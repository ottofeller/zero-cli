schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

input AcceptInvitationInput {
  invitationId: uuid!
  userId: uuid!
}

type AcceptInvitationOutput {
  invitationId: uuid!
  invite: teamInvitation
  teamUser: teamUser
  teamUserId: uuid!
}

input AcceptTeamInviteInput {
  failureAcceptInviteMessage: String!
  successfullAcceptInviteMessage: String!
  teamId: String!
}

type AcceptTeamInviteOutput {
  errorCode: String
  success: Boolean!
}

input AddedTeamsIdsType {
  teamId: String!
  tokenId: String!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

input CancelSubscriptionInput {
  stripeCustomerId: String!
}

type CancelSubscriptionOutput {
  cancelAt: Int
  currentPlan: String
}

input ChangePasswordInput {
  email: String!
  newPassword: String!
  oldPassword: String!
}

type ChangePasswordOutput {
  success: Boolean
}

input ChangeSubscriptionInput {
  priceId: String!
  stripeCustomerId: String!
}

type ChangeSubscriptionOutput {
  success: Boolean
}

input CheckIntegrationDeployInput {
  accountId: String!
}

type CheckIntegrationDeployOutput {
  status: DeployStatusIntegration!
}

input CheckPaymentMethodInput {
  stripeCustomerId: String!
}

type CheckPaymentMethodOutput {
  brand: String
  expirationMonth: Int
  expirationYear: Int
  last4: String
  lastUpdated: Int
}

input CheckUserEmailExistInput {
  email: String!
}

type CheckUserEmailExistOutput {
  isExist: Boolean!
}

input ConfirmEmailChangeInput {
  code: String!
}

type ConfirmEmailChangeOutput {
  accessToken: String!
}

input CreateCustomerInput {
  email: String!
  userId: String!
}

type CreateCustomerOutput {
  stripeCustomerId: String
}

input CreateProjectInput {
  projectIcon: String!
  projectName: String!
  token: TokenObject
}

type CreateProjectOutput {
  errorCode: String
  projectId: String
  tokenValue: String
}

input CreateProjectTokenInput {
  expiresAt: String
  name: String!
  projectId: String!
}

type CreateProjectTokenOutput {
  tokenId: ID!
  tokenValue: String!
}

input CreateSecretFieldInput {
  name: String!
  value: String!
}

input CreateSecretInput {
  name: String!
  tokenId: String!
  vendor: String!
}

type CreateSecretOutput {
  secretId: String!
}

input CreateTeamInput {
  teamName: String!
}

type CreateTeamOutput {
  errorCode: String
  teamId: String!
}

input CurrentPlanInput {
  sessionId: String!
}

type CurrentPlanOutput {
  cancelAt: Int
  currentPlan: String
  interval: String
}

input DecodeSharingSecretsInput {
  id: String!
  passPhrase: String
}

type DecodeSharingSecretsOutput {
  secrets: json!
}

type DecryptedSecretField {
  key: String!
  value: String!
}

input DeleteProjectsInput {
  deleteSecretsOn3rdParty: Boolean
  ids: [uuid!]!
}

type DeleteProjectsOutput {
  affected_rows: Int!
}

enum DeployStatusIntegration {
  CREATE_COMPLETE
  DEPLOY_FAILED
  DEPLOY_IN_PROGRESS
}

type Environment {
  isInUse: Boolean!
  name: String!
}

input GenerateSecretSharingUrlInput {
  expiresAt: timestamptz!
  passPhrase: String
  secretsFieldsIds: [String!]!
  tokenId: String!
}

type GenerateSecretSharingUrlOutput {
  url: String!
}

type InstallationOutput {
  id: String!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input IntegrationAWSInstallInputZero {
  accountId: String!
  integrationId: String!
  projectId: String!
  secretName: String!
  secretsIds: [String]
}

type IntegrationAWSInstallOutput {
  installation: IntegrationAWSInstallOutputInstallation!
}

type IntegrationAWSInstallOutputInstallation {
  id: String!
}

input IntegrationAuthInputIntegration {
  vendorName: String!
}

input IntegrationAuthInputZero {
  userId: String!
}

input IntegrationAuthOAuthInput {
  code: String!
}

type IntegrationAuthOutput {
  id: String!
  response: String!
}

input IntegrationDeleteInput {
  id: String
  installationId: String
  isDeleteInRemoteSourceEnabled: Boolean
}

type IntegrationDeleteOutput {
  success: Boolean!
}

input IntegrationDownloadSecretsInputIntegration {
  installationId: String!
}

input IntegrationDownloadSecretsInputZero {
  projectId: String!
  userId: String!
}

type IntegrationDownloadSecretsOutput {
  secret: SecretOutput!
}

input IntegrationInstallInputIntegration {
  extra: String!
  vendorName: String!
}

input IntegrationInstallInputZero {
  integrationId: String!
  isDownloadSecretsEnabled: Boolean
  projectId: String
  secretsIds: [String]
}

type IntegrationInstallOutput {
  installation: IntegrationInstallOutputInstallation!
}

type IntegrationInstallOutputInstallation {
  id: String!
}

type IntegrationProject {
  environments: [Environment!]!
  id: String!
  isInUse: Boolean!
  name: String!
}

input IntegrationProjectsInput {
  code: String!
  projectId: String!
  vendorName: String!
}

type IntegrationProjectsOutput {
  integrationId: String!
  projects: [IntegrationProject!]!
}

input IntegrationUpdateInputIntegration {
  extra: String
  installationId: String!
}

input IntegrationUpdateInputZero {
  secretsIds: [String]
}

type IntegrationUpdateOutput {
  errors: [String!]
  installation: InstallationOutput!
  success: Boolean!
}

input IntegrationUploadSecretsInputIntegration {
  installationId: String!
}

input IntegrationUploadSecretsInputZero {
  secretsIds: [String]
  userId: String!
}

type IntegrationUploadSecretsOutput {
  success: Boolean!
}

type MeOutput {
  id: ID!
}

type Payment {
  amount: String!
  card: String
  createdAt: String!
  description: String
  id: ID!
  paymentMethod: String
  status: String!
  url: String
}

input PaymentListInput {
  endingBeforePaymentId: ID
  limit: Int!
  startingAfterPaymentId: ID
  stripeCustomerId: String!
}

type PaymentListOutput {
  hasMore: Boolean!
  items: [Payment]!
}

input RecalculateTeamSeatsSubscriptionInput {
  paidSeats: Int!
}

type RecalculateTeamSeatsSubscriptionOutput {
  success: Boolean
}

input RegenerateProjectTokenInput {
  expiresAt: String
  tokenId: String!
}

type RegenerateProjectTokenOutput {
  errorCode: String
  tokenValue: String
}

input RejectTeamInviteInput {
  inviteId: String!
}

type RejectTeamInviteOutput {
  errorCode: String
  success: Boolean!
}

input RemoveTeamInput {
  teamId: String!
}

type RemoveTeamOutput {
  errorCode: String
  success: Boolean!
}

input RemoveUserFromTeamInput {
  ownerTeamUserId: String!
  teamId: String!
  userId: String!
}

type RemoveUserFromTeamOutput {
  errorCode: String
  success: Boolean!
}

input RequestEmailChangeInput {
  newEmail: String!
}

type RequestEmailChangeOutput {
  errorCode: String
  success: Boolean!
}

input RequestResetPasswordInput {
  email: String!
  isReset: Boolean
}

type RequestResetPasswordOutput {
  success: Boolean
}

type ResendSignUpEmailOutput {
  success: Boolean
}

type SecretOutput {
  id: String!
}

input SendInviteUserTeamInput {
  email: String!
  teamId: String!
}

type SendInviteUserTeamOutput {
  errorCode: String
  success: Boolean!
}

input SendNotificationInput {
  message: String!
  userId: uuid!
  users: [uuid!]!
}

type SendNotificationsOutput {
  success: Boolean!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

input TokenObject {
  tokenExpiresAt: String
  tokenName: String
}

input UpdatePaymentMethodInput {
  stripeCustomerId: String!
}

type UpdatePaymentMethodOutput {
  paymentMethod: String
}

input UpdateProjectSettingsInput {
  addedTeamsIds: [AddedTeamsIdsType]!
  icon: String!
  projectDescription: String
  projectId: String!
  projectName: String!
  removedTeamsIds: [String]!
}

type UpdateProjectSettingsOutput {
  errorCode: String
  success: String
}

type UpdateSecretOutput {
  success: Boolean!
}

input UpdateUserSecretFieldsInput {
  decryptedValue: String
  encryptedValue: String
  name: String!
  userSecretId: String!
}

input UpdateUserSecretInput {
  id: String!
  name: String!
}

input ViewSecretFieldsInput {
  secretId: String!
}

type ViewSecretFieldsOutput {
  secretFields: [DecryptedSecretField!]!
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar inet

"""
Boolean expression to compare columns of type "inet". All fields are combined with logical 'AND'.
"""
input inet_comparison_exp {
  _eq: inet
  _gt: inet
  _gte: inet
  _in: [inet!]
  _is_null: Boolean
  _lt: inet
  _lte: inet
  _neq: inet
  _nin: [inet!]
}

"""integration relative data"""
type integration {
  extra(
    """JSON select path"""
    path: String
  ): jsonb
  id: uuid!

  """An array relationship"""
  installations(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): [integrationInstallation!]!

  """An aggregate relationship"""
  installations_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): integrationInstallation_aggregate!
  userId: uuid
  vendorName: integrationVendorNameEnum_enum!
}

"""
Created per each integration installation, should link 3rd party with zero project
"""
type integrationInstallation {
  createdAt: timestamptz!
  extra(
    """JSON select path"""
    path: String
  ): jsonb
  id: uuid!

  """An object relationship"""
  integration: integration
  integrationId: uuid!
  isSuccessful: Boolean
  projectId: uuid

  """An array relationship"""
  secrets(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): [integrationInstallationUserSecret!]!
  vendorProjectName: String!
}

"""
columns and relationships of "integrationInstallationUserSecret"
"""
type integrationInstallationUserSecret {
  id: uuid!

  """An object relationship"""
  integrationInstallation: integrationInstallation
  integrationInstallationId: uuid!

  """An object relationship"""
  secret: userSecret
  userSecretId: uuid!
}

"""
order by aggregate values of table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_aggregate_order_by {
  count: order_by
  max: integrationInstallationUserSecret_max_order_by
  min: integrationInstallationUserSecret_min_order_by
}

"""
input type for inserting array relation for remote table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_arr_rel_insert_input {
  data: [integrationInstallationUserSecret_insert_input!]!

  """upsert condition"""
  on_conflict: integrationInstallationUserSecret_on_conflict
}

"""
Boolean expression to filter rows from the table "integrationInstallationUserSecret". All fields are combined with a logical 'AND'.
"""
input integrationInstallationUserSecret_bool_exp {
  _and: [integrationInstallationUserSecret_bool_exp!]
  _not: integrationInstallationUserSecret_bool_exp
  _or: [integrationInstallationUserSecret_bool_exp!]
  id: uuid_comparison_exp
  integrationInstallation: integrationInstallation_bool_exp
  integrationInstallationId: uuid_comparison_exp
  secret: userSecret_bool_exp
  userSecretId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "integrationInstallationUserSecret"
"""
enum integrationInstallationUserSecret_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  integrationInstallationUserSecret_pkey
}

"""
input type for inserting data into table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_insert_input {
  id: uuid
  integrationInstallationId: uuid
  secret: userSecret_obj_rel_insert_input
  userSecretId: uuid
}

"""
order by max() on columns of table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_max_order_by {
  id: order_by
  integrationInstallationId: order_by
  userSecretId: order_by
}

"""
order by min() on columns of table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_min_order_by {
  id: order_by
  integrationInstallationId: order_by
  userSecretId: order_by
}

"""
response of any mutation on the table "integrationInstallationUserSecret"
"""
type integrationInstallationUserSecret_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [integrationInstallationUserSecret!]!
}

"""
on_conflict condition type for table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_on_conflict {
  constraint: integrationInstallationUserSecret_constraint!
  update_columns: [integrationInstallationUserSecret_update_column!]! = []
  where: integrationInstallationUserSecret_bool_exp
}

"""
Ordering options when selecting data from "integrationInstallationUserSecret".
"""
input integrationInstallationUserSecret_order_by {
  id: order_by
  integrationInstallation: integrationInstallation_order_by
  integrationInstallationId: order_by
  secret: userSecret_order_by
  userSecretId: order_by
}

"""
select columns of table "integrationInstallationUserSecret"
"""
enum integrationInstallationUserSecret_select_column {
  """column name"""
  id

  """column name"""
  integrationInstallationId

  """column name"""
  userSecretId
}

"""
Streaming cursor of the table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: integrationInstallationUserSecret_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input integrationInstallationUserSecret_stream_cursor_value_input {
  id: uuid
  integrationInstallationId: uuid
  userSecretId: uuid
}

"""
placeholder for update columns of table "integrationInstallationUserSecret" (current role has no relevant permissions)
"""
enum integrationInstallationUserSecret_update_column {
  """placeholder (do not use)"""
  _PLACEHOLDER
}

"""
aggregated selection of "integrationInstallation"
"""
type integrationInstallation_aggregate {
  aggregate: integrationInstallation_aggregate_fields
  nodes: [integrationInstallation!]!
}

input integrationInstallation_aggregate_bool_exp {
  bool_and: integrationInstallation_aggregate_bool_exp_bool_and
  bool_or: integrationInstallation_aggregate_bool_exp_bool_or
  count: integrationInstallation_aggregate_bool_exp_count
}

input integrationInstallation_aggregate_bool_exp_bool_and {
  arguments: integrationInstallation_select_column_integrationInstallation_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: integrationInstallation_bool_exp
  predicate: Boolean_comparison_exp!
}

input integrationInstallation_aggregate_bool_exp_bool_or {
  arguments: integrationInstallation_select_column_integrationInstallation_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: integrationInstallation_bool_exp
  predicate: Boolean_comparison_exp!
}

input integrationInstallation_aggregate_bool_exp_count {
  arguments: [integrationInstallation_select_column!]
  distinct: Boolean
  filter: integrationInstallation_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "integrationInstallation"
"""
type integrationInstallation_aggregate_fields {
  count(columns: [integrationInstallation_select_column!], distinct: Boolean): Int!
  max: integrationInstallation_max_fields
  min: integrationInstallation_min_fields
}

"""
order by aggregate values of table "integrationInstallation"
"""
input integrationInstallation_aggregate_order_by {
  count: order_by
  max: integrationInstallation_max_order_by
  min: integrationInstallation_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input integrationInstallation_append_input {
  extra: jsonb
}

"""
Boolean expression to filter rows from the table "integrationInstallation". All fields are combined with a logical 'AND'.
"""
input integrationInstallation_bool_exp {
  _and: [integrationInstallation_bool_exp!]
  _not: integrationInstallation_bool_exp
  _or: [integrationInstallation_bool_exp!]
  createdAt: timestamptz_comparison_exp
  extra: jsonb_comparison_exp
  id: uuid_comparison_exp
  integration: integration_bool_exp
  integrationId: uuid_comparison_exp
  isSuccessful: Boolean_comparison_exp
  projectId: uuid_comparison_exp
  secrets: integrationInstallationUserSecret_bool_exp
  vendorProjectName: String_comparison_exp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input integrationInstallation_delete_at_path_input {
  extra: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input integrationInstallation_delete_elem_input {
  extra: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input integrationInstallation_delete_key_input {
  extra: String
}

"""aggregate max on columns"""
type integrationInstallation_max_fields {
  createdAt: timestamptz
  id: uuid
  integrationId: uuid
  projectId: uuid
  vendorProjectName: String
}

"""
order by max() on columns of table "integrationInstallation"
"""
input integrationInstallation_max_order_by {
  createdAt: order_by
  id: order_by
  integrationId: order_by
  projectId: order_by
  vendorProjectName: order_by
}

"""aggregate min on columns"""
type integrationInstallation_min_fields {
  createdAt: timestamptz
  id: uuid
  integrationId: uuid
  projectId: uuid
  vendorProjectName: String
}

"""
order by min() on columns of table "integrationInstallation"
"""
input integrationInstallation_min_order_by {
  createdAt: order_by
  id: order_by
  integrationId: order_by
  projectId: order_by
  vendorProjectName: order_by
}

"""
response of any mutation on the table "integrationInstallation"
"""
type integrationInstallation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [integrationInstallation!]!
}

"""Ordering options when selecting data from "integrationInstallation"."""
input integrationInstallation_order_by {
  createdAt: order_by
  extra: order_by
  id: order_by
  integration: integration_order_by
  integrationId: order_by
  isSuccessful: order_by
  projectId: order_by
  secrets_aggregate: integrationInstallationUserSecret_aggregate_order_by
  vendorProjectName: order_by
}

"""primary key columns input for table: integrationInstallation"""
input integrationInstallation_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input integrationInstallation_prepend_input {
  extra: jsonb
}

"""
select columns of table "integrationInstallation"
"""
enum integrationInstallation_select_column {
  """column name"""
  createdAt

  """column name"""
  extra

  """column name"""
  id

  """column name"""
  integrationId

  """column name"""
  isSuccessful

  """column name"""
  projectId

  """column name"""
  vendorProjectName
}

"""
select "integrationInstallation_aggregate_bool_exp_bool_and_arguments_columns" columns of table "integrationInstallation"
"""
enum integrationInstallation_select_column_integrationInstallation_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  isSuccessful
}

"""
select "integrationInstallation_aggregate_bool_exp_bool_or_arguments_columns" columns of table "integrationInstallation"
"""
enum integrationInstallation_select_column_integrationInstallation_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  isSuccessful
}

"""
input type for updating data in table "integrationInstallation"
"""
input integrationInstallation_set_input {
  extra: jsonb
}

"""
Streaming cursor of the table "integrationInstallation"
"""
input integrationInstallation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: integrationInstallation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input integrationInstallation_stream_cursor_value_input {
  createdAt: timestamptz
  extra: jsonb
  id: uuid
  integrationId: uuid
  isSuccessful: Boolean
  projectId: uuid
  vendorProjectName: String
}

input integrationInstallation_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: integrationInstallation_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: integrationInstallation_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: integrationInstallation_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: integrationInstallation_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: integrationInstallation_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: integrationInstallation_set_input

  """filter the rows which have to be updated"""
  where: integrationInstallation_bool_exp!
}

enum integrationVendorNameEnum_enum {
  aws
  netlify
  vercel
}

"""
Boolean expression to compare columns of type "integrationVendorNameEnum_enum". All fields are combined with logical 'AND'.
"""
input integrationVendorNameEnum_enum_comparison_exp {
  _eq: integrationVendorNameEnum_enum
  _in: [integrationVendorNameEnum_enum!]
  _is_null: Boolean
  _neq: integrationVendorNameEnum_enum
  _nin: [integrationVendorNameEnum_enum!]
}

"""
Boolean expression to filter rows from the table "integration". All fields are combined with a logical 'AND'.
"""
input integration_bool_exp {
  _and: [integration_bool_exp!]
  _not: integration_bool_exp
  _or: [integration_bool_exp!]
  extra: jsonb_comparison_exp
  id: uuid_comparison_exp
  installations: integrationInstallation_bool_exp
  installations_aggregate: integrationInstallation_aggregate_bool_exp
  userId: uuid_comparison_exp
  vendorName: integrationVendorNameEnum_enum_comparison_exp
}

"""Ordering options when selecting data from "integration"."""
input integration_order_by {
  extra: order_by
  id: order_by
  installations_aggregate: integrationInstallation_aggregate_order_by
  userId: order_by
  vendorName: order_by
}

"""
select columns of table "integration"
"""
enum integration_select_column {
  """column name"""
  extra

  """column name"""
  id

  """column name"""
  userId

  """column name"""
  vendorName
}

"""
Streaming cursor of the table "integration"
"""
input integration_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: integration_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input integration_stream_cursor_value_input {
  extra: jsonb
  id: uuid
  userId: uuid
  vendorName: integrationVendorNameEnum_enum
}

enum invitationStatusEnum_enum {
  ACCEPT
  PENDING
  REJECT
}

"""
Boolean expression to compare columns of type "invitationStatusEnum_enum". All fields are combined with logical 'AND'.
"""
input invitationStatusEnum_enum_comparison_exp {
  _eq: invitationStatusEnum_enum
  _in: [invitationStatusEnum_enum!]
  _is_null: Boolean
  _neq: invitationStatusEnum_enum
  _nin: [invitationStatusEnum_enum!]
}

scalar json

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

enum listIdEnum_enum {
  integrations
  projects
  secrets
  teams
  users
}

"""
Boolean expression to compare columns of type "listIdEnum_enum". All fields are combined with logical 'AND'.
"""
input listIdEnum_enum_comparison_exp {
  _eq: listIdEnum_enum
  _in: [listIdEnum_enum!]
  _is_null: Boolean
  _neq: listIdEnum_enum
  _nin: [listIdEnum_enum!]
}

"""mutation root"""
type mutation_root {
  """Accept team invitation"""
  acceptInvitation(object: AcceptInvitationInput!): AcceptInvitationOutput
  acceptTeamInvite(object: AcceptTeamInviteInput!): AcceptTeamInviteOutput!
  cancelSubscription(object: CancelSubscriptionInput!): CancelSubscriptionOutput!
  changePassword(object: ChangePasswordInput!): ChangePasswordOutput!
  changeSubscription(object: ChangeSubscriptionInput!): ChangeSubscriptionOutput!
  confirmEmailChange(object: ConfirmEmailChangeInput!): ConfirmEmailChangeOutput!
  createCustomer(object: CreateCustomerInput!): CreateCustomerOutput!
  createProject(object: CreateProjectInput!): CreateProjectOutput!
  createProjectToken(object: CreateProjectTokenInput!): CreateProjectTokenOutput!
  createSecret(fields: [CreateSecretFieldInput!]!, secret: CreateSecretInput!, userId: String!): CreateSecretOutput!
  createTeam(object: CreateTeamInput!): CreateTeamOutput!

  """Release (represent and erase) shared secrets"""
  decodeSharingSecrets(object: DecodeSharingSecretsInput!): DecodeSharingSecretsOutput!

  """
  deletes specified projects, all its relations and optionally deletes 3rd party secrets
  """
  deleteProjects(object: DeleteProjectsInput!): DeleteProjectsOutput

  """
  delete data from the table: "integrationInstallation"
  """
  delete_integrationInstallation(
    """filter the rows which have to be deleted"""
    where: integrationInstallation_bool_exp!
  ): integrationInstallation_mutation_response

  """
  delete data from the table: "integrationInstallationUserSecret"
  """
  delete_integrationInstallationUserSecret(
    """filter the rows which have to be deleted"""
    where: integrationInstallationUserSecret_bool_exp!
  ): integrationInstallationUserSecret_mutation_response

  """
  delete single row from the table: "integrationInstallationUserSecret"
  """
  delete_integrationInstallationUserSecret_by_pk(id: uuid!): integrationInstallationUserSecret

  """
  delete single row from the table: "integrationInstallation"
  """
  delete_integrationInstallation_by_pk(id: uuid!): integrationInstallation

  """
  delete data from the table: "projectToken"
  """
  delete_projectToken(
    """filter the rows which have to be deleted"""
    where: projectToken_bool_exp!
  ): projectToken_mutation_response

  """
  delete single row from the table: "projectToken"
  """
  delete_projectToken_by_pk(id: uuid!): projectToken

  """
  delete data from the table: "tag"
  """
  delete_tag(
    """filter the rows which have to be deleted"""
    where: tag_bool_exp!
  ): tag_mutation_response

  """
  delete single row from the table: "tag"
  """
  delete_tag_by_pk(id: uuid!): tag

  """
  delete data from the table: "team"
  """
  delete_team(
    """filter the rows which have to be deleted"""
    where: team_bool_exp!
  ): team_mutation_response

  """
  delete data from the table: "teamInvitation"
  """
  delete_teamInvitation(
    """filter the rows which have to be deleted"""
    where: teamInvitation_bool_exp!
  ): teamInvitation_mutation_response

  """
  delete single row from the table: "teamInvitation"
  """
  delete_teamInvitation_by_pk(id: uuid!): teamInvitation

  """
  delete single row from the table: "team"
  """
  delete_team_by_pk(id: uuid!): team

  """
  delete data from the table: "token"
  """
  delete_token(
    """filter the rows which have to be deleted"""
    where: token_bool_exp!
  ): token_mutation_response

  """
  delete data from the table: "tokenTag"
  """
  delete_tokenTag(
    """filter the rows which have to be deleted"""
    where: tokenTag_bool_exp!
  ): tokenTag_mutation_response

  """
  delete single row from the table: "tokenTag"
  """
  delete_tokenTag_by_pk(id: uuid!): tokenTag

  """
  delete data from the table: "tokenTeam"
  """
  delete_tokenTeam(
    """filter the rows which have to be deleted"""
    where: tokenTeam_bool_exp!
  ): tokenTeam_mutation_response

  """
  delete single row from the table: "tokenTeam"
  """
  delete_tokenTeam_by_pk(id: uuid!): tokenTeam

  """
  delete single row from the table: "token"
  """
  delete_token_by_pk(id: uuid!): token

  """
  delete data from the table: "userSecret"
  """
  delete_userSecret(
    """filter the rows which have to be deleted"""
    where: userSecret_bool_exp!
  ): userSecret_mutation_response

  """
  delete data from the table: "userSecretField"
  """
  delete_userSecretField(
    """filter the rows which have to be deleted"""
    where: userSecretField_bool_exp!
  ): userSecretField_mutation_response

  """
  delete single row from the table: "userSecretField"
  """
  delete_userSecretField_by_pk(id: uuid!): userSecretField

  """
  delete single row from the table: "userSecret"
  """
  delete_userSecret_by_pk(id: uuid!): userSecret

  """Share secrets by URL"""
  generateSecretSharingUrl(object: GenerateSecretSharingUrlInput!): GenerateSecretSharingUrlOutput!

  """
  insert data into the table: "integrationInstallationUserSecret"
  """
  insert_integrationInstallationUserSecret(
    """the rows to be inserted"""
    objects: [integrationInstallationUserSecret_insert_input!]!

    """upsert condition"""
    on_conflict: integrationInstallationUserSecret_on_conflict
  ): integrationInstallationUserSecret_mutation_response

  """
  insert a single row into the table: "integrationInstallationUserSecret"
  """
  insert_integrationInstallationUserSecret_one(
    """the row to be inserted"""
    object: integrationInstallationUserSecret_insert_input!

    """upsert condition"""
    on_conflict: integrationInstallationUserSecret_on_conflict
  ): integrationInstallationUserSecret

  """
  insert data into the table: "notification"
  """
  insert_notification(
    """the rows to be inserted"""
    objects: [notification_insert_input!]!

    """upsert condition"""
    on_conflict: notification_on_conflict
  ): notification_mutation_response

  """
  insert data into the table: "notificationUser"
  """
  insert_notificationUser(
    """the rows to be inserted"""
    objects: [notificationUser_insert_input!]!

    """upsert condition"""
    on_conflict: notificationUser_on_conflict
  ): notificationUser_mutation_response

  """
  insert a single row into the table: "notificationUser"
  """
  insert_notificationUser_one(
    """the row to be inserted"""
    object: notificationUser_insert_input!

    """upsert condition"""
    on_conflict: notificationUser_on_conflict
  ): notificationUser

  """
  insert a single row into the table: "notification"
  """
  insert_notification_one(
    """the row to be inserted"""
    object: notification_insert_input!

    """upsert condition"""
    on_conflict: notification_on_conflict
  ): notification

  """
  insert data into the table: "tag"
  """
  insert_tag(
    """the rows to be inserted"""
    objects: [tag_insert_input!]!

    """upsert condition"""
    on_conflict: tag_on_conflict
  ): tag_mutation_response

  """
  insert a single row into the table: "tag"
  """
  insert_tag_one(
    """the row to be inserted"""
    object: tag_insert_input!

    """upsert condition"""
    on_conflict: tag_on_conflict
  ): tag

  """
  insert data into the table: "teamInvitation"
  """
  insert_teamInvitation(
    """the rows to be inserted"""
    objects: [teamInvitation_insert_input!]!

    """upsert condition"""
    on_conflict: teamInvitation_on_conflict
  ): teamInvitation_mutation_response

  """
  insert a single row into the table: "teamInvitation"
  """
  insert_teamInvitation_one(
    """the row to be inserted"""
    object: teamInvitation_insert_input!

    """upsert condition"""
    on_conflict: teamInvitation_on_conflict
  ): teamInvitation

  """
  insert data into the table: "teamUser"
  """
  insert_teamUser(
    """the rows to be inserted"""
    objects: [teamUser_insert_input!]!

    """upsert condition"""
    on_conflict: teamUser_on_conflict
  ): teamUser_mutation_response

  """
  insert a single row into the table: "teamUser"
  """
  insert_teamUser_one(
    """the row to be inserted"""
    object: teamUser_insert_input!

    """upsert condition"""
    on_conflict: teamUser_on_conflict
  ): teamUser

  """
  insert data into the table: "tokenTag"
  """
  insert_tokenTag(
    """the rows to be inserted"""
    objects: [tokenTag_insert_input!]!

    """upsert condition"""
    on_conflict: tokenTag_on_conflict
  ): tokenTag_mutation_response

  """
  insert a single row into the table: "tokenTag"
  """
  insert_tokenTag_one(
    """the row to be inserted"""
    object: tokenTag_insert_input!

    """upsert condition"""
    on_conflict: tokenTag_on_conflict
  ): tokenTag

  """
  insert data into the table: "tokenTeam"
  """
  insert_tokenTeam(
    """the rows to be inserted"""
    objects: [tokenTeam_insert_input!]!

    """upsert condition"""
    on_conflict: tokenTeam_on_conflict
  ): tokenTeam_mutation_response

  """
  insert a single row into the table: "tokenTeam"
  """
  insert_tokenTeam_one(
    """the row to be inserted"""
    object: tokenTeam_insert_input!

    """upsert condition"""
    on_conflict: tokenTeam_on_conflict
  ): tokenTeam

  """
  insert data into the table: "userSecret"
  """
  insert_userSecret(
    """the rows to be inserted"""
    objects: [userSecret_insert_input!]!

    """upsert condition"""
    on_conflict: userSecret_on_conflict
  ): userSecret_mutation_response

  """
  insert data into the table: "userSecretField"
  """
  insert_userSecretField(
    """the rows to be inserted"""
    objects: [userSecretField_insert_input!]!

    """upsert condition"""
    on_conflict: userSecretField_on_conflict
  ): userSecretField_mutation_response

  """
  insert a single row into the table: "userSecretField"
  """
  insert_userSecretField_one(
    """the row to be inserted"""
    object: userSecretField_insert_input!

    """upsert condition"""
    on_conflict: userSecretField_on_conflict
  ): userSecretField

  """
  insert a single row into the table: "userSecret"
  """
  insert_userSecret_one(
    """the row to be inserted"""
    object: userSecret_insert_input!

    """upsert condition"""
    on_conflict: userSecret_on_conflict
  ): userSecret

  """
  insert data into the table: "viewPreferences"
  """
  insert_viewPreferences(
    """the rows to be inserted"""
    objects: [viewPreferences_insert_input!]!

    """upsert condition"""
    on_conflict: viewPreferences_on_conflict
  ): viewPreferences_mutation_response

  """
  insert a single row into the table: "viewPreferences"
  """
  insert_viewPreferences_one(
    """the row to be inserted"""
    object: viewPreferences_insert_input!

    """upsert condition"""
    on_conflict: viewPreferences_on_conflict
  ): viewPreferences
  integrationAWSInstall(zero: IntegrationAWSInstallInputZero!): IntegrationAWSInstallOutput!
  integrationAuth(integration: IntegrationAuthInputIntegration!, oauth: IntegrationAuthOAuthInput!, zero: IntegrationAuthInputZero!): IntegrationAuthOutput!
  integrationDelete(integration: IntegrationDeleteInput!): IntegrationDeleteOutput!
  integrationDownloadSecrets(integration: IntegrationDownloadSecretsInputIntegration!, zero: IntegrationDownloadSecretsInputZero!): IntegrationDownloadSecretsOutput!
  integrationInstall(integration: IntegrationInstallInputIntegration!, zero: IntegrationInstallInputZero!): IntegrationInstallOutput!
  integrationUpdate(integration: IntegrationUpdateInputIntegration!, zero: IntegrationUpdateInputZero!): IntegrationUpdateOutput!
  integrationUploadSecrets(integration: IntegrationUploadSecretsInputIntegration!, zero: IntegrationUploadSecretsInputZero!): IntegrationUploadSecretsOutput!
  recalculateTeamSeatsSubscription(object: RecalculateTeamSeatsSubscriptionInput!): RecalculateTeamSeatsSubscriptionOutput!
  regenerateProjectToken(object: RegenerateProjectTokenInput!): RegenerateProjectTokenOutput!
  rejectTeamInvite(object: RejectTeamInviteInput!): RejectTeamInviteOutput!
  removeTeam(object: RemoveTeamInput!): RemoveTeamOutput!
  removeUserFromTeam(object: RemoveUserFromTeamInput!): RemoveUserFromTeamOutput!
  requestEmailChange(object: RequestEmailChangeInput!): RequestEmailChangeOutput!
  requestResetPassword(object: RequestResetPasswordInput!): RequestResetPasswordOutput!
  resendSignUpEmail: ResendSignUpEmailOutput!
  sendInviteUserTeam(object: SendInviteUserTeamInput!): SendInviteUserTeamOutput!

  """Send notifications"""
  sendNotifications(objects: [SendNotificationInput!]!): uuid!
  updatePaymentMethod(object: UpdatePaymentMethodInput!): UpdatePaymentMethodOutput!
  updateProjectSettings(object: UpdateProjectSettingsInput!): UpdateProjectSettingsOutput!
  updateSecret(userSecret: UpdateUserSecretInput!, userSecretFields: [UpdateUserSecretFieldsInput!]!): UpdateSecretOutput!

  """
  update data of the table: "integrationInstallation"
  """
  update_integrationInstallation(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: integrationInstallation_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: integrationInstallation_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: integrationInstallation_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: integrationInstallation_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: integrationInstallation_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: integrationInstallation_set_input

    """filter the rows which have to be updated"""
    where: integrationInstallation_bool_exp!
  ): integrationInstallation_mutation_response

  """
  update single row of the table: "integrationInstallation"
  """
  update_integrationInstallation_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: integrationInstallation_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: integrationInstallation_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: integrationInstallation_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: integrationInstallation_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: integrationInstallation_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: integrationInstallation_set_input
    pk_columns: integrationInstallation_pk_columns_input!
  ): integrationInstallation

  """
  update multiples rows of table: "integrationInstallation"
  """
  update_integrationInstallation_many(
    """updates to execute, in order"""
    updates: [integrationInstallation_updates!]!
  ): [integrationInstallation_mutation_response]

  """
  update data of the table: "notification"
  """
  update_notification(
    """sets the columns of the filtered rows to the given values"""
    _set: notification_set_input

    """filter the rows which have to be updated"""
    where: notification_bool_exp!
  ): notification_mutation_response

  """
  update single row of the table: "notification"
  """
  update_notification_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notification_set_input
    pk_columns: notification_pk_columns_input!
  ): notification

  """
  update multiples rows of table: "notification"
  """
  update_notification_many(
    """updates to execute, in order"""
    updates: [notification_updates!]!
  ): [notification_mutation_response]

  """
  update data of the table: "projectToken"
  """
  update_projectToken(
    """sets the columns of the filtered rows to the given values"""
    _set: projectToken_set_input

    """filter the rows which have to be updated"""
    where: projectToken_bool_exp!
  ): projectToken_mutation_response

  """
  update single row of the table: "projectToken"
  """
  update_projectToken_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: projectToken_set_input
    pk_columns: projectToken_pk_columns_input!
  ): projectToken

  """
  update multiples rows of table: "projectToken"
  """
  update_projectToken_many(
    """updates to execute, in order"""
    updates: [projectToken_updates!]!
  ): [projectToken_mutation_response]

  """
  update data of the table: "team"
  """
  update_team(
    """sets the columns of the filtered rows to the given values"""
    _set: team_set_input

    """filter the rows which have to be updated"""
    where: team_bool_exp!
  ): team_mutation_response

  """
  update data of the table: "teamUser"
  """
  update_teamUser(
    """sets the columns of the filtered rows to the given values"""
    _set: teamUser_set_input

    """filter the rows which have to be updated"""
    where: teamUser_bool_exp!
  ): teamUser_mutation_response

  """
  update single row of the table: "teamUser"
  """
  update_teamUser_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: teamUser_set_input
    pk_columns: teamUser_pk_columns_input!
  ): teamUser

  """
  update multiples rows of table: "teamUser"
  """
  update_teamUser_many(
    """updates to execute, in order"""
    updates: [teamUser_updates!]!
  ): [teamUser_mutation_response]

  """
  update single row of the table: "team"
  """
  update_team_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: team_set_input
    pk_columns: team_pk_columns_input!
  ): team

  """
  update multiples rows of table: "team"
  """
  update_team_many(
    """updates to execute, in order"""
    updates: [team_updates!]!
  ): [team_mutation_response]

  """
  update data of the table: "token"
  """
  update_token(
    """sets the columns of the filtered rows to the given values"""
    _set: token_set_input

    """filter the rows which have to be updated"""
    where: token_bool_exp!
  ): token_mutation_response

  """
  update data of the table: "tokenTag"
  """
  update_tokenTag(
    """sets the columns of the filtered rows to the given values"""
    _set: tokenTag_set_input

    """filter the rows which have to be updated"""
    where: tokenTag_bool_exp!
  ): tokenTag_mutation_response

  """
  update single row of the table: "tokenTag"
  """
  update_tokenTag_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: tokenTag_set_input
    pk_columns: tokenTag_pk_columns_input!
  ): tokenTag

  """
  update multiples rows of table: "tokenTag"
  """
  update_tokenTag_many(
    """updates to execute, in order"""
    updates: [tokenTag_updates!]!
  ): [tokenTag_mutation_response]

  """
  update data of the table: "tokenTeam"
  """
  update_tokenTeam(
    """sets the columns of the filtered rows to the given values"""
    _set: tokenTeam_set_input

    """filter the rows which have to be updated"""
    where: tokenTeam_bool_exp!
  ): tokenTeam_mutation_response

  """
  update single row of the table: "tokenTeam"
  """
  update_tokenTeam_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: tokenTeam_set_input
    pk_columns: tokenTeam_pk_columns_input!
  ): tokenTeam

  """
  update multiples rows of table: "tokenTeam"
  """
  update_tokenTeam_many(
    """updates to execute, in order"""
    updates: [tokenTeam_updates!]!
  ): [tokenTeam_mutation_response]

  """
  update single row of the table: "token"
  """
  update_token_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: token_set_input
    pk_columns: token_pk_columns_input!
  ): token

  """
  update multiples rows of table: "token"
  """
  update_token_many(
    """updates to execute, in order"""
    updates: [token_updates!]!
  ): [token_mutation_response]

  """
  update data of the table: "user"
  """
  update_user(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update data of the table: "userSecret"
  """
  update_userSecret(
    """sets the columns of the filtered rows to the given values"""
    _set: userSecret_set_input

    """filter the rows which have to be updated"""
    where: userSecret_bool_exp!
  ): userSecret_mutation_response

  """
  update data of the table: "userSecretField"
  """
  update_userSecretField(
    """sets the columns of the filtered rows to the given values"""
    _set: userSecretField_set_input

    """filter the rows which have to be updated"""
    where: userSecretField_bool_exp!
  ): userSecretField_mutation_response

  """
  update single row of the table: "userSecretField"
  """
  update_userSecretField_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: userSecretField_set_input
    pk_columns: userSecretField_pk_columns_input!
  ): userSecretField

  """
  update multiples rows of table: "userSecretField"
  """
  update_userSecretField_many(
    """updates to execute, in order"""
    updates: [userSecretField_updates!]!
  ): [userSecretField_mutation_response]

  """
  update single row of the table: "userSecret"
  """
  update_userSecret_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: userSecret_set_input
    pk_columns: userSecret_pk_columns_input!
  ): userSecret

  """
  update multiples rows of table: "userSecret"
  """
  update_userSecret_many(
    """updates to execute, in order"""
    updates: [userSecret_updates!]!
  ): [userSecret_mutation_response]

  """
  update data of the table: "userSubscription"
  """
  update_userSubscription(
    """sets the columns of the filtered rows to the given values"""
    _set: userSubscription_set_input

    """filter the rows which have to be updated"""
    where: userSubscription_bool_exp!
  ): userSubscription_mutation_response

  """
  update single row of the table: "userSubscription"
  """
  update_userSubscription_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: userSubscription_set_input
    pk_columns: userSubscription_pk_columns_input!
  ): userSubscription

  """
  update multiples rows of table: "userSubscription"
  """
  update_userSubscription_many(
    """updates to execute, in order"""
    updates: [userSubscription_updates!]!
  ): [userSubscription_mutation_response]

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  update multiples rows of table: "user"
  """
  update_user_many(
    """updates to execute, in order"""
    updates: [user_updates!]!
  ): [user_mutation_response]

  """
  update data of the table: "viewPreferences"
  """
  update_viewPreferences(
    """sets the columns of the filtered rows to the given values"""
    _set: viewPreferences_set_input

    """filter the rows which have to be updated"""
    where: viewPreferences_bool_exp!
  ): viewPreferences_mutation_response

  """
  update single row of the table: "viewPreferences"
  """
  update_viewPreferences_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: viewPreferences_set_input
    pk_columns: viewPreferences_pk_columns_input!
  ): viewPreferences

  """
  update multiples rows of table: "viewPreferences"
  """
  update_viewPreferences_many(
    """updates to execute, in order"""
    updates: [viewPreferences_updates!]!
  ): [viewPreferences_mutation_response]
}

"""
columns and relationships of "notification"
"""
type notification {
  createdAt: timestamp!
  id: uuid!
  isViewed: Boolean!
  message: String!
  updatedAt: timestamp!

  """An object relationship"""
  user: user!
  userId: uuid!

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!
}

"""
columns and relationships of "notificationUser"
"""
type notificationUser {
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  notification: notification!
  notificationId: uuid!
  updatedAt: timestamptz!

  """An object relationship"""
  user: user!
  userId: uuid!
}

"""
order by aggregate values of table "notificationUser"
"""
input notificationUser_aggregate_order_by {
  count: order_by
  max: notificationUser_max_order_by
  min: notificationUser_min_order_by
}

"""
input type for inserting array relation for remote table "notificationUser"
"""
input notificationUser_arr_rel_insert_input {
  data: [notificationUser_insert_input!]!

  """upsert condition"""
  on_conflict: notificationUser_on_conflict
}

"""
Boolean expression to filter rows from the table "notificationUser". All fields are combined with a logical 'AND'.
"""
input notificationUser_bool_exp {
  _and: [notificationUser_bool_exp!]
  _not: notificationUser_bool_exp
  _or: [notificationUser_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  notification: notification_bool_exp
  notificationId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: user_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "notificationUser"
"""
enum notificationUser_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notificationUser_pkey
}

"""
input type for inserting data into table "notificationUser"
"""
input notificationUser_insert_input {
  notification: notification_obj_rel_insert_input
  notificationId: uuid
  userId: uuid
}

"""
order by max() on columns of table "notificationUser"
"""
input notificationUser_max_order_by {
  createdAt: order_by
  id: order_by
  notificationId: order_by
  updatedAt: order_by
  userId: order_by
}

"""
order by min() on columns of table "notificationUser"
"""
input notificationUser_min_order_by {
  createdAt: order_by
  id: order_by
  notificationId: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "notificationUser"
"""
type notificationUser_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notificationUser!]!
}

"""
on_conflict condition type for table "notificationUser"
"""
input notificationUser_on_conflict {
  constraint: notificationUser_constraint!
  update_columns: [notificationUser_update_column!]! = []
  where: notificationUser_bool_exp
}

"""Ordering options when selecting data from "notificationUser"."""
input notificationUser_order_by {
  createdAt: order_by
  id: order_by
  notification: notification_order_by
  notificationId: order_by
  updatedAt: order_by
  user: user_order_by
  userId: order_by
}

"""
select columns of table "notificationUser"
"""
enum notificationUser_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  notificationId

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
Streaming cursor of the table "notificationUser"
"""
input notificationUser_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notificationUser_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notificationUser_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  notificationId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
placeholder for update columns of table "notificationUser" (current role has no relevant permissions)
"""
enum notificationUser_update_column {
  """placeholder (do not use)"""
  _PLACEHOLDER
}

"""
Boolean expression to filter rows from the table "notification". All fields are combined with a logical 'AND'.
"""
input notification_bool_exp {
  _and: [notification_bool_exp!]
  _not: notification_bool_exp
  _or: [notification_bool_exp!]
  createdAt: timestamp_comparison_exp
  id: uuid_comparison_exp
  isViewed: Boolean_comparison_exp
  message: String_comparison_exp
  updatedAt: timestamp_comparison_exp
  user: user_bool_exp
  userId: uuid_comparison_exp
  users: notificationUser_bool_exp
}

"""
unique or primary key constraints on table "notification"
"""
enum notification_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notification_pkey
}

"""
input type for inserting data into table "notification"
"""
input notification_insert_input {
  message: String
  userId: uuid
  users: notificationUser_arr_rel_insert_input
}

"""
response of any mutation on the table "notification"
"""
type notification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notification!]!
}

"""
input type for inserting object relation for remote table "notification"
"""
input notification_obj_rel_insert_input {
  data: notification_insert_input!

  """upsert condition"""
  on_conflict: notification_on_conflict
}

"""
on_conflict condition type for table "notification"
"""
input notification_on_conflict {
  constraint: notification_constraint!
  update_columns: [notification_update_column!]! = []
  where: notification_bool_exp
}

"""Ordering options when selecting data from "notification"."""
input notification_order_by {
  createdAt: order_by
  id: order_by
  isViewed: order_by
  message: order_by
  updatedAt: order_by
  user: user_order_by
  userId: order_by
  users_aggregate: notificationUser_aggregate_order_by
}

"""primary key columns input for table: notification"""
input notification_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notification"
"""
enum notification_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isViewed

  """column name"""
  message

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "notification"
"""
input notification_set_input {
  isViewed: Boolean
}

"""
Streaming cursor of the table "notification"
"""
input notification_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notification_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notification_stream_cursor_value_input {
  createdAt: timestamp
  id: uuid
  isViewed: Boolean
  message: String
  updatedAt: timestamp
  userId: uuid
}

"""
update columns of table "notification"
"""
enum notification_update_column {
  """column name"""
  isViewed
}

input notification_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notification_set_input

  """filter the rows which have to be updated"""
  where: notification_bool_exp!
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""Table for storing user project tokens."""
type projectToken {
  created_at: timestamptz!
  expiresAt: timestamptz
  id: uuid!
  name: String!
  projectId: uuid!

  """An object relationship"""
  projectToken_project: token!
  updated_at: timestamptz!
}

"""
order by aggregate values of table "projectToken"
"""
input projectToken_aggregate_order_by {
  count: order_by
  max: projectToken_max_order_by
  min: projectToken_min_order_by
}

"""
Boolean expression to filter rows from the table "projectToken". All fields are combined with a logical 'AND'.
"""
input projectToken_bool_exp {
  _and: [projectToken_bool_exp!]
  _not: projectToken_bool_exp
  _or: [projectToken_bool_exp!]
  created_at: timestamptz_comparison_exp
  expiresAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  projectId: uuid_comparison_exp
  projectToken_project: token_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
order by max() on columns of table "projectToken"
"""
input projectToken_max_order_by {
  created_at: order_by
  expiresAt: order_by
  id: order_by
  name: order_by
  projectId: order_by
  updated_at: order_by
}

"""
order by min() on columns of table "projectToken"
"""
input projectToken_min_order_by {
  created_at: order_by
  expiresAt: order_by
  id: order_by
  name: order_by
  projectId: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "projectToken"
"""
type projectToken_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [projectToken!]!
}

"""Ordering options when selecting data from "projectToken"."""
input projectToken_order_by {
  created_at: order_by
  expiresAt: order_by
  id: order_by
  name: order_by
  projectId: order_by
  projectToken_project: token_order_by
  updated_at: order_by
}

"""primary key columns input for table: projectToken"""
input projectToken_pk_columns_input {
  id: uuid!
}

"""
select columns of table "projectToken"
"""
enum projectToken_select_column {
  """column name"""
  created_at

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  projectId

  """column name"""
  updated_at
}

"""
input type for updating data in table "projectToken"
"""
input projectToken_set_input {
  name: String
}

"""
Streaming cursor of the table "projectToken"
"""
input projectToken_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: projectToken_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input projectToken_stream_cursor_value_input {
  created_at: timestamptz
  expiresAt: timestamptz
  id: uuid
  name: String
  projectId: uuid
  updated_at: timestamptz
}

input projectToken_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: projectToken_set_input

  """filter the rows which have to be updated"""
  where: projectToken_bool_exp!
}

type query_root {
  IntegrationProjects(where: IntegrationProjectsInput!): IntegrationProjectsOutput!
  checkIntegrationDeploy(integration: CheckIntegrationDeployInput!): CheckIntegrationDeployOutput!
  checkPaymentMethod(where: CheckPaymentMethodInput!): CheckPaymentMethodOutput!
  checkUserEmailExist(object: CheckUserEmailExistInput!): CheckUserEmailExistOutput!
  currentPlan(where: CurrentPlanInput!): CurrentPlanOutput!

  """
  fetch data from the table: "integration"
  """
  integration(
    """distinct select on columns"""
    distinct_on: [integration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integration_order_by!]

    """filter the rows returned"""
    where: integration_bool_exp
  ): [integration!]!

  """
  fetch data from the table: "integrationInstallation"
  """
  integrationInstallation(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): [integrationInstallation!]!

  """
  fetch data from the table: "integrationInstallationUserSecret"
  """
  integrationInstallationUserSecret(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): [integrationInstallationUserSecret!]!

  """
  fetch data from the table: "integrationInstallationUserSecret" using primary key columns
  """
  integrationInstallationUserSecret_by_pk(id: uuid!): integrationInstallationUserSecret

  """
  fetch aggregated fields from the table: "integrationInstallation"
  """
  integrationInstallation_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): integrationInstallation_aggregate!

  """
  fetch data from the table: "integrationInstallation" using primary key columns
  """
  integrationInstallation_by_pk(id: uuid!): integrationInstallation

  """fetch data from the table: "integration" using primary key columns"""
  integration_by_pk(id: uuid!): integration
  me: MeOutput!

  """
  fetch data from the table: "notification"
  """
  notification(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """
  fetch data from the table: "notificationUser"
  """
  notificationUser(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!

  """
  fetch data from the table: "notificationUser" using primary key columns
  """
  notificationUser_by_pk(id: uuid!): notificationUser

  """fetch data from the table: "notification" using primary key columns"""
  notification_by_pk(id: uuid!): notification
  paymentList(where: PaymentListInput!): PaymentListOutput!

  """
  fetch data from the table: "projectToken"
  """
  projectToken(
    """distinct select on columns"""
    distinct_on: [projectToken_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [projectToken_order_by!]

    """filter the rows returned"""
    where: projectToken_bool_exp
  ): [projectToken!]!

  """fetch data from the table: "projectToken" using primary key columns"""
  projectToken_by_pk(id: uuid!): projectToken

  """
  execute function "search_project_by_id" which returns "token"
  """
  search_project_by_id(
    """
    input parameters for function "search_project_by_id"
    """
    args: search_project_by_id_args!

    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  execute function "search_project_by_id" and query aggregates on result of table type "token"
  """
  search_project_by_id_aggregate(
    """
    input parameters for function "search_project_by_id_aggregate"
    """
    args: search_project_by_id_args!

    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """
  execute function "search_team_by_id" which returns "team"
  """
  search_team_by_id(
    """
    input parameters for function "search_team_by_id"
    """
    args: search_team_by_id_args!

    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """
  execute function "search_team_by_id" and query aggregates on result of table type "team"
  """
  search_team_by_id_aggregate(
    """
    input parameters for function "search_team_by_id_aggregate"
    """
    args: search_team_by_id_args!

    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): team_aggregate!

  """
  execute function "search_token_by_id" which returns "projectToken"
  """
  search_token_by_id(
    """
    input parameters for function "search_token_by_id"
    """
    args: search_token_by_id_args!

    """distinct select on columns"""
    distinct_on: [projectToken_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [projectToken_order_by!]

    """filter the rows returned"""
    where: projectToken_bool_exp
  ): [projectToken!]!

  """
  execute function "search_usage_history_by_id" which returns "usageHistory"
  """
  search_usage_history_by_id(
    """
    input parameters for function "search_usage_history_by_id"
    """
    args: search_usage_history_by_id_args!

    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """
  execute function "search_usage_history_by_id" and query aggregates on result of table type "usageHistory"
  """
  search_usage_history_by_id_aggregate(
    """
    input parameters for function "search_usage_history_by_id_aggregate"
    """
    args: search_usage_history_by_id_args!

    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): usageHistory_aggregate!

  """
  execute function "search_user_by_id" which returns "user"
  """
  search_user_by_id(
    """
    input parameters for function "search_user_by_id"
    """
    args: search_user_by_id_args!

    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  execute function "search_user_secret_by_id" which returns "userSecret"
  """
  search_user_secret_by_id(
    """
    input parameters for function "search_user_secret_by_id"
    """
    args: search_user_secret_by_id_args!

    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """
  execute function "search_user_secret_by_id" and query aggregates on result of table type "userSecret"
  """
  search_user_secret_by_id_aggregate(
    """
    input parameters for function "search_user_secret_by_id_aggregate"
    """
    args: search_user_secret_by_id_args!

    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): userSecret_aggregate!

  """Send notifications"""
  sendNotifications(
    """the unique id of an action"""
    id: uuid!
  ): sendNotifications

  """
  fetch data from the table: "tag"
  """
  tag(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """fetch data from the table: "tag" using primary key columns"""
  tag_by_pk(id: uuid!): tag

  """
  fetch data from the table: "team"
  """
  team(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """
  fetch data from the table: "teamInvitation"
  """
  teamInvitation(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!

  """fetch data from the table: "teamInvitation" using primary key columns"""
  teamInvitation_by_pk(id: uuid!): teamInvitation

  """
  fetch data from the table: "teamUser"
  """
  teamUser(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """
  fetch aggregated fields from the table: "teamUser"
  """
  teamUser_aggregate(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!

  """fetch data from the table: "teamUser" using primary key columns"""
  teamUser_by_pk(id: uuid!): teamUser

  """
  fetch aggregated fields from the table: "team"
  """
  team_aggregate(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): team_aggregate!

  """fetch data from the table: "team" using primary key columns"""
  team_by_pk(id: uuid!): team

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  fetch data from the table: "tokenTag"
  """
  tokenTag(
    """distinct select on columns"""
    distinct_on: [tokenTag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTag_order_by!]

    """filter the rows returned"""
    where: tokenTag_bool_exp
  ): [tokenTag!]!

  """fetch data from the table: "tokenTag" using primary key columns"""
  tokenTag_by_pk(id: uuid!): tokenTag

  """
  fetch data from the table: "tokenTeam"
  """
  tokenTeam(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): [tokenTeam!]!

  """
  fetch aggregated fields from the table: "tokenTeam"
  """
  tokenTeam_aggregate(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): tokenTeam_aggregate!

  """fetch data from the table: "tokenTeam" using primary key columns"""
  tokenTeam_by_pk(id: uuid!): tokenTeam

  """
  fetch aggregated fields from the table: "token"
  """
  token_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """fetch data from the table: "token" using primary key columns"""
  token_by_pk(id: uuid!): token

  """An array relationship"""
  usageHistory(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """
  fetch data from the table: "usageHistorySecret"
  """
  usageHistorySecret(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): [usageHistorySecret!]!

  """
  fetch aggregated fields from the table: "usageHistorySecret"
  """
  usageHistorySecret_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): usageHistorySecret_aggregate!

  """
  fetch data from the table: "usageHistorySecret" using primary key columns
  """
  usageHistorySecret_by_pk(id: uuid!): usageHistorySecret

  """An aggregate relationship"""
  usageHistory_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): usageHistory_aggregate!

  """fetch data from the table: "usageHistory" using primary key columns"""
  usageHistory_by_pk(id: uuid!): usageHistory

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """An array relationship"""
  userSecret(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """
  fetch data from the table: "userSecretField"
  """
  userSecretField(
    """distinct select on columns"""
    distinct_on: [userSecretField_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecretField_order_by!]

    """filter the rows returned"""
    where: userSecretField_bool_exp
  ): [userSecretField!]!

  """fetch data from the table: "userSecretField" using primary key columns"""
  userSecretField_by_pk(id: uuid!): userSecretField

  """An aggregate relationship"""
  userSecret_aggregate(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): userSecret_aggregate!

  """fetch data from the table: "userSecret" using primary key columns"""
  userSecret_by_pk(id: uuid!): userSecret

  """
  fetch data from the table: "userSubscription"
  """
  userSubscription(
    """distinct select on columns"""
    distinct_on: [userSubscription_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSubscription_order_by!]

    """filter the rows returned"""
    where: userSubscription_bool_exp
  ): [userSubscription!]!

  """
  fetch data from the table: "userSubscription" using primary key columns
  """
  userSubscription_by_pk(id: uuid!): userSubscription

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: uuid!): user

  """An array relationship"""
  viewPreferences(
    """distinct select on columns"""
    distinct_on: [viewPreferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [viewPreferences_order_by!]

    """filter the rows returned"""
    where: viewPreferences_bool_exp
  ): [viewPreferences!]!

  """fetch data from the table: "viewPreferences" using primary key columns"""
  viewPreferences_by_pk(id: uuid!): viewPreferences
  viewSecretFields(secretField: ViewSecretFieldsInput!): ViewSecretFieldsOutput!
}

enum registrationStep_enum {
  """billing information collection step"""
  billingInformation

  """registration is complete"""
  complete

  """email verification step"""
  emailVerification
}

"""
Boolean expression to compare columns of type "registrationStep_enum". All fields are combined with logical 'AND'.
"""
input registrationStep_enum_comparison_exp {
  _eq: registrationStep_enum
  _in: [registrationStep_enum!]
  _is_null: Boolean
  _neq: registrationStep_enum
  _nin: [registrationStep_enum!]
}

input search_project_by_id_args {
  match: String
}

input search_team_by_id_args {
  match: String
}

input search_token_by_id_args {
  match: String
}

input search_usage_history_by_id_args {
  match: String
}

input search_user_by_id_args {
  match: String
}

input search_user_secret_by_id_args {
  match: String
}

"""
fields of action: "sendNotifications"
"""
type sendNotifications {
  """the time at which this action was created"""
  created_at: timestamptz!

  """errors related to the invocation"""
  errors: json

  """the unique id of an action"""
  id: uuid!

  """the output fields of this action"""
  output: SendNotificationsOutput
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

enum subscriptionIntervalEnum_enum {
  month
  year
}

"""
Boolean expression to compare columns of type "subscriptionIntervalEnum_enum". All fields are combined with logical 'AND'.
"""
input subscriptionIntervalEnum_enum_comparison_exp {
  _eq: subscriptionIntervalEnum_enum
  _in: [subscriptionIntervalEnum_enum!]
  _is_null: Boolean
  _neq: subscriptionIntervalEnum_enum
  _nin: [subscriptionIntervalEnum_enum!]
}

enum subscriptionPlanEnum_enum {
  enterprise
  free
  lifetime
  professional
}

"""
Boolean expression to compare columns of type "subscriptionPlanEnum_enum". All fields are combined with logical 'AND'.
"""
input subscriptionPlanEnum_enum_comparison_exp {
  _eq: subscriptionPlanEnum_enum
  _in: [subscriptionPlanEnum_enum!]
  _is_null: Boolean
  _neq: subscriptionPlanEnum_enum
  _nin: [subscriptionPlanEnum_enum!]
}

type subscription_root {
  """
  fetch data from the table: "integration"
  """
  integration(
    """distinct select on columns"""
    distinct_on: [integration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integration_order_by!]

    """filter the rows returned"""
    where: integration_bool_exp
  ): [integration!]!

  """
  fetch data from the table: "integrationInstallation"
  """
  integrationInstallation(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): [integrationInstallation!]!

  """
  fetch data from the table: "integrationInstallationUserSecret"
  """
  integrationInstallationUserSecret(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): [integrationInstallationUserSecret!]!

  """
  fetch data from the table: "integrationInstallationUserSecret" using primary key columns
  """
  integrationInstallationUserSecret_by_pk(id: uuid!): integrationInstallationUserSecret

  """
  fetch data from the table in a streaming manner: "integrationInstallationUserSecret"
  """
  integrationInstallationUserSecret_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [integrationInstallationUserSecret_stream_cursor_input]!

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): [integrationInstallationUserSecret!]!

  """
  fetch aggregated fields from the table: "integrationInstallation"
  """
  integrationInstallation_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): integrationInstallation_aggregate!

  """
  fetch data from the table: "integrationInstallation" using primary key columns
  """
  integrationInstallation_by_pk(id: uuid!): integrationInstallation

  """
  fetch data from the table in a streaming manner: "integrationInstallation"
  """
  integrationInstallation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [integrationInstallation_stream_cursor_input]!

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): [integrationInstallation!]!

  """fetch data from the table: "integration" using primary key columns"""
  integration_by_pk(id: uuid!): integration

  """
  fetch data from the table in a streaming manner: "integration"
  """
  integration_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [integration_stream_cursor_input]!

    """filter the rows returned"""
    where: integration_bool_exp
  ): [integration!]!

  """
  fetch data from the table: "notification"
  """
  notification(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """
  fetch data from the table: "notificationUser"
  """
  notificationUser(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!

  """
  fetch data from the table: "notificationUser" using primary key columns
  """
  notificationUser_by_pk(id: uuid!): notificationUser

  """
  fetch data from the table in a streaming manner: "notificationUser"
  """
  notificationUser_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notificationUser_stream_cursor_input]!

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!

  """fetch data from the table: "notification" using primary key columns"""
  notification_by_pk(id: uuid!): notification

  """
  fetch data from the table in a streaming manner: "notification"
  """
  notification_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notification_stream_cursor_input]!

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """
  fetch data from the table: "projectToken"
  """
  projectToken(
    """distinct select on columns"""
    distinct_on: [projectToken_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [projectToken_order_by!]

    """filter the rows returned"""
    where: projectToken_bool_exp
  ): [projectToken!]!

  """fetch data from the table: "projectToken" using primary key columns"""
  projectToken_by_pk(id: uuid!): projectToken

  """
  fetch data from the table in a streaming manner: "projectToken"
  """
  projectToken_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [projectToken_stream_cursor_input]!

    """filter the rows returned"""
    where: projectToken_bool_exp
  ): [projectToken!]!

  """
  execute function "search_project_by_id" which returns "token"
  """
  search_project_by_id(
    """
    input parameters for function "search_project_by_id"
    """
    args: search_project_by_id_args!

    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  execute function "search_project_by_id" and query aggregates on result of table type "token"
  """
  search_project_by_id_aggregate(
    """
    input parameters for function "search_project_by_id_aggregate"
    """
    args: search_project_by_id_args!

    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """
  execute function "search_team_by_id" which returns "team"
  """
  search_team_by_id(
    """
    input parameters for function "search_team_by_id"
    """
    args: search_team_by_id_args!

    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """
  execute function "search_team_by_id" and query aggregates on result of table type "team"
  """
  search_team_by_id_aggregate(
    """
    input parameters for function "search_team_by_id_aggregate"
    """
    args: search_team_by_id_args!

    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): team_aggregate!

  """
  execute function "search_token_by_id" which returns "projectToken"
  """
  search_token_by_id(
    """
    input parameters for function "search_token_by_id"
    """
    args: search_token_by_id_args!

    """distinct select on columns"""
    distinct_on: [projectToken_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [projectToken_order_by!]

    """filter the rows returned"""
    where: projectToken_bool_exp
  ): [projectToken!]!

  """
  execute function "search_usage_history_by_id" which returns "usageHistory"
  """
  search_usage_history_by_id(
    """
    input parameters for function "search_usage_history_by_id"
    """
    args: search_usage_history_by_id_args!

    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """
  execute function "search_usage_history_by_id" and query aggregates on result of table type "usageHistory"
  """
  search_usage_history_by_id_aggregate(
    """
    input parameters for function "search_usage_history_by_id_aggregate"
    """
    args: search_usage_history_by_id_args!

    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): usageHistory_aggregate!

  """
  execute function "search_user_by_id" which returns "user"
  """
  search_user_by_id(
    """
    input parameters for function "search_user_by_id"
    """
    args: search_user_by_id_args!

    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  execute function "search_user_secret_by_id" which returns "userSecret"
  """
  search_user_secret_by_id(
    """
    input parameters for function "search_user_secret_by_id"
    """
    args: search_user_secret_by_id_args!

    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """
  execute function "search_user_secret_by_id" and query aggregates on result of table type "userSecret"
  """
  search_user_secret_by_id_aggregate(
    """
    input parameters for function "search_user_secret_by_id_aggregate"
    """
    args: search_user_secret_by_id_args!

    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): userSecret_aggregate!

  """Send notifications"""
  sendNotifications(
    """the unique id of an action"""
    id: uuid!
  ): sendNotifications

  """
  fetch data from the table: "tag"
  """
  tag(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """fetch data from the table: "tag" using primary key columns"""
  tag_by_pk(id: uuid!): tag

  """
  fetch data from the table in a streaming manner: "tag"
  """
  tag_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tag_stream_cursor_input]!

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """
  fetch data from the table: "team"
  """
  team(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """
  fetch data from the table: "teamInvitation"
  """
  teamInvitation(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!

  """fetch data from the table: "teamInvitation" using primary key columns"""
  teamInvitation_by_pk(id: uuid!): teamInvitation

  """
  fetch data from the table in a streaming manner: "teamInvitation"
  """
  teamInvitation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [teamInvitation_stream_cursor_input]!

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!

  """
  fetch data from the table: "teamUser"
  """
  teamUser(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """
  fetch aggregated fields from the table: "teamUser"
  """
  teamUser_aggregate(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!

  """fetch data from the table: "teamUser" using primary key columns"""
  teamUser_by_pk(id: uuid!): teamUser

  """
  fetch data from the table in a streaming manner: "teamUser"
  """
  teamUser_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [teamUser_stream_cursor_input]!

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """
  fetch aggregated fields from the table: "team"
  """
  team_aggregate(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): team_aggregate!

  """fetch data from the table: "team" using primary key columns"""
  team_by_pk(id: uuid!): team

  """
  fetch data from the table in a streaming manner: "team"
  """
  team_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [team_stream_cursor_input]!

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  fetch data from the table: "tokenTag"
  """
  tokenTag(
    """distinct select on columns"""
    distinct_on: [tokenTag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTag_order_by!]

    """filter the rows returned"""
    where: tokenTag_bool_exp
  ): [tokenTag!]!

  """fetch data from the table: "tokenTag" using primary key columns"""
  tokenTag_by_pk(id: uuid!): tokenTag

  """
  fetch data from the table in a streaming manner: "tokenTag"
  """
  tokenTag_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tokenTag_stream_cursor_input]!

    """filter the rows returned"""
    where: tokenTag_bool_exp
  ): [tokenTag!]!

  """
  fetch data from the table: "tokenTeam"
  """
  tokenTeam(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): [tokenTeam!]!

  """
  fetch aggregated fields from the table: "tokenTeam"
  """
  tokenTeam_aggregate(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): tokenTeam_aggregate!

  """fetch data from the table: "tokenTeam" using primary key columns"""
  tokenTeam_by_pk(id: uuid!): tokenTeam

  """
  fetch data from the table in a streaming manner: "tokenTeam"
  """
  tokenTeam_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tokenTeam_stream_cursor_input]!

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): [tokenTeam!]!

  """
  fetch aggregated fields from the table: "token"
  """
  token_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """fetch data from the table: "token" using primary key columns"""
  token_by_pk(id: uuid!): token

  """
  fetch data from the table in a streaming manner: "token"
  """
  token_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [token_stream_cursor_input]!

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """An array relationship"""
  usageHistory(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """
  fetch data from the table: "usageHistorySecret"
  """
  usageHistorySecret(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): [usageHistorySecret!]!

  """
  fetch aggregated fields from the table: "usageHistorySecret"
  """
  usageHistorySecret_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): usageHistorySecret_aggregate!

  """
  fetch data from the table: "usageHistorySecret" using primary key columns
  """
  usageHistorySecret_by_pk(id: uuid!): usageHistorySecret

  """
  fetch data from the table in a streaming manner: "usageHistorySecret"
  """
  usageHistorySecret_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [usageHistorySecret_stream_cursor_input]!

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): [usageHistorySecret!]!

  """An aggregate relationship"""
  usageHistory_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): usageHistory_aggregate!

  """fetch data from the table: "usageHistory" using primary key columns"""
  usageHistory_by_pk(id: uuid!): usageHistory

  """
  fetch data from the table in a streaming manner: "usageHistory"
  """
  usageHistory_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [usageHistory_stream_cursor_input]!

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """An array relationship"""
  userSecret(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """
  fetch data from the table: "userSecretField"
  """
  userSecretField(
    """distinct select on columns"""
    distinct_on: [userSecretField_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecretField_order_by!]

    """filter the rows returned"""
    where: userSecretField_bool_exp
  ): [userSecretField!]!

  """fetch data from the table: "userSecretField" using primary key columns"""
  userSecretField_by_pk(id: uuid!): userSecretField

  """
  fetch data from the table in a streaming manner: "userSecretField"
  """
  userSecretField_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [userSecretField_stream_cursor_input]!

    """filter the rows returned"""
    where: userSecretField_bool_exp
  ): [userSecretField!]!

  """An aggregate relationship"""
  userSecret_aggregate(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): userSecret_aggregate!

  """fetch data from the table: "userSecret" using primary key columns"""
  userSecret_by_pk(id: uuid!): userSecret

  """
  fetch data from the table in a streaming manner: "userSecret"
  """
  userSecret_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [userSecret_stream_cursor_input]!

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """
  fetch data from the table: "userSubscription"
  """
  userSubscription(
    """distinct select on columns"""
    distinct_on: [userSubscription_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSubscription_order_by!]

    """filter the rows returned"""
    where: userSubscription_bool_exp
  ): [userSubscription!]!

  """
  fetch data from the table: "userSubscription" using primary key columns
  """
  userSubscription_by_pk(id: uuid!): userSubscription

  """
  fetch data from the table in a streaming manner: "userSubscription"
  """
  userSubscription_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [userSubscription_stream_cursor_input]!

    """filter the rows returned"""
    where: userSubscription_bool_exp
  ): [userSubscription!]!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: uuid!): user

  """
  fetch data from the table in a streaming manner: "user"
  """
  user_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_stream_cursor_input]!

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """An array relationship"""
  viewPreferences(
    """distinct select on columns"""
    distinct_on: [viewPreferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [viewPreferences_order_by!]

    """filter the rows returned"""
    where: viewPreferences_bool_exp
  ): [viewPreferences!]!

  """fetch data from the table: "viewPreferences" using primary key columns"""
  viewPreferences_by_pk(id: uuid!): viewPreferences

  """
  fetch data from the table in a streaming manner: "viewPreferences"
  """
  viewPreferences_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [viewPreferences_stream_cursor_input]!

    """filter the rows returned"""
    where: viewPreferences_bool_exp
  ): [viewPreferences!]!
}

"""
columns and relationships of "tag"
"""
type tag {
  color: String!
  id: uuid!
  name: String!

  """An array relationship"""
  tokenTags(
    """distinct select on columns"""
    distinct_on: [tokenTag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTag_order_by!]

    """filter the rows returned"""
    where: tokenTag_bool_exp
  ): [tokenTag!]!

  """An object relationship"""
  user: user
}

"""
Boolean expression to filter rows from the table "tag". All fields are combined with a logical 'AND'.
"""
input tag_bool_exp {
  _and: [tag_bool_exp!]
  _not: tag_bool_exp
  _or: [tag_bool_exp!]
  color: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  tokenTags: tokenTag_bool_exp
  user: user_bool_exp
}

"""
unique or primary key constraints on table "tag"
"""
enum tag_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tag_id_key

  """
  unique or primary key constraint on columns "id"
  """
  tag_pkey
}

"""
input type for inserting data into table "tag"
"""
input tag_insert_input {
  color: String
  name: String
  tokenTags: tokenTag_arr_rel_insert_input
}

"""
response of any mutation on the table "tag"
"""
type tag_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tag!]!
}

"""
input type for inserting object relation for remote table "tag"
"""
input tag_obj_rel_insert_input {
  data: tag_insert_input!

  """upsert condition"""
  on_conflict: tag_on_conflict
}

"""
on_conflict condition type for table "tag"
"""
input tag_on_conflict {
  constraint: tag_constraint!
  update_columns: [tag_update_column!]! = []
  where: tag_bool_exp
}

"""Ordering options when selecting data from "tag"."""
input tag_order_by {
  color: order_by
  id: order_by
  name: order_by
  tokenTags_aggregate: tokenTag_aggregate_order_by
  user: user_order_by
}

"""
select columns of table "tag"
"""
enum tag_select_column {
  """column name"""
  color

  """column name"""
  id

  """column name"""
  name
}

"""
Streaming cursor of the table "tag"
"""
input tag_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tag_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tag_stream_cursor_value_input {
  color: String
  id: uuid
  name: String
}

"""
placeholder for update columns of table "tag" (current role has no relevant permissions)
"""
enum tag_update_column {
  """placeholder (do not use)"""
  _PLACEHOLDER
}

"""
columns and relationships of "team"
"""
type team {
  createdAt: timestamptz!
  description: String
  id: uuid!
  lastUpdatedAt: timestamptz

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!
  name: String!

  """An object relationship"""
  owner: user
  ownerUserId: uuid!

  """An array relationship"""
  tokenTeams(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): [tokenTeam!]!

  """An aggregate relationship"""
  tokenTeams_aggregate(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): tokenTeam_aggregate!
  updatedAt: timestamptz!
}

"""
columns and relationships of "teamInvitation"
"""
type teamInvitation {
  createdAt: timestamptz!
  email: String!
  expiredAt: timestamptz!
  id: uuid!
  invitedBy: uuid!

  """An object relationship"""
  invitedUser: user

  """An object relationship"""
  ownerTeam: user!
  status: invitationStatusEnum_enum!

  """An object relationship"""
  team: team!
  teamId: uuid!
  teamName: String!
  updatedAt: timestamptz!
}

"""
order by aggregate values of table "teamInvitation"
"""
input teamInvitation_aggregate_order_by {
  count: order_by
  max: teamInvitation_max_order_by
  min: teamInvitation_min_order_by
}

"""
Boolean expression to filter rows from the table "teamInvitation". All fields are combined with a logical 'AND'.
"""
input teamInvitation_bool_exp {
  _and: [teamInvitation_bool_exp!]
  _not: teamInvitation_bool_exp
  _or: [teamInvitation_bool_exp!]
  createdAt: timestamptz_comparison_exp
  email: String_comparison_exp
  expiredAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  invitedBy: uuid_comparison_exp
  invitedUser: user_bool_exp
  ownerTeam: user_bool_exp
  status: invitationStatusEnum_enum_comparison_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  teamName: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "teamInvitation"
"""
enum teamInvitation_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  teamInvitation_pkey
}

"""
input type for inserting data into table "teamInvitation"
"""
input teamInvitation_insert_input {
  email: String
  expiredAt: timestamptz
  invitedBy: uuid
  status: invitationStatusEnum_enum
  teamId: uuid
  teamName: String
}

"""
order by max() on columns of table "teamInvitation"
"""
input teamInvitation_max_order_by {
  createdAt: order_by
  email: order_by
  expiredAt: order_by
  id: order_by
  invitedBy: order_by
  teamId: order_by
  teamName: order_by
  updatedAt: order_by
}

"""
order by min() on columns of table "teamInvitation"
"""
input teamInvitation_min_order_by {
  createdAt: order_by
  email: order_by
  expiredAt: order_by
  id: order_by
  invitedBy: order_by
  teamId: order_by
  teamName: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "teamInvitation"
"""
type teamInvitation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [teamInvitation!]!
}

"""
on_conflict condition type for table "teamInvitation"
"""
input teamInvitation_on_conflict {
  constraint: teamInvitation_constraint!
  update_columns: [teamInvitation_update_column!]! = []
  where: teamInvitation_bool_exp
}

"""Ordering options when selecting data from "teamInvitation"."""
input teamInvitation_order_by {
  createdAt: order_by
  email: order_by
  expiredAt: order_by
  id: order_by
  invitedBy: order_by
  invitedUser: user_order_by
  ownerTeam: user_order_by
  status: order_by
  team: team_order_by
  teamId: order_by
  teamName: order_by
  updatedAt: order_by
}

"""
select columns of table "teamInvitation"
"""
enum teamInvitation_select_column {
  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  expiredAt

  """column name"""
  id

  """column name"""
  invitedBy

  """column name"""
  status

  """column name"""
  teamId

  """column name"""
  teamName

  """column name"""
  updatedAt
}

"""
Streaming cursor of the table "teamInvitation"
"""
input teamInvitation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: teamInvitation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input teamInvitation_stream_cursor_value_input {
  createdAt: timestamptz
  email: String
  expiredAt: timestamptz
  id: uuid
  invitedBy: uuid
  status: invitationStatusEnum_enum
  teamId: uuid
  teamName: String
  updatedAt: timestamptz
}

"""
placeholder for update columns of table "teamInvitation" (current role has no relevant permissions)
"""
enum teamInvitation_update_column {
  """placeholder (do not use)"""
  _PLACEHOLDER
}

"""
columns and relationships of "teamUser"
"""
type teamUser {
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  member: user!

  """An object relationship"""
  team: team!
  teamId: uuid!
  updatedAt: timestamptz!
  userId: uuid!
}

"""
aggregated selection of "teamUser"
"""
type teamUser_aggregate {
  aggregate: teamUser_aggregate_fields
  nodes: [teamUser!]!
}

input teamUser_aggregate_bool_exp {
  count: teamUser_aggregate_bool_exp_count
}

input teamUser_aggregate_bool_exp_count {
  arguments: [teamUser_select_column!]
  distinct: Boolean
  filter: teamUser_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "teamUser"
"""
type teamUser_aggregate_fields {
  count(columns: [teamUser_select_column!], distinct: Boolean): Int!
  max: teamUser_max_fields
  min: teamUser_min_fields
}

"""
order by aggregate values of table "teamUser"
"""
input teamUser_aggregate_order_by {
  count: order_by
  max: teamUser_max_order_by
  min: teamUser_min_order_by
}

"""
Boolean expression to filter rows from the table "teamUser". All fields are combined with a logical 'AND'.
"""
input teamUser_bool_exp {
  _and: [teamUser_bool_exp!]
  _not: teamUser_bool_exp
  _or: [teamUser_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  member: user_bool_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "teamUser"
"""
enum teamUser_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  teamUser_pkey
}

"""
input type for inserting data into table "teamUser"
"""
input teamUser_insert_input {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate max on columns"""
type teamUser_max_fields {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "teamUser"
"""
input teamUser_max_order_by {
  createdAt: order_by
  id: order_by
  teamId: order_by
  updatedAt: order_by
  userId: order_by
}

"""aggregate min on columns"""
type teamUser_min_fields {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "teamUser"
"""
input teamUser_min_order_by {
  createdAt: order_by
  id: order_by
  teamId: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "teamUser"
"""
type teamUser_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [teamUser!]!
}

"""
on_conflict condition type for table "teamUser"
"""
input teamUser_on_conflict {
  constraint: teamUser_constraint!
  update_columns: [teamUser_update_column!]! = []
  where: teamUser_bool_exp
}

"""Ordering options when selecting data from "teamUser"."""
input teamUser_order_by {
  createdAt: order_by
  id: order_by
  member: user_order_by
  team: team_order_by
  teamId: order_by
  updatedAt: order_by
  userId: order_by
}

"""primary key columns input for table: teamUser"""
input teamUser_pk_columns_input {
  id: uuid!
}

"""
select columns of table "teamUser"
"""
enum teamUser_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  teamId

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "teamUser"
"""
input teamUser_set_input {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "teamUser"
"""
input teamUser_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: teamUser_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input teamUser_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "teamUser"
"""
enum teamUser_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  teamId

  """column name"""
  updatedAt

  """column name"""
  userId
}

input teamUser_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: teamUser_set_input

  """filter the rows which have to be updated"""
  where: teamUser_bool_exp!
}

type team_aggregate {
  aggregate: team_aggregate_fields
  nodes: [team!]!
}

"""
aggregate fields of "team"
"""
type team_aggregate_fields {
  count(columns: [team_select_column!], distinct: Boolean): Int!
  max: team_max_fields
  min: team_min_fields
}

"""
Boolean expression to filter rows from the table "team". All fields are combined with a logical 'AND'.
"""
input team_bool_exp {
  _and: [team_bool_exp!]
  _not: team_bool_exp
  _or: [team_bool_exp!]
  createdAt: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  lastUpdatedAt: timestamptz_comparison_exp
  members: teamUser_bool_exp
  members_aggregate: teamUser_aggregate_bool_exp
  name: String_comparison_exp
  owner: user_bool_exp
  ownerUserId: uuid_comparison_exp
  tokenTeams: tokenTeam_bool_exp
  tokenTeams_aggregate: tokenTeam_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type team_max_fields {
  createdAt: timestamptz
  description: String
  id: uuid
  lastUpdatedAt: timestamptz
  name: String
  ownerUserId: uuid
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type team_min_fields {
  createdAt: timestamptz
  description: String
  id: uuid
  lastUpdatedAt: timestamptz
  name: String
  ownerUserId: uuid
  updatedAt: timestamptz
}

"""
response of any mutation on the table "team"
"""
type team_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [team!]!
}

"""Ordering options when selecting data from "team"."""
input team_order_by {
  createdAt: order_by
  description: order_by
  id: order_by
  lastUpdatedAt: order_by
  members_aggregate: teamUser_aggregate_order_by
  name: order_by
  owner: user_order_by
  ownerUserId: order_by
  tokenTeams_aggregate: tokenTeam_aggregate_order_by
  updatedAt: order_by
}

"""primary key columns input for table: team"""
input team_pk_columns_input {
  id: uuid!
}

"""
select columns of table "team"
"""
enum team_select_column {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  name

  """column name"""
  ownerUserId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "team"
"""
input team_set_input {
  description: String
  name: String
}

"""
Streaming cursor of the table "team"
"""
input team_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: team_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input team_stream_cursor_value_input {
  createdAt: timestamptz
  description: String
  id: uuid
  lastUpdatedAt: timestamptz
  name: String
  ownerUserId: uuid
  updatedAt: timestamptz
}

input team_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: team_set_input

  """filter the rows which have to be updated"""
  where: team_bool_exp!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "token"
"""
type token {
  createdAt: timestamptz!
  description: String
  icon: String!
  id: uuid!

  """An array relationship"""
  integrationInstallations(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): [integrationInstallation!]!

  """An aggregate relationship"""
  integrationInstallations_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): integrationInstallation_aggregate!
  lastUpdatedAt: timestamptz

  """
  A computed field, executes function "computeTokenLastUsedAt"
  """
  lastUsedAt: timestamptz
  name: String!

  """An object relationship"""
  owner: user!
  ownerUserId: uuid!

  """An array relationship"""
  project_projectTokens(
    """distinct select on columns"""
    distinct_on: [projectToken_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [projectToken_order_by!]

    """filter the rows returned"""
    where: projectToken_bool_exp
  ): [projectToken!]!
  slug: String!

  """An array relationship"""
  tags(
    """distinct select on columns"""
    distinct_on: [tokenTag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTag_order_by!]

    """filter the rows returned"""
    where: tokenTag_bool_exp
  ): [tokenTag!]!

  """An array relationship"""
  teams(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): [tokenTeam!]!

  """An aggregate relationship"""
  teams_aggregate(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): tokenTeam_aggregate!

  """An array relationship"""
  usageHistory(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """An aggregate relationship"""
  usageHistory_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): usageHistory_aggregate!

  """An array relationship"""
  userSecret(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """An aggregate relationship"""
  userSecret_aggregate(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): userSecret_aggregate!
}

"""
columns and relationships of "tokenTag"
"""
type tokenTag {
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  tag: tag!
  tagId: uuid!

  """An object relationship"""
  token: token!
  tokenId: uuid!
  updatedAt: timestamptz!
}

"""
order by aggregate values of table "tokenTag"
"""
input tokenTag_aggregate_order_by {
  count: order_by
  max: tokenTag_max_order_by
  min: tokenTag_min_order_by
}

"""
input type for inserting array relation for remote table "tokenTag"
"""
input tokenTag_arr_rel_insert_input {
  data: [tokenTag_insert_input!]!

  """upsert condition"""
  on_conflict: tokenTag_on_conflict
}

"""
Boolean expression to filter rows from the table "tokenTag". All fields are combined with a logical 'AND'.
"""
input tokenTag_bool_exp {
  _and: [tokenTag_bool_exp!]
  _not: tokenTag_bool_exp
  _or: [tokenTag_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  tag: tag_bool_exp
  tagId: uuid_comparison_exp
  token: token_bool_exp
  tokenId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "tokenTag"
"""
enum tokenTag_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tokenTag_pkey

  """
  unique or primary key constraint on columns "tagId", "tokenId"
  """
  tokenTag_tokenId_tagId_key
}

"""
input type for inserting data into table "tokenTag"
"""
input tokenTag_insert_input {
  tag: tag_obj_rel_insert_input
  tagId: uuid
  tokenId: uuid
}

"""
order by max() on columns of table "tokenTag"
"""
input tokenTag_max_order_by {
  createdAt: order_by
  id: order_by
  tagId: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""
order by min() on columns of table "tokenTag"
"""
input tokenTag_min_order_by {
  createdAt: order_by
  id: order_by
  tagId: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "tokenTag"
"""
type tokenTag_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tokenTag!]!
}

"""
on_conflict condition type for table "tokenTag"
"""
input tokenTag_on_conflict {
  constraint: tokenTag_constraint!
  update_columns: [tokenTag_update_column!]! = []
  where: tokenTag_bool_exp
}

"""Ordering options when selecting data from "tokenTag"."""
input tokenTag_order_by {
  createdAt: order_by
  id: order_by
  tag: tag_order_by
  tagId: order_by
  token: token_order_by
  tokenId: order_by
  updatedAt: order_by
}

"""primary key columns input for table: tokenTag"""
input tokenTag_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tokenTag"
"""
enum tokenTag_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  tagId

  """column name"""
  tokenId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "tokenTag"
"""
input tokenTag_set_input {
  tagId: uuid
  tokenId: uuid
}

"""
Streaming cursor of the table "tokenTag"
"""
input tokenTag_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tokenTag_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tokenTag_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  tagId: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "tokenTag"
"""
enum tokenTag_update_column {
  """column name"""
  tagId

  """column name"""
  tokenId
}

input tokenTag_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: tokenTag_set_input

  """filter the rows which have to be updated"""
  where: tokenTag_bool_exp!
}

"""
columns and relationships of "tokenTeam"
"""
type tokenTeam {
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  team: team!
  teamId: uuid!

  """An object relationship"""
  token: token!
  tokenId: uuid!
  updatedAt: timestamptz!
}

"""
aggregated selection of "tokenTeam"
"""
type tokenTeam_aggregate {
  aggregate: tokenTeam_aggregate_fields
  nodes: [tokenTeam!]!
}

input tokenTeam_aggregate_bool_exp {
  count: tokenTeam_aggregate_bool_exp_count
}

input tokenTeam_aggregate_bool_exp_count {
  arguments: [tokenTeam_select_column!]
  distinct: Boolean
  filter: tokenTeam_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "tokenTeam"
"""
type tokenTeam_aggregate_fields {
  count(columns: [tokenTeam_select_column!], distinct: Boolean): Int!
  max: tokenTeam_max_fields
  min: tokenTeam_min_fields
}

"""
order by aggregate values of table "tokenTeam"
"""
input tokenTeam_aggregate_order_by {
  count: order_by
  max: tokenTeam_max_order_by
  min: tokenTeam_min_order_by
}

"""
Boolean expression to filter rows from the table "tokenTeam". All fields are combined with a logical 'AND'.
"""
input tokenTeam_bool_exp {
  _and: [tokenTeam_bool_exp!]
  _not: tokenTeam_bool_exp
  _or: [tokenTeam_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  token: token_bool_exp
  tokenId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "tokenTeam"
"""
enum tokenTeam_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tokenTeam_pkey

  """
  unique or primary key constraint on columns "teamId", "tokenId"
  """
  tokenTeam_tokenId_teamId_key
}

"""
input type for inserting data into table "tokenTeam"
"""
input tokenTeam_insert_input {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type tokenTeam_max_fields {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "tokenTeam"
"""
input tokenTeam_max_order_by {
  createdAt: order_by
  id: order_by
  teamId: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type tokenTeam_min_fields {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "tokenTeam"
"""
input tokenTeam_min_order_by {
  createdAt: order_by
  id: order_by
  teamId: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "tokenTeam"
"""
type tokenTeam_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tokenTeam!]!
}

"""
on_conflict condition type for table "tokenTeam"
"""
input tokenTeam_on_conflict {
  constraint: tokenTeam_constraint!
  update_columns: [tokenTeam_update_column!]! = []
  where: tokenTeam_bool_exp
}

"""Ordering options when selecting data from "tokenTeam"."""
input tokenTeam_order_by {
  createdAt: order_by
  id: order_by
  team: team_order_by
  teamId: order_by
  token: token_order_by
  tokenId: order_by
  updatedAt: order_by
}

"""primary key columns input for table: tokenTeam"""
input tokenTeam_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tokenTeam"
"""
enum tokenTeam_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  teamId

  """column name"""
  tokenId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "tokenTeam"
"""
input tokenTeam_set_input {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "tokenTeam"
"""
input tokenTeam_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tokenTeam_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tokenTeam_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "tokenTeam"
"""
enum tokenTeam_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  teamId

  """column name"""
  tokenId

  """column name"""
  updatedAt
}

input tokenTeam_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: tokenTeam_set_input

  """filter the rows which have to be updated"""
  where: tokenTeam_bool_exp!
}

"""
aggregated selection of "token"
"""
type token_aggregate {
  aggregate: token_aggregate_fields
  nodes: [token!]!
}

input token_aggregate_bool_exp {
  count: token_aggregate_bool_exp_count
}

input token_aggregate_bool_exp_count {
  arguments: [token_select_column!]
  distinct: Boolean
  filter: token_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "token"
"""
type token_aggregate_fields {
  count(columns: [token_select_column!], distinct: Boolean): Int!
  max: token_max_fields
  min: token_min_fields
}

"""
order by aggregate values of table "token"
"""
input token_aggregate_order_by {
  count: order_by
  max: token_max_order_by
  min: token_min_order_by
}

"""
Boolean expression to filter rows from the table "token". All fields are combined with a logical 'AND'.
"""
input token_bool_exp {
  _and: [token_bool_exp!]
  _not: token_bool_exp
  _or: [token_bool_exp!]
  createdAt: timestamptz_comparison_exp
  description: String_comparison_exp
  icon: String_comparison_exp
  id: uuid_comparison_exp
  integrationInstallations: integrationInstallation_bool_exp
  integrationInstallations_aggregate: integrationInstallation_aggregate_bool_exp
  lastUpdatedAt: timestamptz_comparison_exp
  lastUsedAt: timestamptz_comparison_exp
  name: String_comparison_exp
  owner: user_bool_exp
  ownerUserId: uuid_comparison_exp
  project_projectTokens: projectToken_bool_exp
  slug: String_comparison_exp
  tags: tokenTag_bool_exp
  teams: tokenTeam_bool_exp
  teams_aggregate: tokenTeam_aggregate_bool_exp
  usageHistory: usageHistory_bool_exp
  usageHistory_aggregate: usageHistory_aggregate_bool_exp
  userSecret: userSecret_bool_exp
  userSecret_aggregate: userSecret_aggregate_bool_exp
}

"""aggregate max on columns"""
type token_max_fields {
  createdAt: timestamptz
  description: String
  icon: String
  id: uuid
  lastUpdatedAt: timestamptz

  """
  A computed field, executes function "computeTokenLastUsedAt"
  """
  lastUsedAt: timestamptz
  name: String
  ownerUserId: uuid
  slug: String
}

"""
order by max() on columns of table "token"
"""
input token_max_order_by {
  createdAt: order_by
  description: order_by
  icon: order_by
  id: order_by
  lastUpdatedAt: order_by
  name: order_by
  ownerUserId: order_by
  slug: order_by
}

"""aggregate min on columns"""
type token_min_fields {
  createdAt: timestamptz
  description: String
  icon: String
  id: uuid
  lastUpdatedAt: timestamptz

  """
  A computed field, executes function "computeTokenLastUsedAt"
  """
  lastUsedAt: timestamptz
  name: String
  ownerUserId: uuid
  slug: String
}

"""
order by min() on columns of table "token"
"""
input token_min_order_by {
  createdAt: order_by
  description: order_by
  icon: order_by
  id: order_by
  lastUpdatedAt: order_by
  name: order_by
  ownerUserId: order_by
  slug: order_by
}

"""
response of any mutation on the table "token"
"""
type token_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [token!]!
}

"""Ordering options when selecting data from "token"."""
input token_order_by {
  createdAt: order_by
  description: order_by
  icon: order_by
  id: order_by
  integrationInstallations_aggregate: integrationInstallation_aggregate_order_by
  lastUpdatedAt: order_by
  lastUsedAt: order_by
  name: order_by
  owner: user_order_by
  ownerUserId: order_by
  project_projectTokens_aggregate: projectToken_aggregate_order_by
  slug: order_by
  tags_aggregate: tokenTag_aggregate_order_by
  teams_aggregate: tokenTeam_aggregate_order_by
  usageHistory_aggregate: usageHistory_aggregate_order_by
  userSecret_aggregate: userSecret_aggregate_order_by
}

"""primary key columns input for table: token"""
input token_pk_columns_input {
  id: uuid!
}

"""
select columns of table "token"
"""
enum token_select_column {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  name

  """column name"""
  ownerUserId

  """column name"""
  slug
}

"""
input type for updating data in table "token"
"""
input token_set_input {
  description: String
  icon: String
  name: String
}

"""
Streaming cursor of the table "token"
"""
input token_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: token_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input token_stream_cursor_value_input {
  createdAt: timestamptz
  description: String
  icon: String
  id: uuid
  lastUpdatedAt: timestamptz
  name: String
  ownerUserId: uuid
  slug: String
}

input token_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: token_set_input

  """filter the rows which have to be updated"""
  where: token_bool_exp!
}

"""
columns and relationships of "usageHistory"
"""
type usageHistory {
  callerName: String
  createdAt: timestamptz!
  id: uuid!
  remoteIp: inet!

  """An array relationship"""
  secrets(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): [usageHistorySecret!]!

  """An aggregate relationship"""
  secrets_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): usageHistorySecret_aggregate!

  """An object relationship"""
  token: token!
  tokenId: uuid!
  updatedAt: timestamptz!
}

"""
columns and relationships of "usageHistorySecret"
"""
type usageHistorySecret {
  createdAt: timestamptz!
  id: uuid!
  updatedAt: timestamptz!

  """An object relationship"""
  usageHistory: usageHistory!
  usageHistoryId: uuid!

  """An object relationship"""
  userSecret: userSecret
  userSecretId: uuid
}

"""
aggregated selection of "usageHistorySecret"
"""
type usageHistorySecret_aggregate {
  aggregate: usageHistorySecret_aggregate_fields
  nodes: [usageHistorySecret!]!
}

input usageHistorySecret_aggregate_bool_exp {
  count: usageHistorySecret_aggregate_bool_exp_count
}

input usageHistorySecret_aggregate_bool_exp_count {
  arguments: [usageHistorySecret_select_column!]
  distinct: Boolean
  filter: usageHistorySecret_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "usageHistorySecret"
"""
type usageHistorySecret_aggregate_fields {
  count(columns: [usageHistorySecret_select_column!], distinct: Boolean): Int!
  max: usageHistorySecret_max_fields
  min: usageHistorySecret_min_fields
}

"""
order by aggregate values of table "usageHistorySecret"
"""
input usageHistorySecret_aggregate_order_by {
  count: order_by
  max: usageHistorySecret_max_order_by
  min: usageHistorySecret_min_order_by
}

"""
Boolean expression to filter rows from the table "usageHistorySecret". All fields are combined with a logical 'AND'.
"""
input usageHistorySecret_bool_exp {
  _and: [usageHistorySecret_bool_exp!]
  _not: usageHistorySecret_bool_exp
  _or: [usageHistorySecret_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  usageHistory: usageHistory_bool_exp
  usageHistoryId: uuid_comparison_exp
  userSecret: userSecret_bool_exp
  userSecretId: uuid_comparison_exp
}

"""aggregate max on columns"""
type usageHistorySecret_max_fields {
  createdAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usageHistoryId: uuid
  userSecretId: uuid
}

"""
order by max() on columns of table "usageHistorySecret"
"""
input usageHistorySecret_max_order_by {
  createdAt: order_by
  id: order_by
  updatedAt: order_by
  usageHistoryId: order_by
  userSecretId: order_by
}

"""aggregate min on columns"""
type usageHistorySecret_min_fields {
  createdAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usageHistoryId: uuid
  userSecretId: uuid
}

"""
order by min() on columns of table "usageHistorySecret"
"""
input usageHistorySecret_min_order_by {
  createdAt: order_by
  id: order_by
  updatedAt: order_by
  usageHistoryId: order_by
  userSecretId: order_by
}

"""Ordering options when selecting data from "usageHistorySecret"."""
input usageHistorySecret_order_by {
  createdAt: order_by
  id: order_by
  updatedAt: order_by
  usageHistory: usageHistory_order_by
  usageHistoryId: order_by
  userSecret: userSecret_order_by
  userSecretId: order_by
}

"""
select columns of table "usageHistorySecret"
"""
enum usageHistorySecret_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  updatedAt

  """column name"""
  usageHistoryId

  """column name"""
  userSecretId
}

"""
Streaming cursor of the table "usageHistorySecret"
"""
input usageHistorySecret_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: usageHistorySecret_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input usageHistorySecret_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usageHistoryId: uuid
  userSecretId: uuid
}

"""
aggregated selection of "usageHistory"
"""
type usageHistory_aggregate {
  aggregate: usageHistory_aggregate_fields
  nodes: [usageHistory!]!
}

input usageHistory_aggregate_bool_exp {
  count: usageHistory_aggregate_bool_exp_count
}

input usageHistory_aggregate_bool_exp_count {
  arguments: [usageHistory_select_column!]
  distinct: Boolean
  filter: usageHistory_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "usageHistory"
"""
type usageHistory_aggregate_fields {
  count(columns: [usageHistory_select_column!], distinct: Boolean): Int!
  max: usageHistory_max_fields
  min: usageHistory_min_fields
}

"""
order by aggregate values of table "usageHistory"
"""
input usageHistory_aggregate_order_by {
  count: order_by
  max: usageHistory_max_order_by
  min: usageHistory_min_order_by
}

"""
Boolean expression to filter rows from the table "usageHistory". All fields are combined with a logical 'AND'.
"""
input usageHistory_bool_exp {
  _and: [usageHistory_bool_exp!]
  _not: usageHistory_bool_exp
  _or: [usageHistory_bool_exp!]
  callerName: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  remoteIp: inet_comparison_exp
  secrets: usageHistorySecret_bool_exp
  secrets_aggregate: usageHistorySecret_aggregate_bool_exp
  token: token_bool_exp
  tokenId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type usageHistory_max_fields {
  callerName: String
  createdAt: timestamptz
  id: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "usageHistory"
"""
input usageHistory_max_order_by {
  callerName: order_by
  createdAt: order_by
  id: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type usageHistory_min_fields {
  callerName: String
  createdAt: timestamptz
  id: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "usageHistory"
"""
input usageHistory_min_order_by {
  callerName: order_by
  createdAt: order_by
  id: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""Ordering options when selecting data from "usageHistory"."""
input usageHistory_order_by {
  callerName: order_by
  createdAt: order_by
  id: order_by
  remoteIp: order_by
  secrets_aggregate: usageHistorySecret_aggregate_order_by
  token: token_order_by
  tokenId: order_by
  updatedAt: order_by
}

"""
select columns of table "usageHistory"
"""
enum usageHistory_select_column {
  """column name"""
  callerName

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  remoteIp

  """column name"""
  tokenId

  """column name"""
  updatedAt
}

"""
Streaming cursor of the table "usageHistory"
"""
input usageHistory_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: usageHistory_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input usageHistory_stream_cursor_value_input {
  callerName: String
  createdAt: timestamptz
  id: uuid
  remoteIp: inet
  tokenId: uuid
  updatedAt: timestamptz
}

"""
columns and relationships of "user"
"""
type user {
  activeTeamId: uuid
  avatarUrl: String
  createdAt: timestamptz!
  email: String!

  """A computed field which return the hasPassword boolean value"""
  hasPassword: Boolean
  id: uuid!

  """An array relationship"""
  invitation(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!
  name: String!

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!
  registrationStep: registrationStep_enum

  """An array relationship"""
  teams(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """An aggregate relationship"""
  teams_aggregate(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!

  """An array relationship"""
  tokens(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """An aggregate relationship"""
  tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!
  updatedAt: timestamptz!

  """An object relationship"""
  userSubscription: userSubscription

  """An object relationship"""
  user_activeTeam: team

  """An array relationship"""
  user_notificationUsers(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!

  """An array relationship"""
  user_teamInvitation(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!

  """An array relationship"""
  viewPreferences(
    """distinct select on columns"""
    distinct_on: [viewPreferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [viewPreferences_order_by!]

    """filter the rows returned"""
    where: viewPreferences_bool_exp
  ): [viewPreferences!]!
}

"""
columns and relationships of "userSecret"
"""
type userSecret {
  createdAt: timestamptz!

  """An array relationship"""
  fields(
    """distinct select on columns"""
    distinct_on: [userSecretField_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecretField_order_by!]

    """filter the rows returned"""
    where: userSecretField_bool_exp
  ): [userSecretField!]!
  id: uuid!

  """An array relationship"""
  installations(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): [integrationInstallationUserSecret!]!
  name: String!
  note: String!
  slug: String!

  """An object relationship"""
  token: token
  tokenId: uuid!
  updatedAt: timestamptz!

  """An array relationship"""
  userSecret_usageHistorySecrets(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): [usageHistorySecret!]!

  """An aggregate relationship"""
  userSecret_usageHistorySecrets_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): usageHistorySecret_aggregate!
  vendor: vendorEnum_enum!
}

"""
columns and relationships of "userSecretField"
"""
type userSecretField {
  createdAt: timestamptz!
  id: uuid!
  name: String!
  slug: String!
  updatedAt: timestamptz!

  """An object relationship"""
  userSecret: userSecret
  userSecretId: uuid!
  value: String!
}

"""
order by aggregate values of table "userSecretField"
"""
input userSecretField_aggregate_order_by {
  count: order_by
  max: userSecretField_max_order_by
  min: userSecretField_min_order_by
}

"""
input type for inserting array relation for remote table "userSecretField"
"""
input userSecretField_arr_rel_insert_input {
  data: [userSecretField_insert_input!]!

  """upsert condition"""
  on_conflict: userSecretField_on_conflict
}

"""
Boolean expression to filter rows from the table "userSecretField". All fields are combined with a logical 'AND'.
"""
input userSecretField_bool_exp {
  _and: [userSecretField_bool_exp!]
  _not: userSecretField_bool_exp
  _or: [userSecretField_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  slug: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userSecret: userSecret_bool_exp
  userSecretId: uuid_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "userSecretField"
"""
enum userSecretField_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  userSecretField_pkey
}

"""
input type for inserting data into table "userSecretField"
"""
input userSecretField_insert_input {
  name: String
  slug: String
  userSecret: userSecret_obj_rel_insert_input
  userSecretId: uuid
  value: String
}

"""
order by max() on columns of table "userSecretField"
"""
input userSecretField_max_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  slug: order_by
  updatedAt: order_by
  userSecretId: order_by
  value: order_by
}

"""
order by min() on columns of table "userSecretField"
"""
input userSecretField_min_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  slug: order_by
  updatedAt: order_by
  userSecretId: order_by
  value: order_by
}

"""
response of any mutation on the table "userSecretField"
"""
type userSecretField_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [userSecretField!]!
}

"""
on_conflict condition type for table "userSecretField"
"""
input userSecretField_on_conflict {
  constraint: userSecretField_constraint!
  update_columns: [userSecretField_update_column!]! = []
  where: userSecretField_bool_exp
}

"""Ordering options when selecting data from "userSecretField"."""
input userSecretField_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  slug: order_by
  updatedAt: order_by
  userSecret: userSecret_order_by
  userSecretId: order_by
  value: order_by
}

"""primary key columns input for table: userSecretField"""
input userSecretField_pk_columns_input {
  id: uuid!
}

"""
select columns of table "userSecretField"
"""
enum userSecretField_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  updatedAt

  """column name"""
  userSecretId

  """column name"""
  value
}

"""
input type for updating data in table "userSecretField"
"""
input userSecretField_set_input {
  name: String
  slug: String
  userSecretId: uuid
  value: String
}

"""
Streaming cursor of the table "userSecretField"
"""
input userSecretField_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: userSecretField_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input userSecretField_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  name: String
  slug: String
  updatedAt: timestamptz
  userSecretId: uuid
  value: String
}

"""
update columns of table "userSecretField"
"""
enum userSecretField_update_column {
  """column name"""
  name

  """column name"""
  slug

  """column name"""
  userSecretId

  """column name"""
  value
}

input userSecretField_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: userSecretField_set_input

  """filter the rows which have to be updated"""
  where: userSecretField_bool_exp!
}

"""
aggregated selection of "userSecret"
"""
type userSecret_aggregate {
  aggregate: userSecret_aggregate_fields
  nodes: [userSecret!]!
}

input userSecret_aggregate_bool_exp {
  count: userSecret_aggregate_bool_exp_count
}

input userSecret_aggregate_bool_exp_count {
  arguments: [userSecret_select_column!]
  distinct: Boolean
  filter: userSecret_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "userSecret"
"""
type userSecret_aggregate_fields {
  count(columns: [userSecret_select_column!], distinct: Boolean): Int!
  max: userSecret_max_fields
  min: userSecret_min_fields
}

"""
order by aggregate values of table "userSecret"
"""
input userSecret_aggregate_order_by {
  count: order_by
  max: userSecret_max_order_by
  min: userSecret_min_order_by
}

"""
Boolean expression to filter rows from the table "userSecret". All fields are combined with a logical 'AND'.
"""
input userSecret_bool_exp {
  _and: [userSecret_bool_exp!]
  _not: userSecret_bool_exp
  _or: [userSecret_bool_exp!]
  createdAt: timestamptz_comparison_exp
  fields: userSecretField_bool_exp
  id: uuid_comparison_exp
  installations: integrationInstallationUserSecret_bool_exp
  name: String_comparison_exp
  note: String_comparison_exp
  slug: String_comparison_exp
  token: token_bool_exp
  tokenId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userSecret_usageHistorySecrets: usageHistorySecret_bool_exp
  userSecret_usageHistorySecrets_aggregate: usageHistorySecret_aggregate_bool_exp
  vendor: vendorEnum_enum_comparison_exp
}

"""
unique or primary key constraints on table "userSecret"
"""
enum userSecret_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  userSecret_pkey
}

"""
input type for inserting data into table "userSecret"
"""
input userSecret_insert_input {
  fields: userSecretField_arr_rel_insert_input
  installations: integrationInstallationUserSecret_arr_rel_insert_input
  name: String
  note: String
  slug: String
  tokenId: uuid
  vendor: vendorEnum_enum
}

"""aggregate max on columns"""
type userSecret_max_fields {
  createdAt: timestamptz
  id: uuid
  name: String
  note: String
  slug: String
  tokenId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "userSecret"
"""
input userSecret_max_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  note: order_by
  slug: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type userSecret_min_fields {
  createdAt: timestamptz
  id: uuid
  name: String
  note: String
  slug: String
  tokenId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "userSecret"
"""
input userSecret_min_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  note: order_by
  slug: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "userSecret"
"""
type userSecret_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [userSecret!]!
}

"""
input type for inserting object relation for remote table "userSecret"
"""
input userSecret_obj_rel_insert_input {
  data: userSecret_insert_input!

  """upsert condition"""
  on_conflict: userSecret_on_conflict
}

"""
on_conflict condition type for table "userSecret"
"""
input userSecret_on_conflict {
  constraint: userSecret_constraint!
  update_columns: [userSecret_update_column!]! = []
  where: userSecret_bool_exp
}

"""Ordering options when selecting data from "userSecret"."""
input userSecret_order_by {
  createdAt: order_by
  fields_aggregate: userSecretField_aggregate_order_by
  id: order_by
  installations_aggregate: integrationInstallationUserSecret_aggregate_order_by
  name: order_by
  note: order_by
  slug: order_by
  token: token_order_by
  tokenId: order_by
  updatedAt: order_by
  userSecret_usageHistorySecrets_aggregate: usageHistorySecret_aggregate_order_by
  vendor: order_by
}

"""primary key columns input for table: userSecret"""
input userSecret_pk_columns_input {
  id: uuid!
}

"""
select columns of table "userSecret"
"""
enum userSecret_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  note

  """column name"""
  slug

  """column name"""
  tokenId

  """column name"""
  updatedAt

  """column name"""
  vendor
}

"""
input type for updating data in table "userSecret"
"""
input userSecret_set_input {
  name: String
  note: String
  slug: String
  vendor: vendorEnum_enum
}

"""
Streaming cursor of the table "userSecret"
"""
input userSecret_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: userSecret_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input userSecret_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  name: String
  note: String
  slug: String
  tokenId: uuid
  updatedAt: timestamptz
  vendor: vendorEnum_enum
}

"""
update columns of table "userSecret"
"""
enum userSecret_update_column {
  """column name"""
  name

  """column name"""
  note

  """column name"""
  slug

  """column name"""
  vendor
}

input userSecret_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: userSecret_set_input

  """filter the rows which have to be updated"""
  where: userSecret_bool_exp!
}

"""User subscription data"""
type userSubscription {
  availableSeats: smallint!
  createdAt: timestamptz!
  id: uuid!
  paidSeats: smallint!
  stripeCustomerId: String
  subscriptionCancellationDate: timestamptz
  subscriptionExpirationDate: timestamptz
  subscriptionExpirationMessageRead: Boolean!
  subscriptionInterval: subscriptionIntervalEnum_enum
  subscriptionPlan: subscriptionPlanEnum_enum!
  updatedAt: timestamptz!

  """An object relationship"""
  user: user!
  userId: uuid!
}

"""
Boolean expression to filter rows from the table "userSubscription". All fields are combined with a logical 'AND'.
"""
input userSubscription_bool_exp {
  _and: [userSubscription_bool_exp!]
  _not: userSubscription_bool_exp
  _or: [userSubscription_bool_exp!]
  availableSeats: smallint_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  paidSeats: smallint_comparison_exp
  stripeCustomerId: String_comparison_exp
  subscriptionCancellationDate: timestamptz_comparison_exp
  subscriptionExpirationDate: timestamptz_comparison_exp
  subscriptionExpirationMessageRead: Boolean_comparison_exp
  subscriptionInterval: subscriptionIntervalEnum_enum_comparison_exp
  subscriptionPlan: subscriptionPlanEnum_enum_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: user_bool_exp
  userId: uuid_comparison_exp
}

"""
response of any mutation on the table "userSubscription"
"""
type userSubscription_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [userSubscription!]!
}

"""Ordering options when selecting data from "userSubscription"."""
input userSubscription_order_by {
  availableSeats: order_by
  createdAt: order_by
  id: order_by
  paidSeats: order_by
  stripeCustomerId: order_by
  subscriptionCancellationDate: order_by
  subscriptionExpirationDate: order_by
  subscriptionExpirationMessageRead: order_by
  subscriptionInterval: order_by
  subscriptionPlan: order_by
  updatedAt: order_by
  user: user_order_by
  userId: order_by
}

"""primary key columns input for table: userSubscription"""
input userSubscription_pk_columns_input {
  id: uuid!
}

"""
select columns of table "userSubscription"
"""
enum userSubscription_select_column {
  """column name"""
  availableSeats

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  paidSeats

  """column name"""
  stripeCustomerId

  """column name"""
  subscriptionCancellationDate

  """column name"""
  subscriptionExpirationDate

  """column name"""
  subscriptionExpirationMessageRead

  """column name"""
  subscriptionInterval

  """column name"""
  subscriptionPlan

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "userSubscription"
"""
input userSubscription_set_input {
  subscriptionExpirationMessageRead: Boolean
}

"""
Streaming cursor of the table "userSubscription"
"""
input userSubscription_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: userSubscription_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input userSubscription_stream_cursor_value_input {
  availableSeats: smallint
  createdAt: timestamptz
  id: uuid
  paidSeats: smallint
  stripeCustomerId: String
  subscriptionCancellationDate: timestamptz
  subscriptionExpirationDate: timestamptz
  subscriptionExpirationMessageRead: Boolean
  subscriptionInterval: subscriptionIntervalEnum_enum
  subscriptionPlan: subscriptionPlanEnum_enum
  updatedAt: timestamptz
  userId: uuid
}

input userSubscription_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: userSubscription_set_input

  """filter the rows which have to be updated"""
  where: userSubscription_bool_exp!
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  activeTeamId: uuid_comparison_exp
  avatarUrl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  email: String_comparison_exp
  hasPassword: Boolean_comparison_exp
  id: uuid_comparison_exp
  invitation: teamInvitation_bool_exp
  name: String_comparison_exp
  notifications: notificationUser_bool_exp
  registrationStep: registrationStep_enum_comparison_exp
  teams: teamUser_bool_exp
  teams_aggregate: teamUser_aggregate_bool_exp
  tokens: token_bool_exp
  tokens_aggregate: token_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
  userSubscription: userSubscription_bool_exp
  user_activeTeam: team_bool_exp
  user_notificationUsers: notificationUser_bool_exp
  user_teamInvitation: teamInvitation_bool_exp
  viewPreferences: viewPreferences_bool_exp
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user!]!
}

"""Ordering options when selecting data from "user"."""
input user_order_by {
  activeTeamId: order_by
  avatarUrl: order_by
  createdAt: order_by
  email: order_by
  hasPassword: order_by
  id: order_by
  invitation_aggregate: teamInvitation_aggregate_order_by
  name: order_by
  notifications_aggregate: notificationUser_aggregate_order_by
  registrationStep: order_by
  teams_aggregate: teamUser_aggregate_order_by
  tokens_aggregate: token_aggregate_order_by
  updatedAt: order_by
  userSubscription: userSubscription_order_by
  user_activeTeam: team_order_by
  user_notificationUsers_aggregate: notificationUser_aggregate_order_by
  user_teamInvitation_aggregate: teamInvitation_aggregate_order_by
  viewPreferences_aggregate: viewPreferences_aggregate_order_by
}

"""primary key columns input for table: user"""
input user_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  activeTeamId

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  registrationStep

  """column name"""
  updatedAt
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  activeTeamId: uuid
  avatarUrl: String
  name: String
  registrationStep: registrationStep_enum
}

"""
Streaming cursor of the table "user"
"""
input user_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_stream_cursor_value_input {
  activeTeamId: uuid
  avatarUrl: String
  createdAt: timestamptz
  email: String
  id: uuid
  name: String
  registrationStep: registrationStep_enum
  updatedAt: timestamptz
}

input user_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_set_input

  """filter the rows which have to be updated"""
  where: user_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

enum vendorEnum_enum {
  agora
  aws
  azure
  braintree
  digitalOcean
  googleCloud
  mailchimp
  mixpanel
  other
  paypal
  pulumi
  segment
  sendgrid
  stripe
  terraform
  twilio
}

"""
Boolean expression to compare columns of type "vendorEnum_enum". All fields are combined with logical 'AND'.
"""
input vendorEnum_enum_comparison_exp {
  _eq: vendorEnum_enum
  _in: [vendorEnum_enum!]
  _is_null: Boolean
  _neq: vendorEnum_enum
  _nin: [vendorEnum_enum!]
}

"""
columns and relationships of "viewPreferences"
"""
type viewPreferences {
  id: uuid!
  isSortingReversed: Boolean!
  layout: String
  listId: listIdEnum_enum!
  sortedBy: String
}

"""
order by aggregate values of table "viewPreferences"
"""
input viewPreferences_aggregate_order_by {
  count: order_by
  max: viewPreferences_max_order_by
  min: viewPreferences_min_order_by
}

"""
Boolean expression to filter rows from the table "viewPreferences". All fields are combined with a logical 'AND'.
"""
input viewPreferences_bool_exp {
  _and: [viewPreferences_bool_exp!]
  _not: viewPreferences_bool_exp
  _or: [viewPreferences_bool_exp!]
  id: uuid_comparison_exp
  isSortingReversed: Boolean_comparison_exp
  layout: String_comparison_exp
  listId: listIdEnum_enum_comparison_exp
  sortedBy: String_comparison_exp
}

"""
unique or primary key constraints on table "viewPreferences"
"""
enum viewPreferences_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  viewPreferences_pkey

  """
  unique or primary key constraint on columns "userId", "listId"
  """
  viewPreferences_userId_listId_key
}

"""
input type for inserting data into table "viewPreferences"
"""
input viewPreferences_insert_input {
  isSortingReversed: Boolean
  layout: String
  listId: listIdEnum_enum
  sortedBy: String
  userId: uuid
}

"""
order by max() on columns of table "viewPreferences"
"""
input viewPreferences_max_order_by {
  id: order_by
  layout: order_by
  sortedBy: order_by
}

"""
order by min() on columns of table "viewPreferences"
"""
input viewPreferences_min_order_by {
  id: order_by
  layout: order_by
  sortedBy: order_by
}

"""
response of any mutation on the table "viewPreferences"
"""
type viewPreferences_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [viewPreferences!]!
}

"""
on_conflict condition type for table "viewPreferences"
"""
input viewPreferences_on_conflict {
  constraint: viewPreferences_constraint!
  update_columns: [viewPreferences_update_column!]! = []
  where: viewPreferences_bool_exp
}

"""Ordering options when selecting data from "viewPreferences"."""
input viewPreferences_order_by {
  id: order_by
  isSortingReversed: order_by
  layout: order_by
  listId: order_by
  sortedBy: order_by
}

"""primary key columns input for table: viewPreferences"""
input viewPreferences_pk_columns_input {
  id: uuid!
}

"""
select columns of table "viewPreferences"
"""
enum viewPreferences_select_column {
  """column name"""
  id

  """column name"""
  isSortingReversed

  """column name"""
  layout

  """column name"""
  listId

  """column name"""
  sortedBy
}

"""
input type for updating data in table "viewPreferences"
"""
input viewPreferences_set_input {
  isSortingReversed: Boolean
  layout: String
  sortedBy: String
}

"""
Streaming cursor of the table "viewPreferences"
"""
input viewPreferences_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: viewPreferences_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input viewPreferences_stream_cursor_value_input {
  id: uuid
  isSortingReversed: Boolean
  layout: String
  listId: listIdEnum_enum
  sortedBy: String
}

"""
update columns of table "viewPreferences"
"""
enum viewPreferences_update_column {
  """column name"""
  isSortingReversed

  """column name"""
  layout

  """column name"""
  sortedBy
}

input viewPreferences_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: viewPreferences_set_input

  """filter the rows which have to be updated"""
  where: viewPreferences_bool_exp!
}

