schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

input AcceptInvitationInput {
  invitationId: uuid!
  userId: uuid!
}

type AcceptInvitationOutput {
  invitationId: uuid!
  invite: teamInvitation
  teamUser: teamUser
  teamUserId: uuid!
}

input AcceptTeamInviteInput {
  failureAcceptInviteMessage: String!
  successfullAcceptInviteMessage: String!
  teamId: String!
}

type AcceptTeamInviteOutput {
  errorCode: String
  success: Boolean!
}

input AddedTeamsIdsType {
  teamId: String!
  tokenId: String!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

input CancelSubscriptionInput {
  stripeCustomerId: String!
}

type CancelSubscriptionOutput {
  cancelAt: Int
  currentPlan: String
}

input ChangePasswordInput {
  email: String!
  newPassword: String!
  oldPassword: String!
}

type ChangePasswordOutput {
  success: Boolean
}

input ChangeSubscriptionInput {
  priceId: String!
  stripeCustomerId: String!
}

type ChangeSubscriptionOutput {
  success: Boolean
}

input CheckIntegrationDeployInput {
  accountId: String!
}

type CheckIntegrationDeployOutput {
  status: DeployStatusIntegration!
}

input CheckPaymentMethodInput {
  stripeCustomerId: String!
}

type CheckPaymentMethodOutput {
  brand: String
  expirationMonth: Int
  expirationYear: Int
  last4: String
  lastUpdated: Int
}

input CheckUserEmailExistInput {
  email: String!
}

type CheckUserEmailExistOutput {
  isExist: Boolean!
}

input CliAccessTokensInput {
  code: String!
}

type CliAccessTokensOutput {
  accessToken: String!
}

input ConfirmEmailChangeInput {
  code: String!
}

type ConfirmEmailChangeOutput {
  accessToken: String!
}

input CreateCustomerInput {
  email: String!
  userId: String!
}

type CreateCustomerOutput {
  stripeCustomerId: String
}

input CreateProjectInput {
  activeTeamId: uuid
  icon: String!
  name: String!
}

type CreateProjectOutput {
  id: uuid!
  project: token
  token: String!
}

input CreateSecretFieldInput {
  name: String!
  value: String!
}

input CreateSecretInput {
  name: String!
  tokenId: String!
  vendor: String!
}

type CreateSecretOutput {
  secretId: String!
}

input CreateTeamInput {
  teamName: String!
}

type CreateTeamOutput {
  errorCode: String
  teamId: String!
}

input CurrentPlanInput {
  sessionId: String!
}

type CurrentPlanOutput {
  cancelAt: Int
  currentPlan: String
  interval: String
}

input DecodeSharingSecretsInput {
  id: String!
  passPhrase: String
}

type DecodeSharingSecretsOutput {
  secrets: json!
}

type DecryptedSecretField {
  key: String!
  value: String!
}

input DeleteProjectsInput {
  deleteSecretsOn3rdParty: Boolean
  ids: [uuid!]!
}

type DeleteProjectsOutput {
  affected_rows: Int!
}

enum DeployStatusIntegration {
  CREATE_COMPLETE
  DEPLOY_FAILED
  DEPLOY_IN_PROGRESS
}

input EmailVerifyInput {
  code: String!
}

type EmailVerifyOutput {
  accessToken: String
}

type Environment {
  isInUse: Boolean!
  name: String!
}

input GenerateSecretSharingUrlInput {
  expiresAt: timestamptz!
  passPhrase: String
  secretsFieldsIds: [String!]!
  tokenId: String!
}

type GenerateSecretSharingUrlOutput {
  url: String!
}

input GithubSignInInput {
  code: String!
}

type GithubSignInOutput {
  accessToken: String!
  isNewUser: Boolean!
}

input GoogleSignInInput {
  code: String!
}

type GoogleSignInOutput {
  accessToken: String!
  isNewUser: Boolean!
}

type InstallationOutput {
  id: String!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input IntegrationAWSInstallInputZero {
  accountId: String!
  integrationId: String!
  projectId: String!
  secretName: String!
  secretsIds: [String]
}

type IntegrationAWSInstallOutput {
  installation: IntegrationAWSInstallOutputInstallation!
}

type IntegrationAWSInstallOutputInstallation {
  id: String!
}

input IntegrationAuthInputIntegration {
  vendorName: String!
}

input IntegrationAuthInputZero {
  userId: String!
}

input IntegrationAuthOAuthInput {
  code: String!
}

type IntegrationAuthOutput {
  id: String!
  response: String!
}

input IntegrationDeleteInput {
  id: String
  installationId: String
  isDeleteInRemoteSourceEnabled: Boolean
}

type IntegrationDeleteOutput {
  success: Boolean!
}

input IntegrationDownloadSecretsInputIntegration {
  installationId: String!
}

input IntegrationDownloadSecretsInputZero {
  projectId: String!
  userId: String!
}

type IntegrationDownloadSecretsOutput {
  secret: SecretOutput!
}

input IntegrationInstallInputIntegration {
  extra: String!
  vendorName: String!
}

input IntegrationInstallInputZero {
  integrationId: String!
  isDownloadSecretsEnabled: Boolean
  projectId: String
  secretsIds: [String]
}

type IntegrationInstallOutput {
  installation: IntegrationInstallOutputInstallation!
}

type IntegrationInstallOutputInstallation {
  id: String!
}

type IntegrationProject {
  environments: [Environment!]!
  id: String!
  isInUse: Boolean!
  name: String!
}

input IntegrationProjectsInput {
  code: String!
  projectId: String!
  vendorName: String!
}

type IntegrationProjectsOutput {
  integrationId: String!
  projects: [IntegrationProject!]!
}

input IntegrationUpdateInputIntegration {
  extra: String
  installationId: String!
}

input IntegrationUpdateInputZero {
  secretsIds: [String]
}

type IntegrationUpdateOutput {
  errors: [String!]
  installation: InstallationOutput!
  success: Boolean!
}

input IntegrationUploadSecretsInputIntegration {
  installationId: String!
}

input IntegrationUploadSecretsInputZero {
  secretsIds: [String]
  userId: String!
}

type IntegrationUploadSecretsOutput {
  success: Boolean!
}

type MeOutput {
  id: ID!
}

type Payment {
  amount: String!
  card: String
  createdAt: String!
  description: String
  id: ID!
  paymentMethod: String
  url: String
}

input PaymentListInput {
  endingBeforePaymentId: ID
  limit: Int!
  startingAfterPaymentId: ID
  stripeCustomerId: String!
}

type PaymentListOutput {
  hasMore: Boolean!
  items: [Payment]!
}

input RecalculateTeamSeatsSubscriptionInput {
  paidSeats: Int!
}

type RecalculateTeamSeatsSubscriptionOutput {
  success: Boolean
}

input RefreshAccessTokenInput {
  refreshToken: String!
}

type RefreshAccessTokenOutput {
  accessToken: String!
}

input RejectTeamInviteInput {
  inviteId: String!
}

type RejectTeamInviteOutput {
  errorCode: String
  success: Boolean!
}

input RemovePaidFeaturesInput {
  stripeCustomerId: String!
}

type RemovePaidFeaturesOutput {
  success: Boolean
}

input RemoveTeamInput {
  teamId: String!
  teamMemberIds: [String!]!
  teamName: String!
}

type RemoveTeamOutput {
  errorCode: String
  success: Boolean!
}

input RemoveUserFromTeamInput {
  ownerTeamUserId: String!
  teamId: String!
  userId: String!
}

type RemoveUserFromTeamOutput {
  errorCode: String
  success: Boolean!
}

input RequestEmailChangeInput {
  newEmail: String!
}

type RequestEmailChangeOutput {
  errorCode: String
  success: Boolean!
}

input RequestResetPasswordInput {
  email: String!
  isReset: Boolean
}

type RequestResetPasswordOutput {
  errorCode: String
  success: Boolean
}

type ResendSignUpEmailOutput {
  success: Boolean
}

input ResetPasswordInput {
  code: String!
  newPassword: String!
}

type ResetPasswordOutput {
  success: Boolean
}

input RotateTokenInput {
  projectId: uuid!
}

type RotateTokenOutput {
  id: uuid!
  project: token
  token: String!
}

type SecretOutput {
  id: String!
}

input SendEmailToContactUsInput {
  email: String!
  message: String!
  name: String!
}

type SendEmailToContactUsOutput {
  success: Boolean!
}

input SendInviteUserTeamInput {
  email: String!
  teamId: String!
}

type SendInviteUserTeamOutput {
  errorCode: String
  success: Boolean!
}

input SendNotificationInput {
  message: String!
  userId: uuid!
  users: [uuid!]!
}

type SendNotificationsOutput {
  success: Boolean!
}

input SignInInput {
  email: String!
  password: String!
}

type SignInOutput {
  accessToken: String!
}

input SignUpInput {
  email: String!
  isMarketingEmailsRequested: Boolean
  password: String!
}

type SignUpOutput {
  accessToken: String!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

input UpdatePaymentMethodInput {
  stripeCustomerId: String!
}

type UpdatePaymentMethodOutput {
  paymentMethod: String
}

input UpdateProjectSettingsInput {
  addedTeamsIds: [AddedTeamsIdsType]!
  icon: String!
  projectDescription: String
  projectId: String!
  projectName: String!
  removedTeamsIds: [String]!
}

type UpdateProjectSettingsOutput {
  errorCode: String
  success: String
}

type UpdateSecretOutput {
  success: Boolean!
}

input UpdateUserSecretFieldsInput {
  decryptedValue: String
  encryptedValue: String
  name: String!
  userSecretId: String!
}

input UpdateUserSecretInput {
  id: String!
  name: String!
}

input ViewSecretFieldsInput {
  secretId: String!
}

type ViewSecretFieldsOutput {
  secretFields: [DecryptedSecretField!]!
}

"""The table for the CLI login"""
type cli {
  code: String!
  created_at: timestamptz!
  id: uuid!
  updated_at: timestamptz!
  userId: uuid!
}

"""
aggregated selection of "cli"
"""
type cli_aggregate {
  aggregate: cli_aggregate_fields
  nodes: [cli!]!
}

"""
aggregate fields of "cli"
"""
type cli_aggregate_fields {
  count(columns: [cli_select_column!], distinct: Boolean): Int!
  max: cli_max_fields
  min: cli_min_fields
}

"""
Boolean expression to filter rows from the table "cli". All fields are combined with a logical 'AND'.
"""
input cli_bool_exp {
  _and: [cli_bool_exp!]
  _not: cli_bool_exp
  _or: [cli_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "cli"
"""
enum cli_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  cli_code_key

  """
  unique or primary key constraint on columns "id"
  """
  cli_pkey
}

"""
input type for inserting data into table "cli"
"""
input cli_insert_input {
  code: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
  userId: uuid
}

"""aggregate max on columns"""
type cli_max_fields {
  code: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
  userId: uuid
}

"""aggregate min on columns"""
type cli_min_fields {
  code: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
  userId: uuid
}

"""
response of any mutation on the table "cli"
"""
type cli_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [cli!]!
}

"""
on_conflict condition type for table "cli"
"""
input cli_on_conflict {
  constraint: cli_constraint!
  update_columns: [cli_update_column!]! = []
  where: cli_bool_exp
}

"""Ordering options when selecting data from "cli"."""
input cli_order_by {
  code: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  userId: order_by
}

"""primary key columns input for table: cli"""
input cli_pk_columns_input {
  id: uuid!
}

"""
select columns of table "cli"
"""
enum cli_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  userId
}

"""
input type for updating data in table "cli"
"""
input cli_set_input {
  code: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "cli"
"""
input cli_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: cli_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input cli_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
  userId: uuid
}

"""
update columns of table "cli"
"""
enum cli_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  userId
}

input cli_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: cli_set_input

  """filter the rows which have to be updated"""
  where: cli_bool_exp!
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar inet

"""
Boolean expression to compare columns of type "inet". All fields are combined with logical 'AND'.
"""
input inet_comparison_exp {
  _eq: inet
  _gt: inet
  _gte: inet
  _in: [inet!]
  _is_null: Boolean
  _lt: inet
  _lte: inet
  _neq: inet
  _nin: [inet!]
}

"""integration relative data"""
type integration {
  createdAt: timestamptz!
  extra(
    """JSON select path"""
    path: String
  ): jsonb
  id: uuid!

  """An array relationship"""
  installations(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): [integrationInstallation!]!

  """An aggregate relationship"""
  installations_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): integrationInstallation_aggregate!
  updatedAt: timestamptz!
  userId: uuid
  vendorName: integrationVendorNameEnum_enum!
}

"""
Created per each integration installation, should link 3rd party with zero project
"""
type integrationInstallation {
  createdAt: timestamptz!
  extra(
    """JSON select path"""
    path: String
  ): jsonb
  id: uuid!

  """An object relationship"""
  integration: integration
  integrationId: uuid!
  isSuccessful: Boolean
  projectId: uuid

  """An array relationship"""
  secrets(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): [integrationInstallationUserSecret!]!

  """An aggregate relationship"""
  secrets_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): integrationInstallationUserSecret_aggregate!
  updatedAt: timestamptz!
  vendorProjectName: String!
}

"""
columns and relationships of "integrationInstallationUserSecret"
"""
type integrationInstallationUserSecret {
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  integrationInstallation: integrationInstallation
  integrationInstallationId: uuid!

  """An object relationship"""
  secret: userSecret
  updatedAt: timestamptz!
  userSecretId: uuid!
}

"""
aggregated selection of "integrationInstallationUserSecret"
"""
type integrationInstallationUserSecret_aggregate {
  aggregate: integrationInstallationUserSecret_aggregate_fields
  nodes: [integrationInstallationUserSecret!]!
}

input integrationInstallationUserSecret_aggregate_bool_exp {
  count: integrationInstallationUserSecret_aggregate_bool_exp_count
}

input integrationInstallationUserSecret_aggregate_bool_exp_count {
  arguments: [integrationInstallationUserSecret_select_column!]
  distinct: Boolean
  filter: integrationInstallationUserSecret_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "integrationInstallationUserSecret"
"""
type integrationInstallationUserSecret_aggregate_fields {
  count(columns: [integrationInstallationUserSecret_select_column!], distinct: Boolean): Int!
  max: integrationInstallationUserSecret_max_fields
  min: integrationInstallationUserSecret_min_fields
}

"""
order by aggregate values of table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_aggregate_order_by {
  count: order_by
  max: integrationInstallationUserSecret_max_order_by
  min: integrationInstallationUserSecret_min_order_by
}

"""
input type for inserting array relation for remote table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_arr_rel_insert_input {
  data: [integrationInstallationUserSecret_insert_input!]!

  """upsert condition"""
  on_conflict: integrationInstallationUserSecret_on_conflict
}

"""
Boolean expression to filter rows from the table "integrationInstallationUserSecret". All fields are combined with a logical 'AND'.
"""
input integrationInstallationUserSecret_bool_exp {
  _and: [integrationInstallationUserSecret_bool_exp!]
  _not: integrationInstallationUserSecret_bool_exp
  _or: [integrationInstallationUserSecret_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  integrationInstallation: integrationInstallation_bool_exp
  integrationInstallationId: uuid_comparison_exp
  secret: userSecret_bool_exp
  updatedAt: timestamptz_comparison_exp
  userSecretId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "integrationInstallationUserSecret"
"""
enum integrationInstallationUserSecret_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  integrationInstallationUserSecret_pkey
}

"""
input type for inserting data into table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_insert_input {
  createdAt: timestamptz
  id: uuid
  integrationInstallation: integrationInstallation_obj_rel_insert_input
  integrationInstallationId: uuid
  secret: userSecret_obj_rel_insert_input
  updatedAt: timestamptz
  userSecretId: uuid
}

"""aggregate max on columns"""
type integrationInstallationUserSecret_max_fields {
  createdAt: timestamptz
  id: uuid
  integrationInstallationId: uuid
  updatedAt: timestamptz
  userSecretId: uuid
}

"""
order by max() on columns of table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_max_order_by {
  createdAt: order_by
  id: order_by
  integrationInstallationId: order_by
  updatedAt: order_by
  userSecretId: order_by
}

"""aggregate min on columns"""
type integrationInstallationUserSecret_min_fields {
  createdAt: timestamptz
  id: uuid
  integrationInstallationId: uuid
  updatedAt: timestamptz
  userSecretId: uuid
}

"""
order by min() on columns of table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_min_order_by {
  createdAt: order_by
  id: order_by
  integrationInstallationId: order_by
  updatedAt: order_by
  userSecretId: order_by
}

"""
response of any mutation on the table "integrationInstallationUserSecret"
"""
type integrationInstallationUserSecret_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [integrationInstallationUserSecret!]!
}

"""
on_conflict condition type for table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_on_conflict {
  constraint: integrationInstallationUserSecret_constraint!
  update_columns: [integrationInstallationUserSecret_update_column!]! = []
  where: integrationInstallationUserSecret_bool_exp
}

"""
Ordering options when selecting data from "integrationInstallationUserSecret".
"""
input integrationInstallationUserSecret_order_by {
  createdAt: order_by
  id: order_by
  integrationInstallation: integrationInstallation_order_by
  integrationInstallationId: order_by
  secret: userSecret_order_by
  updatedAt: order_by
  userSecretId: order_by
}

"""primary key columns input for table: integrationInstallationUserSecret"""
input integrationInstallationUserSecret_pk_columns_input {
  id: uuid!
}

"""
select columns of table "integrationInstallationUserSecret"
"""
enum integrationInstallationUserSecret_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  integrationInstallationId

  """column name"""
  updatedAt

  """column name"""
  userSecretId
}

"""
input type for updating data in table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_set_input {
  createdAt: timestamptz
  id: uuid
  integrationInstallationId: uuid
  updatedAt: timestamptz
  userSecretId: uuid
}

"""
Streaming cursor of the table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: integrationInstallationUserSecret_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input integrationInstallationUserSecret_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  integrationInstallationId: uuid
  updatedAt: timestamptz
  userSecretId: uuid
}

"""
update columns of table "integrationInstallationUserSecret"
"""
enum integrationInstallationUserSecret_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  integrationInstallationId

  """column name"""
  updatedAt

  """column name"""
  userSecretId
}

input integrationInstallationUserSecret_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: integrationInstallationUserSecret_set_input

  """filter the rows which have to be updated"""
  where: integrationInstallationUserSecret_bool_exp!
}

"""
aggregated selection of "integrationInstallation"
"""
type integrationInstallation_aggregate {
  aggregate: integrationInstallation_aggregate_fields
  nodes: [integrationInstallation!]!
}

input integrationInstallation_aggregate_bool_exp {
  bool_and: integrationInstallation_aggregate_bool_exp_bool_and
  bool_or: integrationInstallation_aggregate_bool_exp_bool_or
  count: integrationInstallation_aggregate_bool_exp_count
}

input integrationInstallation_aggregate_bool_exp_bool_and {
  arguments: integrationInstallation_select_column_integrationInstallation_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: integrationInstallation_bool_exp
  predicate: Boolean_comparison_exp!
}

input integrationInstallation_aggregate_bool_exp_bool_or {
  arguments: integrationInstallation_select_column_integrationInstallation_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: integrationInstallation_bool_exp
  predicate: Boolean_comparison_exp!
}

input integrationInstallation_aggregate_bool_exp_count {
  arguments: [integrationInstallation_select_column!]
  distinct: Boolean
  filter: integrationInstallation_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "integrationInstallation"
"""
type integrationInstallation_aggregate_fields {
  count(columns: [integrationInstallation_select_column!], distinct: Boolean): Int!
  max: integrationInstallation_max_fields
  min: integrationInstallation_min_fields
}

"""
order by aggregate values of table "integrationInstallation"
"""
input integrationInstallation_aggregate_order_by {
  count: order_by
  max: integrationInstallation_max_order_by
  min: integrationInstallation_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input integrationInstallation_append_input {
  extra: jsonb
}

"""
input type for inserting array relation for remote table "integrationInstallation"
"""
input integrationInstallation_arr_rel_insert_input {
  data: [integrationInstallation_insert_input!]!

  """upsert condition"""
  on_conflict: integrationInstallation_on_conflict
}

"""
Boolean expression to filter rows from the table "integrationInstallation". All fields are combined with a logical 'AND'.
"""
input integrationInstallation_bool_exp {
  _and: [integrationInstallation_bool_exp!]
  _not: integrationInstallation_bool_exp
  _or: [integrationInstallation_bool_exp!]
  createdAt: timestamptz_comparison_exp
  extra: jsonb_comparison_exp
  id: uuid_comparison_exp
  integration: integration_bool_exp
  integrationId: uuid_comparison_exp
  isSuccessful: Boolean_comparison_exp
  projectId: uuid_comparison_exp
  secrets: integrationInstallationUserSecret_bool_exp
  secrets_aggregate: integrationInstallationUserSecret_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
  vendorProjectName: String_comparison_exp
}

"""
unique or primary key constraints on table "integrationInstallation"
"""
enum integrationInstallation_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  integrationInstallation_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input integrationInstallation_delete_at_path_input {
  extra: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input integrationInstallation_delete_elem_input {
  extra: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input integrationInstallation_delete_key_input {
  extra: String
}

"""
input type for inserting data into table "integrationInstallation"
"""
input integrationInstallation_insert_input {
  createdAt: timestamptz
  extra: jsonb
  id: uuid
  integration: integration_obj_rel_insert_input
  integrationId: uuid
  isSuccessful: Boolean
  projectId: uuid
  secrets: integrationInstallationUserSecret_arr_rel_insert_input
  updatedAt: timestamptz
  vendorProjectName: String
}

"""aggregate max on columns"""
type integrationInstallation_max_fields {
  createdAt: timestamptz
  id: uuid
  integrationId: uuid
  projectId: uuid
  updatedAt: timestamptz
  vendorProjectName: String
}

"""
order by max() on columns of table "integrationInstallation"
"""
input integrationInstallation_max_order_by {
  createdAt: order_by
  id: order_by
  integrationId: order_by
  projectId: order_by
  updatedAt: order_by
  vendorProjectName: order_by
}

"""aggregate min on columns"""
type integrationInstallation_min_fields {
  createdAt: timestamptz
  id: uuid
  integrationId: uuid
  projectId: uuid
  updatedAt: timestamptz
  vendorProjectName: String
}

"""
order by min() on columns of table "integrationInstallation"
"""
input integrationInstallation_min_order_by {
  createdAt: order_by
  id: order_by
  integrationId: order_by
  projectId: order_by
  updatedAt: order_by
  vendorProjectName: order_by
}

"""
response of any mutation on the table "integrationInstallation"
"""
type integrationInstallation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [integrationInstallation!]!
}

"""
input type for inserting object relation for remote table "integrationInstallation"
"""
input integrationInstallation_obj_rel_insert_input {
  data: integrationInstallation_insert_input!

  """upsert condition"""
  on_conflict: integrationInstallation_on_conflict
}

"""
on_conflict condition type for table "integrationInstallation"
"""
input integrationInstallation_on_conflict {
  constraint: integrationInstallation_constraint!
  update_columns: [integrationInstallation_update_column!]! = []
  where: integrationInstallation_bool_exp
}

"""Ordering options when selecting data from "integrationInstallation"."""
input integrationInstallation_order_by {
  createdAt: order_by
  extra: order_by
  id: order_by
  integration: integration_order_by
  integrationId: order_by
  isSuccessful: order_by
  projectId: order_by
  secrets_aggregate: integrationInstallationUserSecret_aggregate_order_by
  updatedAt: order_by
  vendorProjectName: order_by
}

"""primary key columns input for table: integrationInstallation"""
input integrationInstallation_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input integrationInstallation_prepend_input {
  extra: jsonb
}

"""
select columns of table "integrationInstallation"
"""
enum integrationInstallation_select_column {
  """column name"""
  createdAt

  """column name"""
  extra

  """column name"""
  id

  """column name"""
  integrationId

  """column name"""
  isSuccessful

  """column name"""
  projectId

  """column name"""
  updatedAt

  """column name"""
  vendorProjectName
}

"""
select "integrationInstallation_aggregate_bool_exp_bool_and_arguments_columns" columns of table "integrationInstallation"
"""
enum integrationInstallation_select_column_integrationInstallation_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  isSuccessful
}

"""
select "integrationInstallation_aggregate_bool_exp_bool_or_arguments_columns" columns of table "integrationInstallation"
"""
enum integrationInstallation_select_column_integrationInstallation_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  isSuccessful
}

"""
input type for updating data in table "integrationInstallation"
"""
input integrationInstallation_set_input {
  createdAt: timestamptz
  extra: jsonb
  id: uuid
  integrationId: uuid
  isSuccessful: Boolean
  projectId: uuid
  updatedAt: timestamptz
  vendorProjectName: String
}

"""
Streaming cursor of the table "integrationInstallation"
"""
input integrationInstallation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: integrationInstallation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input integrationInstallation_stream_cursor_value_input {
  createdAt: timestamptz
  extra: jsonb
  id: uuid
  integrationId: uuid
  isSuccessful: Boolean
  projectId: uuid
  updatedAt: timestamptz
  vendorProjectName: String
}

"""
update columns of table "integrationInstallation"
"""
enum integrationInstallation_update_column {
  """column name"""
  createdAt

  """column name"""
  extra

  """column name"""
  id

  """column name"""
  integrationId

  """column name"""
  isSuccessful

  """column name"""
  projectId

  """column name"""
  updatedAt

  """column name"""
  vendorProjectName
}

input integrationInstallation_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: integrationInstallation_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: integrationInstallation_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: integrationInstallation_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: integrationInstallation_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: integrationInstallation_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: integrationInstallation_set_input

  """filter the rows which have to be updated"""
  where: integrationInstallation_bool_exp!
}

"""integration services names"""
type integrationVendorNameEnum {
  value: String!
}

"""
aggregated selection of "integrationVendorNameEnum"
"""
type integrationVendorNameEnum_aggregate {
  aggregate: integrationVendorNameEnum_aggregate_fields
  nodes: [integrationVendorNameEnum!]!
}

"""
aggregate fields of "integrationVendorNameEnum"
"""
type integrationVendorNameEnum_aggregate_fields {
  count(columns: [integrationVendorNameEnum_select_column!], distinct: Boolean): Int!
  max: integrationVendorNameEnum_max_fields
  min: integrationVendorNameEnum_min_fields
}

"""
Boolean expression to filter rows from the table "integrationVendorNameEnum". All fields are combined with a logical 'AND'.
"""
input integrationVendorNameEnum_bool_exp {
  _and: [integrationVendorNameEnum_bool_exp!]
  _not: integrationVendorNameEnum_bool_exp
  _or: [integrationVendorNameEnum_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "integrationVendorNameEnum"
"""
enum integrationVendorNameEnum_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  integrationServiceNameEnum_pkey
}

enum integrationVendorNameEnum_enum {
  aws
  netlify
  vercel
}

"""
Boolean expression to compare columns of type "integrationVendorNameEnum_enum". All fields are combined with logical 'AND'.
"""
input integrationVendorNameEnum_enum_comparison_exp {
  _eq: integrationVendorNameEnum_enum
  _in: [integrationVendorNameEnum_enum!]
  _is_null: Boolean
  _neq: integrationVendorNameEnum_enum
  _nin: [integrationVendorNameEnum_enum!]
}

"""
input type for inserting data into table "integrationVendorNameEnum"
"""
input integrationVendorNameEnum_insert_input {
  value: String
}

"""aggregate max on columns"""
type integrationVendorNameEnum_max_fields {
  value: String
}

"""aggregate min on columns"""
type integrationVendorNameEnum_min_fields {
  value: String
}

"""
response of any mutation on the table "integrationVendorNameEnum"
"""
type integrationVendorNameEnum_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [integrationVendorNameEnum!]!
}

"""
on_conflict condition type for table "integrationVendorNameEnum"
"""
input integrationVendorNameEnum_on_conflict {
  constraint: integrationVendorNameEnum_constraint!
  update_columns: [integrationVendorNameEnum_update_column!]! = []
  where: integrationVendorNameEnum_bool_exp
}

"""Ordering options when selecting data from "integrationVendorNameEnum"."""
input integrationVendorNameEnum_order_by {
  value: order_by
}

"""primary key columns input for table: integrationVendorNameEnum"""
input integrationVendorNameEnum_pk_columns_input {
  value: String!
}

"""
select columns of table "integrationVendorNameEnum"
"""
enum integrationVendorNameEnum_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "integrationVendorNameEnum"
"""
input integrationVendorNameEnum_set_input {
  value: String
}

"""
Streaming cursor of the table "integrationVendorNameEnum"
"""
input integrationVendorNameEnum_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: integrationVendorNameEnum_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input integrationVendorNameEnum_stream_cursor_value_input {
  value: String
}

"""
update columns of table "integrationVendorNameEnum"
"""
enum integrationVendorNameEnum_update_column {
  """column name"""
  value
}

input integrationVendorNameEnum_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: integrationVendorNameEnum_set_input

  """filter the rows which have to be updated"""
  where: integrationVendorNameEnum_bool_exp!
}

"""
aggregated selection of "integration"
"""
type integration_aggregate {
  aggregate: integration_aggregate_fields
  nodes: [integration!]!
}

"""
aggregate fields of "integration"
"""
type integration_aggregate_fields {
  count(columns: [integration_select_column!], distinct: Boolean): Int!
  max: integration_max_fields
  min: integration_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input integration_append_input {
  extra: jsonb
}

"""
Boolean expression to filter rows from the table "integration". All fields are combined with a logical 'AND'.
"""
input integration_bool_exp {
  _and: [integration_bool_exp!]
  _not: integration_bool_exp
  _or: [integration_bool_exp!]
  createdAt: timestamptz_comparison_exp
  extra: jsonb_comparison_exp
  id: uuid_comparison_exp
  installations: integrationInstallation_bool_exp
  installations_aggregate: integrationInstallation_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
  userId: uuid_comparison_exp
  vendorName: integrationVendorNameEnum_enum_comparison_exp
}

"""
unique or primary key constraints on table "integration"
"""
enum integration_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  integration_pkey

  """
  unique or primary key constraint on columns "userId", "vendorName"
  """
  integration_userId_vendorName_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input integration_delete_at_path_input {
  extra: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input integration_delete_elem_input {
  extra: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input integration_delete_key_input {
  extra: String
}

"""
input type for inserting data into table "integration"
"""
input integration_insert_input {
  createdAt: timestamptz
  extra: jsonb
  id: uuid
  installations: integrationInstallation_arr_rel_insert_input
  updatedAt: timestamptz
  userId: uuid
  vendorName: integrationVendorNameEnum_enum
}

"""aggregate max on columns"""
type integration_max_fields {
  createdAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate min on columns"""
type integration_min_fields {
  createdAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
response of any mutation on the table "integration"
"""
type integration_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [integration!]!
}

"""
input type for inserting object relation for remote table "integration"
"""
input integration_obj_rel_insert_input {
  data: integration_insert_input!

  """upsert condition"""
  on_conflict: integration_on_conflict
}

"""
on_conflict condition type for table "integration"
"""
input integration_on_conflict {
  constraint: integration_constraint!
  update_columns: [integration_update_column!]! = []
  where: integration_bool_exp
}

"""Ordering options when selecting data from "integration"."""
input integration_order_by {
  createdAt: order_by
  extra: order_by
  id: order_by
  installations_aggregate: integrationInstallation_aggregate_order_by
  updatedAt: order_by
  userId: order_by
  vendorName: order_by
}

"""primary key columns input for table: integration"""
input integration_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input integration_prepend_input {
  extra: jsonb
}

"""
select columns of table "integration"
"""
enum integration_select_column {
  """column name"""
  createdAt

  """column name"""
  extra

  """column name"""
  id

  """column name"""
  updatedAt

  """column name"""
  userId

  """column name"""
  vendorName
}

"""
input type for updating data in table "integration"
"""
input integration_set_input {
  createdAt: timestamptz
  extra: jsonb
  id: uuid
  updatedAt: timestamptz
  userId: uuid
  vendorName: integrationVendorNameEnum_enum
}

"""
Streaming cursor of the table "integration"
"""
input integration_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: integration_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input integration_stream_cursor_value_input {
  createdAt: timestamptz
  extra: jsonb
  id: uuid
  updatedAt: timestamptz
  userId: uuid
  vendorName: integrationVendorNameEnum_enum
}

"""
update columns of table "integration"
"""
enum integration_update_column {
  """column name"""
  createdAt

  """column name"""
  extra

  """column name"""
  id

  """column name"""
  updatedAt

  """column name"""
  userId

  """column name"""
  vendorName
}

input integration_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: integration_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: integration_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: integration_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: integration_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: integration_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: integration_set_input

  """filter the rows which have to be updated"""
  where: integration_bool_exp!
}

"""
columns and relationships of "invitationStatusEnum"
"""
type invitationStatusEnum {
  value: String!
}

"""
aggregated selection of "invitationStatusEnum"
"""
type invitationStatusEnum_aggregate {
  aggregate: invitationStatusEnum_aggregate_fields
  nodes: [invitationStatusEnum!]!
}

"""
aggregate fields of "invitationStatusEnum"
"""
type invitationStatusEnum_aggregate_fields {
  count(columns: [invitationStatusEnum_select_column!], distinct: Boolean): Int!
  max: invitationStatusEnum_max_fields
  min: invitationStatusEnum_min_fields
}

"""
Boolean expression to filter rows from the table "invitationStatusEnum". All fields are combined with a logical 'AND'.
"""
input invitationStatusEnum_bool_exp {
  _and: [invitationStatusEnum_bool_exp!]
  _not: invitationStatusEnum_bool_exp
  _or: [invitationStatusEnum_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "invitationStatusEnum"
"""
enum invitationStatusEnum_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  invitationStatusEnum_pkey
}

enum invitationStatusEnum_enum {
  ACCEPT
  PENDING
  REJECT
}

"""
Boolean expression to compare columns of type "invitationStatusEnum_enum". All fields are combined with logical 'AND'.
"""
input invitationStatusEnum_enum_comparison_exp {
  _eq: invitationStatusEnum_enum
  _in: [invitationStatusEnum_enum!]
  _is_null: Boolean
  _neq: invitationStatusEnum_enum
  _nin: [invitationStatusEnum_enum!]
}

"""
input type for inserting data into table "invitationStatusEnum"
"""
input invitationStatusEnum_insert_input {
  value: String
}

"""aggregate max on columns"""
type invitationStatusEnum_max_fields {
  value: String
}

"""aggregate min on columns"""
type invitationStatusEnum_min_fields {
  value: String
}

"""
response of any mutation on the table "invitationStatusEnum"
"""
type invitationStatusEnum_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [invitationStatusEnum!]!
}

"""
on_conflict condition type for table "invitationStatusEnum"
"""
input invitationStatusEnum_on_conflict {
  constraint: invitationStatusEnum_constraint!
  update_columns: [invitationStatusEnum_update_column!]! = []
  where: invitationStatusEnum_bool_exp
}

"""Ordering options when selecting data from "invitationStatusEnum"."""
input invitationStatusEnum_order_by {
  value: order_by
}

"""primary key columns input for table: invitationStatusEnum"""
input invitationStatusEnum_pk_columns_input {
  value: String!
}

"""
select columns of table "invitationStatusEnum"
"""
enum invitationStatusEnum_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "invitationStatusEnum"
"""
input invitationStatusEnum_set_input {
  value: String
}

"""
Streaming cursor of the table "invitationStatusEnum"
"""
input invitationStatusEnum_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: invitationStatusEnum_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input invitationStatusEnum_stream_cursor_value_input {
  value: String
}

"""
update columns of table "invitationStatusEnum"
"""
enum invitationStatusEnum_update_column {
  """column name"""
  value
}

input invitationStatusEnum_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: invitationStatusEnum_set_input

  """filter the rows which have to be updated"""
  where: invitationStatusEnum_bool_exp!
}

scalar json

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""mutation root"""
type mutation_root {
  """Accept team invitation"""
  acceptInvitation(object: AcceptInvitationInput!): AcceptInvitationOutput
  acceptTeamInvite(object: AcceptTeamInviteInput!): AcceptTeamInviteOutput!
  cancelSubscription(object: CancelSubscriptionInput!): CancelSubscriptionOutput!
  changePassword(object: ChangePasswordInput!): ChangePasswordOutput!
  changeSubscription(object: ChangeSubscriptionInput!): ChangeSubscriptionOutput!
  cliAccessTokens(object: CliAccessTokensInput!): CliAccessTokensOutput!
  confirmEmailChange(object: ConfirmEmailChangeInput!): ConfirmEmailChangeOutput!
  createCustomer(object: CreateCustomerInput!): CreateCustomerOutput!

  """
  creates new project with unique auto generated token and optimally link the project to existed user team
  """
  createProject(object: CreateProjectInput!): CreateProjectOutput
  createSecret(fields: [CreateSecretFieldInput!]!, secret: CreateSecretInput!, userId: String!): CreateSecretOutput!
  createTeam(object: CreateTeamInput!): CreateTeamOutput!

  """Release (represent and erase) shared secrets"""
  decodeSharingSecrets(object: DecodeSharingSecretsInput!): DecodeSharingSecretsOutput!

  """
  deletes specified projects, all its relations and optionally deletes 3rd party secrets
  """
  deleteProjects(object: DeleteProjectsInput!): DeleteProjectsOutput

  """
  delete data from the table: "cli"
  """
  delete_cli(
    """filter the rows which have to be deleted"""
    where: cli_bool_exp!
  ): cli_mutation_response

  """
  delete single row from the table: "cli"
  """
  delete_cli_by_pk(id: uuid!): cli

  """
  delete data from the table: "integration"
  """
  delete_integration(
    """filter the rows which have to be deleted"""
    where: integration_bool_exp!
  ): integration_mutation_response

  """
  delete data from the table: "integrationInstallation"
  """
  delete_integrationInstallation(
    """filter the rows which have to be deleted"""
    where: integrationInstallation_bool_exp!
  ): integrationInstallation_mutation_response

  """
  delete data from the table: "integrationInstallationUserSecret"
  """
  delete_integrationInstallationUserSecret(
    """filter the rows which have to be deleted"""
    where: integrationInstallationUserSecret_bool_exp!
  ): integrationInstallationUserSecret_mutation_response

  """
  delete single row from the table: "integrationInstallationUserSecret"
  """
  delete_integrationInstallationUserSecret_by_pk(id: uuid!): integrationInstallationUserSecret

  """
  delete single row from the table: "integrationInstallation"
  """
  delete_integrationInstallation_by_pk(id: uuid!): integrationInstallation

  """
  delete data from the table: "integrationVendorNameEnum"
  """
  delete_integrationVendorNameEnum(
    """filter the rows which have to be deleted"""
    where: integrationVendorNameEnum_bool_exp!
  ): integrationVendorNameEnum_mutation_response

  """
  delete single row from the table: "integrationVendorNameEnum"
  """
  delete_integrationVendorNameEnum_by_pk(value: String!): integrationVendorNameEnum

  """
  delete single row from the table: "integration"
  """
  delete_integration_by_pk(id: uuid!): integration

  """
  delete data from the table: "invitationStatusEnum"
  """
  delete_invitationStatusEnum(
    """filter the rows which have to be deleted"""
    where: invitationStatusEnum_bool_exp!
  ): invitationStatusEnum_mutation_response

  """
  delete single row from the table: "invitationStatusEnum"
  """
  delete_invitationStatusEnum_by_pk(value: String!): invitationStatusEnum

  """
  delete data from the table: "notification"
  """
  delete_notification(
    """filter the rows which have to be deleted"""
    where: notification_bool_exp!
  ): notification_mutation_response

  """
  delete data from the table: "notificationUser"
  """
  delete_notificationUser(
    """filter the rows which have to be deleted"""
    where: notificationUser_bool_exp!
  ): notificationUser_mutation_response

  """
  delete single row from the table: "notificationUser"
  """
  delete_notificationUser_by_pk(id: uuid!): notificationUser

  """
  delete single row from the table: "notification"
  """
  delete_notification_by_pk(id: uuid!): notification

  """
  delete data from the table: "registrationStep"
  """
  delete_registrationStep(
    """filter the rows which have to be deleted"""
    where: registrationStep_bool_exp!
  ): registrationStep_mutation_response

  """
  delete single row from the table: "registrationStep"
  """
  delete_registrationStep_by_pk(value: String!): registrationStep

  """
  delete data from the table: "secretSharing"
  """
  delete_secretSharing(
    """filter the rows which have to be deleted"""
    where: secretSharing_bool_exp!
  ): secretSharing_mutation_response

  """
  delete single row from the table: "secretSharing"
  """
  delete_secretSharing_by_pk(id: uuid!): secretSharing

  """
  delete data from the table: "subscriptionIntervalEnum"
  """
  delete_subscriptionIntervalEnum(
    """filter the rows which have to be deleted"""
    where: subscriptionIntervalEnum_bool_exp!
  ): subscriptionIntervalEnum_mutation_response

  """
  delete single row from the table: "subscriptionIntervalEnum"
  """
  delete_subscriptionIntervalEnum_by_pk(value: String!): subscriptionIntervalEnum

  """
  delete data from the table: "subscriptionPlanEnum"
  """
  delete_subscriptionPlanEnum(
    """filter the rows which have to be deleted"""
    where: subscriptionPlanEnum_bool_exp!
  ): subscriptionPlanEnum_mutation_response

  """
  delete single row from the table: "subscriptionPlanEnum"
  """
  delete_subscriptionPlanEnum_by_pk(value: String!): subscriptionPlanEnum

  """
  delete data from the table: "tag"
  """
  delete_tag(
    """filter the rows which have to be deleted"""
    where: tag_bool_exp!
  ): tag_mutation_response

  """
  delete single row from the table: "tag"
  """
  delete_tag_by_pk(id: uuid!): tag

  """
  delete data from the table: "team"
  """
  delete_team(
    """filter the rows which have to be deleted"""
    where: team_bool_exp!
  ): team_mutation_response

  """
  delete data from the table: "teamInvitation"
  """
  delete_teamInvitation(
    """filter the rows which have to be deleted"""
    where: teamInvitation_bool_exp!
  ): teamInvitation_mutation_response

  """
  delete single row from the table: "teamInvitation"
  """
  delete_teamInvitation_by_pk(id: uuid!): teamInvitation

  """
  delete data from the table: "teamUser"
  """
  delete_teamUser(
    """filter the rows which have to be deleted"""
    where: teamUser_bool_exp!
  ): teamUser_mutation_response

  """
  delete single row from the table: "teamUser"
  """
  delete_teamUser_by_pk(id: uuid!): teamUser

  """
  delete single row from the table: "team"
  """
  delete_team_by_pk(id: uuid!): team

  """
  delete data from the table: "token"
  """
  delete_token(
    """filter the rows which have to be deleted"""
    where: token_bool_exp!
  ): token_mutation_response

  """
  delete data from the table: "tokenTag"
  """
  delete_tokenTag(
    """filter the rows which have to be deleted"""
    where: tokenTag_bool_exp!
  ): tokenTag_mutation_response

  """
  delete single row from the table: "tokenTag"
  """
  delete_tokenTag_by_pk(id: uuid!): tokenTag

  """
  delete data from the table: "tokenTeam"
  """
  delete_tokenTeam(
    """filter the rows which have to be deleted"""
    where: tokenTeam_bool_exp!
  ): tokenTeam_mutation_response

  """
  delete single row from the table: "tokenTeam"
  """
  delete_tokenTeam_by_pk(id: uuid!): tokenTeam

  """
  delete single row from the table: "token"
  """
  delete_token_by_pk(id: uuid!): token

  """
  delete data from the table: "usageHistory"
  """
  delete_usageHistory(
    """filter the rows which have to be deleted"""
    where: usageHistory_bool_exp!
  ): usageHistory_mutation_response

  """
  delete data from the table: "usageHistorySecret"
  """
  delete_usageHistorySecret(
    """filter the rows which have to be deleted"""
    where: usageHistorySecret_bool_exp!
  ): usageHistorySecret_mutation_response

  """
  delete single row from the table: "usageHistorySecret"
  """
  delete_usageHistorySecret_by_pk(id: uuid!): usageHistorySecret

  """
  delete single row from the table: "usageHistory"
  """
  delete_usageHistory_by_pk(id: uuid!): usageHistory

  """
  delete data from the table: "user"
  """
  delete_user(
    """filter the rows which have to be deleted"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete data from the table: "userEmailChangeCode"
  """
  delete_userEmailChangeCode(
    """filter the rows which have to be deleted"""
    where: userEmailChangeCode_bool_exp!
  ): userEmailChangeCode_mutation_response

  """
  delete single row from the table: "userEmailChangeCode"
  """
  delete_userEmailChangeCode_by_pk(id: uuid!): userEmailChangeCode

  """
  delete data from the table: "userSecret"
  """
  delete_userSecret(
    """filter the rows which have to be deleted"""
    where: userSecret_bool_exp!
  ): userSecret_mutation_response

  """
  delete data from the table: "userSecretField"
  """
  delete_userSecretField(
    """filter the rows which have to be deleted"""
    where: userSecretField_bool_exp!
  ): userSecretField_mutation_response

  """
  delete single row from the table: "userSecretField"
  """
  delete_userSecretField_by_pk(id: uuid!): userSecretField

  """
  delete single row from the table: "userSecret"
  """
  delete_userSecret_by_pk(id: uuid!): userSecret

  """
  delete data from the table: "userSubscription"
  """
  delete_userSubscription(
    """filter the rows which have to be deleted"""
    where: userSubscription_bool_exp!
  ): userSubscription_mutation_response

  """
  delete single row from the table: "userSubscription"
  """
  delete_userSubscription_by_pk(id: uuid!): userSubscription

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: uuid!): user

  """
  delete data from the table: "vendorEnum"
  """
  delete_vendorEnum(
    """filter the rows which have to be deleted"""
    where: vendorEnum_bool_exp!
  ): vendorEnum_mutation_response

  """
  delete single row from the table: "vendorEnum"
  """
  delete_vendorEnum_by_pk(value: String!): vendorEnum

  """
  delete data from the table: "verification"
  """
  delete_verification(
    """filter the rows which have to be deleted"""
    where: verification_bool_exp!
  ): verification_mutation_response

  """
  delete data from the table: "verificationTypeEnum"
  """
  delete_verificationTypeEnum(
    """filter the rows which have to be deleted"""
    where: verificationTypeEnum_bool_exp!
  ): verificationTypeEnum_mutation_response

  """
  delete single row from the table: "verificationTypeEnum"
  """
  delete_verificationTypeEnum_by_pk(value: String!): verificationTypeEnum

  """
  delete single row from the table: "verification"
  """
  delete_verification_by_pk(id: uuid!): verification
  emailVerify(object: EmailVerifyInput!): EmailVerifyOutput!

  """Share secrets by URL"""
  generateSecretSharingUrl(object: GenerateSecretSharingUrlInput!): GenerateSecretSharingUrlOutput!
  githubSignIn(object: GithubSignInInput!): GithubSignInOutput!
  googleSignIn(object: GoogleSignInInput!): GoogleSignInOutput!

  """
  insert data into the table: "cli"
  """
  insert_cli(
    """the rows to be inserted"""
    objects: [cli_insert_input!]!

    """upsert condition"""
    on_conflict: cli_on_conflict
  ): cli_mutation_response

  """
  insert a single row into the table: "cli"
  """
  insert_cli_one(
    """the row to be inserted"""
    object: cli_insert_input!

    """upsert condition"""
    on_conflict: cli_on_conflict
  ): cli

  """
  insert data into the table: "integration"
  """
  insert_integration(
    """the rows to be inserted"""
    objects: [integration_insert_input!]!

    """upsert condition"""
    on_conflict: integration_on_conflict
  ): integration_mutation_response

  """
  insert data into the table: "integrationInstallation"
  """
  insert_integrationInstallation(
    """the rows to be inserted"""
    objects: [integrationInstallation_insert_input!]!

    """upsert condition"""
    on_conflict: integrationInstallation_on_conflict
  ): integrationInstallation_mutation_response

  """
  insert data into the table: "integrationInstallationUserSecret"
  """
  insert_integrationInstallationUserSecret(
    """the rows to be inserted"""
    objects: [integrationInstallationUserSecret_insert_input!]!

    """upsert condition"""
    on_conflict: integrationInstallationUserSecret_on_conflict
  ): integrationInstallationUserSecret_mutation_response

  """
  insert a single row into the table: "integrationInstallationUserSecret"
  """
  insert_integrationInstallationUserSecret_one(
    """the row to be inserted"""
    object: integrationInstallationUserSecret_insert_input!

    """upsert condition"""
    on_conflict: integrationInstallationUserSecret_on_conflict
  ): integrationInstallationUserSecret

  """
  insert a single row into the table: "integrationInstallation"
  """
  insert_integrationInstallation_one(
    """the row to be inserted"""
    object: integrationInstallation_insert_input!

    """upsert condition"""
    on_conflict: integrationInstallation_on_conflict
  ): integrationInstallation

  """
  insert data into the table: "integrationVendorNameEnum"
  """
  insert_integrationVendorNameEnum(
    """the rows to be inserted"""
    objects: [integrationVendorNameEnum_insert_input!]!

    """upsert condition"""
    on_conflict: integrationVendorNameEnum_on_conflict
  ): integrationVendorNameEnum_mutation_response

  """
  insert a single row into the table: "integrationVendorNameEnum"
  """
  insert_integrationVendorNameEnum_one(
    """the row to be inserted"""
    object: integrationVendorNameEnum_insert_input!

    """upsert condition"""
    on_conflict: integrationVendorNameEnum_on_conflict
  ): integrationVendorNameEnum

  """
  insert a single row into the table: "integration"
  """
  insert_integration_one(
    """the row to be inserted"""
    object: integration_insert_input!

    """upsert condition"""
    on_conflict: integration_on_conflict
  ): integration

  """
  insert data into the table: "invitationStatusEnum"
  """
  insert_invitationStatusEnum(
    """the rows to be inserted"""
    objects: [invitationStatusEnum_insert_input!]!

    """upsert condition"""
    on_conflict: invitationStatusEnum_on_conflict
  ): invitationStatusEnum_mutation_response

  """
  insert a single row into the table: "invitationStatusEnum"
  """
  insert_invitationStatusEnum_one(
    """the row to be inserted"""
    object: invitationStatusEnum_insert_input!

    """upsert condition"""
    on_conflict: invitationStatusEnum_on_conflict
  ): invitationStatusEnum

  """
  insert data into the table: "notification"
  """
  insert_notification(
    """the rows to be inserted"""
    objects: [notification_insert_input!]!

    """upsert condition"""
    on_conflict: notification_on_conflict
  ): notification_mutation_response

  """
  insert data into the table: "notificationUser"
  """
  insert_notificationUser(
    """the rows to be inserted"""
    objects: [notificationUser_insert_input!]!

    """upsert condition"""
    on_conflict: notificationUser_on_conflict
  ): notificationUser_mutation_response

  """
  insert a single row into the table: "notificationUser"
  """
  insert_notificationUser_one(
    """the row to be inserted"""
    object: notificationUser_insert_input!

    """upsert condition"""
    on_conflict: notificationUser_on_conflict
  ): notificationUser

  """
  insert a single row into the table: "notification"
  """
  insert_notification_one(
    """the row to be inserted"""
    object: notification_insert_input!

    """upsert condition"""
    on_conflict: notification_on_conflict
  ): notification

  """
  insert data into the table: "registrationStep"
  """
  insert_registrationStep(
    """the rows to be inserted"""
    objects: [registrationStep_insert_input!]!

    """upsert condition"""
    on_conflict: registrationStep_on_conflict
  ): registrationStep_mutation_response

  """
  insert a single row into the table: "registrationStep"
  """
  insert_registrationStep_one(
    """the row to be inserted"""
    object: registrationStep_insert_input!

    """upsert condition"""
    on_conflict: registrationStep_on_conflict
  ): registrationStep

  """
  insert data into the table: "secretSharing"
  """
  insert_secretSharing(
    """the rows to be inserted"""
    objects: [secretSharing_insert_input!]!

    """upsert condition"""
    on_conflict: secretSharing_on_conflict
  ): secretSharing_mutation_response

  """
  insert a single row into the table: "secretSharing"
  """
  insert_secretSharing_one(
    """the row to be inserted"""
    object: secretSharing_insert_input!

    """upsert condition"""
    on_conflict: secretSharing_on_conflict
  ): secretSharing

  """
  insert data into the table: "subscriptionIntervalEnum"
  """
  insert_subscriptionIntervalEnum(
    """the rows to be inserted"""
    objects: [subscriptionIntervalEnum_insert_input!]!

    """upsert condition"""
    on_conflict: subscriptionIntervalEnum_on_conflict
  ): subscriptionIntervalEnum_mutation_response

  """
  insert a single row into the table: "subscriptionIntervalEnum"
  """
  insert_subscriptionIntervalEnum_one(
    """the row to be inserted"""
    object: subscriptionIntervalEnum_insert_input!

    """upsert condition"""
    on_conflict: subscriptionIntervalEnum_on_conflict
  ): subscriptionIntervalEnum

  """
  insert data into the table: "subscriptionPlanEnum"
  """
  insert_subscriptionPlanEnum(
    """the rows to be inserted"""
    objects: [subscriptionPlanEnum_insert_input!]!

    """upsert condition"""
    on_conflict: subscriptionPlanEnum_on_conflict
  ): subscriptionPlanEnum_mutation_response

  """
  insert a single row into the table: "subscriptionPlanEnum"
  """
  insert_subscriptionPlanEnum_one(
    """the row to be inserted"""
    object: subscriptionPlanEnum_insert_input!

    """upsert condition"""
    on_conflict: subscriptionPlanEnum_on_conflict
  ): subscriptionPlanEnum

  """
  insert data into the table: "tag"
  """
  insert_tag(
    """the rows to be inserted"""
    objects: [tag_insert_input!]!

    """upsert condition"""
    on_conflict: tag_on_conflict
  ): tag_mutation_response

  """
  insert a single row into the table: "tag"
  """
  insert_tag_one(
    """the row to be inserted"""
    object: tag_insert_input!

    """upsert condition"""
    on_conflict: tag_on_conflict
  ): tag

  """
  insert data into the table: "team"
  """
  insert_team(
    """the rows to be inserted"""
    objects: [team_insert_input!]!

    """upsert condition"""
    on_conflict: team_on_conflict
  ): team_mutation_response

  """
  insert data into the table: "teamInvitation"
  """
  insert_teamInvitation(
    """the rows to be inserted"""
    objects: [teamInvitation_insert_input!]!

    """upsert condition"""
    on_conflict: teamInvitation_on_conflict
  ): teamInvitation_mutation_response

  """
  insert a single row into the table: "teamInvitation"
  """
  insert_teamInvitation_one(
    """the row to be inserted"""
    object: teamInvitation_insert_input!

    """upsert condition"""
    on_conflict: teamInvitation_on_conflict
  ): teamInvitation

  """
  insert data into the table: "teamUser"
  """
  insert_teamUser(
    """the rows to be inserted"""
    objects: [teamUser_insert_input!]!

    """upsert condition"""
    on_conflict: teamUser_on_conflict
  ): teamUser_mutation_response

  """
  insert a single row into the table: "teamUser"
  """
  insert_teamUser_one(
    """the row to be inserted"""
    object: teamUser_insert_input!

    """upsert condition"""
    on_conflict: teamUser_on_conflict
  ): teamUser

  """
  insert a single row into the table: "team"
  """
  insert_team_one(
    """the row to be inserted"""
    object: team_insert_input!

    """upsert condition"""
    on_conflict: team_on_conflict
  ): team

  """
  insert data into the table: "token"
  """
  insert_token(
    """the rows to be inserted"""
    objects: [token_insert_input!]!

    """upsert condition"""
    on_conflict: token_on_conflict
  ): token_mutation_response

  """
  insert data into the table: "tokenTag"
  """
  insert_tokenTag(
    """the rows to be inserted"""
    objects: [tokenTag_insert_input!]!

    """upsert condition"""
    on_conflict: tokenTag_on_conflict
  ): tokenTag_mutation_response

  """
  insert a single row into the table: "tokenTag"
  """
  insert_tokenTag_one(
    """the row to be inserted"""
    object: tokenTag_insert_input!

    """upsert condition"""
    on_conflict: tokenTag_on_conflict
  ): tokenTag

  """
  insert data into the table: "tokenTeam"
  """
  insert_tokenTeam(
    """the rows to be inserted"""
    objects: [tokenTeam_insert_input!]!

    """upsert condition"""
    on_conflict: tokenTeam_on_conflict
  ): tokenTeam_mutation_response

  """
  insert a single row into the table: "tokenTeam"
  """
  insert_tokenTeam_one(
    """the row to be inserted"""
    object: tokenTeam_insert_input!

    """upsert condition"""
    on_conflict: tokenTeam_on_conflict
  ): tokenTeam

  """
  insert a single row into the table: "token"
  """
  insert_token_one(
    """the row to be inserted"""
    object: token_insert_input!

    """upsert condition"""
    on_conflict: token_on_conflict
  ): token

  """
  insert data into the table: "usageHistory"
  """
  insert_usageHistory(
    """the rows to be inserted"""
    objects: [usageHistory_insert_input!]!

    """upsert condition"""
    on_conflict: usageHistory_on_conflict
  ): usageHistory_mutation_response

  """
  insert data into the table: "usageHistorySecret"
  """
  insert_usageHistorySecret(
    """the rows to be inserted"""
    objects: [usageHistorySecret_insert_input!]!

    """upsert condition"""
    on_conflict: usageHistorySecret_on_conflict
  ): usageHistorySecret_mutation_response

  """
  insert a single row into the table: "usageHistorySecret"
  """
  insert_usageHistorySecret_one(
    """the row to be inserted"""
    object: usageHistorySecret_insert_input!

    """upsert condition"""
    on_conflict: usageHistorySecret_on_conflict
  ): usageHistorySecret

  """
  insert a single row into the table: "usageHistory"
  """
  insert_usageHistory_one(
    """the row to be inserted"""
    object: usageHistory_insert_input!

    """upsert condition"""
    on_conflict: usageHistory_on_conflict
  ): usageHistory

  """
  insert data into the table: "user"
  """
  insert_user(
    """the rows to be inserted"""
    objects: [user_insert_input!]!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert data into the table: "userEmailChangeCode"
  """
  insert_userEmailChangeCode(
    """the rows to be inserted"""
    objects: [userEmailChangeCode_insert_input!]!

    """upsert condition"""
    on_conflict: userEmailChangeCode_on_conflict
  ): userEmailChangeCode_mutation_response

  """
  insert a single row into the table: "userEmailChangeCode"
  """
  insert_userEmailChangeCode_one(
    """the row to be inserted"""
    object: userEmailChangeCode_insert_input!

    """upsert condition"""
    on_conflict: userEmailChangeCode_on_conflict
  ): userEmailChangeCode

  """
  insert data into the table: "userSecret"
  """
  insert_userSecret(
    """the rows to be inserted"""
    objects: [userSecret_insert_input!]!

    """upsert condition"""
    on_conflict: userSecret_on_conflict
  ): userSecret_mutation_response

  """
  insert data into the table: "userSecretField"
  """
  insert_userSecretField(
    """the rows to be inserted"""
    objects: [userSecretField_insert_input!]!

    """upsert condition"""
    on_conflict: userSecretField_on_conflict
  ): userSecretField_mutation_response

  """
  insert a single row into the table: "userSecretField"
  """
  insert_userSecretField_one(
    """the row to be inserted"""
    object: userSecretField_insert_input!

    """upsert condition"""
    on_conflict: userSecretField_on_conflict
  ): userSecretField

  """
  insert a single row into the table: "userSecret"
  """
  insert_userSecret_one(
    """the row to be inserted"""
    object: userSecret_insert_input!

    """upsert condition"""
    on_conflict: userSecret_on_conflict
  ): userSecret

  """
  insert data into the table: "userSubscription"
  """
  insert_userSubscription(
    """the rows to be inserted"""
    objects: [userSubscription_insert_input!]!

    """upsert condition"""
    on_conflict: userSubscription_on_conflict
  ): userSubscription_mutation_response

  """
  insert a single row into the table: "userSubscription"
  """
  insert_userSubscription_one(
    """the row to be inserted"""
    object: userSubscription_insert_input!

    """upsert condition"""
    on_conflict: userSubscription_on_conflict
  ): userSubscription

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """the row to be inserted"""
    object: user_insert_input!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user

  """
  insert data into the table: "vendorEnum"
  """
  insert_vendorEnum(
    """the rows to be inserted"""
    objects: [vendorEnum_insert_input!]!

    """upsert condition"""
    on_conflict: vendorEnum_on_conflict
  ): vendorEnum_mutation_response

  """
  insert a single row into the table: "vendorEnum"
  """
  insert_vendorEnum_one(
    """the row to be inserted"""
    object: vendorEnum_insert_input!

    """upsert condition"""
    on_conflict: vendorEnum_on_conflict
  ): vendorEnum

  """
  insert data into the table: "verification"
  """
  insert_verification(
    """the rows to be inserted"""
    objects: [verification_insert_input!]!

    """upsert condition"""
    on_conflict: verification_on_conflict
  ): verification_mutation_response

  """
  insert data into the table: "verificationTypeEnum"
  """
  insert_verificationTypeEnum(
    """the rows to be inserted"""
    objects: [verificationTypeEnum_insert_input!]!

    """upsert condition"""
    on_conflict: verificationTypeEnum_on_conflict
  ): verificationTypeEnum_mutation_response

  """
  insert a single row into the table: "verificationTypeEnum"
  """
  insert_verificationTypeEnum_one(
    """the row to be inserted"""
    object: verificationTypeEnum_insert_input!

    """upsert condition"""
    on_conflict: verificationTypeEnum_on_conflict
  ): verificationTypeEnum

  """
  insert a single row into the table: "verification"
  """
  insert_verification_one(
    """the row to be inserted"""
    object: verification_insert_input!

    """upsert condition"""
    on_conflict: verification_on_conflict
  ): verification
  integrationAWSInstall(zero: IntegrationAWSInstallInputZero!): IntegrationAWSInstallOutput!
  integrationAuth(integration: IntegrationAuthInputIntegration!, oauth: IntegrationAuthOAuthInput!, zero: IntegrationAuthInputZero!): IntegrationAuthOutput!
  integrationDelete(integration: IntegrationDeleteInput!): IntegrationDeleteOutput!
  integrationDownloadSecrets(integration: IntegrationDownloadSecretsInputIntegration!, zero: IntegrationDownloadSecretsInputZero!): IntegrationDownloadSecretsOutput!
  integrationInstall(integration: IntegrationInstallInputIntegration!, zero: IntegrationInstallInputZero!): IntegrationInstallOutput!
  integrationUpdate(integration: IntegrationUpdateInputIntegration!, zero: IntegrationUpdateInputZero!): IntegrationUpdateOutput!
  integrationUploadSecrets(integration: IntegrationUploadSecretsInputIntegration!, zero: IntegrationUploadSecretsInputZero!): IntegrationUploadSecretsOutput!
  recalculateTeamSeatsSubscription(object: RecalculateTeamSeatsSubscriptionInput!): RecalculateTeamSeatsSubscriptionOutput!
  refreshAccessToken(object: RefreshAccessTokenInput!): RefreshAccessTokenOutput!
  rejectTeamInvite(object: RejectTeamInviteInput!): RejectTeamInviteOutput!
  removePaidFeatures(object: RemovePaidFeaturesInput!): RemovePaidFeaturesOutput!
  removeTeam(object: RemoveTeamInput!): RemoveTeamOutput!
  removeUserFromTeam(object: RemoveUserFromTeamInput!): RemoveUserFromTeamOutput!
  requestEmailChange(object: RequestEmailChangeInput!): RequestEmailChangeOutput!
  requestResetPassword(object: RequestResetPasswordInput!): RequestResetPasswordOutput!
  resendSignUpEmail: ResendSignUpEmailOutput!
  resetPassword(object: ResetPasswordInput!): ResetPasswordOutput!

  """rotate new token for project"""
  rotateToken(object: RotateTokenInput!): RotateTokenOutput
  sendEmailToContactUs(object: SendEmailToContactUsInput!): SendEmailToContactUsOutput!
  sendInviteUserTeam(object: SendInviteUserTeamInput!): SendInviteUserTeamOutput!

  """Send notifications"""
  sendNotifications(objects: [SendNotificationInput!]!): uuid!
  signIn(object: SignInInput!): SignInOutput!
  signUp(object: SignUpInput!): SignUpOutput!
  updatePaymentMethod(object: UpdatePaymentMethodInput!): UpdatePaymentMethodOutput!
  updateProjectSettings(object: UpdateProjectSettingsInput!): UpdateProjectSettingsOutput!
  updateSecret(userSecret: UpdateUserSecretInput!, userSecretFields: [UpdateUserSecretFieldsInput!]!): UpdateSecretOutput!

  """
  update data of the table: "cli"
  """
  update_cli(
    """sets the columns of the filtered rows to the given values"""
    _set: cli_set_input

    """filter the rows which have to be updated"""
    where: cli_bool_exp!
  ): cli_mutation_response

  """
  update single row of the table: "cli"
  """
  update_cli_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: cli_set_input
    pk_columns: cli_pk_columns_input!
  ): cli

  """
  update multiples rows of table: "cli"
  """
  update_cli_many(
    """updates to execute, in order"""
    updates: [cli_updates!]!
  ): [cli_mutation_response]

  """
  update data of the table: "integration"
  """
  update_integration(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: integration_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: integration_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: integration_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: integration_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: integration_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: integration_set_input

    """filter the rows which have to be updated"""
    where: integration_bool_exp!
  ): integration_mutation_response

  """
  update data of the table: "integrationInstallation"
  """
  update_integrationInstallation(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: integrationInstallation_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: integrationInstallation_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: integrationInstallation_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: integrationInstallation_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: integrationInstallation_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: integrationInstallation_set_input

    """filter the rows which have to be updated"""
    where: integrationInstallation_bool_exp!
  ): integrationInstallation_mutation_response

  """
  update data of the table: "integrationInstallationUserSecret"
  """
  update_integrationInstallationUserSecret(
    """sets the columns of the filtered rows to the given values"""
    _set: integrationInstallationUserSecret_set_input

    """filter the rows which have to be updated"""
    where: integrationInstallationUserSecret_bool_exp!
  ): integrationInstallationUserSecret_mutation_response

  """
  update single row of the table: "integrationInstallationUserSecret"
  """
  update_integrationInstallationUserSecret_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: integrationInstallationUserSecret_set_input
    pk_columns: integrationInstallationUserSecret_pk_columns_input!
  ): integrationInstallationUserSecret

  """
  update multiples rows of table: "integrationInstallationUserSecret"
  """
  update_integrationInstallationUserSecret_many(
    """updates to execute, in order"""
    updates: [integrationInstallationUserSecret_updates!]!
  ): [integrationInstallationUserSecret_mutation_response]

  """
  update single row of the table: "integrationInstallation"
  """
  update_integrationInstallation_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: integrationInstallation_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: integrationInstallation_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: integrationInstallation_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: integrationInstallation_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: integrationInstallation_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: integrationInstallation_set_input
    pk_columns: integrationInstallation_pk_columns_input!
  ): integrationInstallation

  """
  update multiples rows of table: "integrationInstallation"
  """
  update_integrationInstallation_many(
    """updates to execute, in order"""
    updates: [integrationInstallation_updates!]!
  ): [integrationInstallation_mutation_response]

  """
  update data of the table: "integrationVendorNameEnum"
  """
  update_integrationVendorNameEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: integrationVendorNameEnum_set_input

    """filter the rows which have to be updated"""
    where: integrationVendorNameEnum_bool_exp!
  ): integrationVendorNameEnum_mutation_response

  """
  update single row of the table: "integrationVendorNameEnum"
  """
  update_integrationVendorNameEnum_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: integrationVendorNameEnum_set_input
    pk_columns: integrationVendorNameEnum_pk_columns_input!
  ): integrationVendorNameEnum

  """
  update multiples rows of table: "integrationVendorNameEnum"
  """
  update_integrationVendorNameEnum_many(
    """updates to execute, in order"""
    updates: [integrationVendorNameEnum_updates!]!
  ): [integrationVendorNameEnum_mutation_response]

  """
  update single row of the table: "integration"
  """
  update_integration_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: integration_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: integration_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: integration_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: integration_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: integration_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: integration_set_input
    pk_columns: integration_pk_columns_input!
  ): integration

  """
  update multiples rows of table: "integration"
  """
  update_integration_many(
    """updates to execute, in order"""
    updates: [integration_updates!]!
  ): [integration_mutation_response]

  """
  update data of the table: "invitationStatusEnum"
  """
  update_invitationStatusEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: invitationStatusEnum_set_input

    """filter the rows which have to be updated"""
    where: invitationStatusEnum_bool_exp!
  ): invitationStatusEnum_mutation_response

  """
  update single row of the table: "invitationStatusEnum"
  """
  update_invitationStatusEnum_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: invitationStatusEnum_set_input
    pk_columns: invitationStatusEnum_pk_columns_input!
  ): invitationStatusEnum

  """
  update multiples rows of table: "invitationStatusEnum"
  """
  update_invitationStatusEnum_many(
    """updates to execute, in order"""
    updates: [invitationStatusEnum_updates!]!
  ): [invitationStatusEnum_mutation_response]

  """
  update data of the table: "notification"
  """
  update_notification(
    """sets the columns of the filtered rows to the given values"""
    _set: notification_set_input

    """filter the rows which have to be updated"""
    where: notification_bool_exp!
  ): notification_mutation_response

  """
  update data of the table: "notificationUser"
  """
  update_notificationUser(
    """sets the columns of the filtered rows to the given values"""
    _set: notificationUser_set_input

    """filter the rows which have to be updated"""
    where: notificationUser_bool_exp!
  ): notificationUser_mutation_response

  """
  update single row of the table: "notificationUser"
  """
  update_notificationUser_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notificationUser_set_input
    pk_columns: notificationUser_pk_columns_input!
  ): notificationUser

  """
  update multiples rows of table: "notificationUser"
  """
  update_notificationUser_many(
    """updates to execute, in order"""
    updates: [notificationUser_updates!]!
  ): [notificationUser_mutation_response]

  """
  update single row of the table: "notification"
  """
  update_notification_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notification_set_input
    pk_columns: notification_pk_columns_input!
  ): notification

  """
  update multiples rows of table: "notification"
  """
  update_notification_many(
    """updates to execute, in order"""
    updates: [notification_updates!]!
  ): [notification_mutation_response]

  """
  update data of the table: "registrationStep"
  """
  update_registrationStep(
    """sets the columns of the filtered rows to the given values"""
    _set: registrationStep_set_input

    """filter the rows which have to be updated"""
    where: registrationStep_bool_exp!
  ): registrationStep_mutation_response

  """
  update single row of the table: "registrationStep"
  """
  update_registrationStep_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: registrationStep_set_input
    pk_columns: registrationStep_pk_columns_input!
  ): registrationStep

  """
  update multiples rows of table: "registrationStep"
  """
  update_registrationStep_many(
    """updates to execute, in order"""
    updates: [registrationStep_updates!]!
  ): [registrationStep_mutation_response]

  """
  update data of the table: "secretSharing"
  """
  update_secretSharing(
    """sets the columns of the filtered rows to the given values"""
    _set: secretSharing_set_input

    """filter the rows which have to be updated"""
    where: secretSharing_bool_exp!
  ): secretSharing_mutation_response

  """
  update single row of the table: "secretSharing"
  """
  update_secretSharing_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: secretSharing_set_input
    pk_columns: secretSharing_pk_columns_input!
  ): secretSharing

  """
  update multiples rows of table: "secretSharing"
  """
  update_secretSharing_many(
    """updates to execute, in order"""
    updates: [secretSharing_updates!]!
  ): [secretSharing_mutation_response]

  """
  update data of the table: "subscriptionIntervalEnum"
  """
  update_subscriptionIntervalEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: subscriptionIntervalEnum_set_input

    """filter the rows which have to be updated"""
    where: subscriptionIntervalEnum_bool_exp!
  ): subscriptionIntervalEnum_mutation_response

  """
  update single row of the table: "subscriptionIntervalEnum"
  """
  update_subscriptionIntervalEnum_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: subscriptionIntervalEnum_set_input
    pk_columns: subscriptionIntervalEnum_pk_columns_input!
  ): subscriptionIntervalEnum

  """
  update multiples rows of table: "subscriptionIntervalEnum"
  """
  update_subscriptionIntervalEnum_many(
    """updates to execute, in order"""
    updates: [subscriptionIntervalEnum_updates!]!
  ): [subscriptionIntervalEnum_mutation_response]

  """
  update data of the table: "subscriptionPlanEnum"
  """
  update_subscriptionPlanEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: subscriptionPlanEnum_set_input

    """filter the rows which have to be updated"""
    where: subscriptionPlanEnum_bool_exp!
  ): subscriptionPlanEnum_mutation_response

  """
  update single row of the table: "subscriptionPlanEnum"
  """
  update_subscriptionPlanEnum_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: subscriptionPlanEnum_set_input
    pk_columns: subscriptionPlanEnum_pk_columns_input!
  ): subscriptionPlanEnum

  """
  update multiples rows of table: "subscriptionPlanEnum"
  """
  update_subscriptionPlanEnum_many(
    """updates to execute, in order"""
    updates: [subscriptionPlanEnum_updates!]!
  ): [subscriptionPlanEnum_mutation_response]

  """
  update data of the table: "tag"
  """
  update_tag(
    """sets the columns of the filtered rows to the given values"""
    _set: tag_set_input

    """filter the rows which have to be updated"""
    where: tag_bool_exp!
  ): tag_mutation_response

  """
  update single row of the table: "tag"
  """
  update_tag_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: tag_set_input
    pk_columns: tag_pk_columns_input!
  ): tag

  """
  update multiples rows of table: "tag"
  """
  update_tag_many(
    """updates to execute, in order"""
    updates: [tag_updates!]!
  ): [tag_mutation_response]

  """
  update data of the table: "team"
  """
  update_team(
    """sets the columns of the filtered rows to the given values"""
    _set: team_set_input

    """filter the rows which have to be updated"""
    where: team_bool_exp!
  ): team_mutation_response

  """
  update data of the table: "teamInvitation"
  """
  update_teamInvitation(
    """sets the columns of the filtered rows to the given values"""
    _set: teamInvitation_set_input

    """filter the rows which have to be updated"""
    where: teamInvitation_bool_exp!
  ): teamInvitation_mutation_response

  """
  update single row of the table: "teamInvitation"
  """
  update_teamInvitation_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: teamInvitation_set_input
    pk_columns: teamInvitation_pk_columns_input!
  ): teamInvitation

  """
  update multiples rows of table: "teamInvitation"
  """
  update_teamInvitation_many(
    """updates to execute, in order"""
    updates: [teamInvitation_updates!]!
  ): [teamInvitation_mutation_response]

  """
  update data of the table: "teamUser"
  """
  update_teamUser(
    """sets the columns of the filtered rows to the given values"""
    _set: teamUser_set_input

    """filter the rows which have to be updated"""
    where: teamUser_bool_exp!
  ): teamUser_mutation_response

  """
  update single row of the table: "teamUser"
  """
  update_teamUser_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: teamUser_set_input
    pk_columns: teamUser_pk_columns_input!
  ): teamUser

  """
  update multiples rows of table: "teamUser"
  """
  update_teamUser_many(
    """updates to execute, in order"""
    updates: [teamUser_updates!]!
  ): [teamUser_mutation_response]

  """
  update single row of the table: "team"
  """
  update_team_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: team_set_input
    pk_columns: team_pk_columns_input!
  ): team

  """
  update multiples rows of table: "team"
  """
  update_team_many(
    """updates to execute, in order"""
    updates: [team_updates!]!
  ): [team_mutation_response]

  """
  update data of the table: "token"
  """
  update_token(
    """sets the columns of the filtered rows to the given values"""
    _set: token_set_input

    """filter the rows which have to be updated"""
    where: token_bool_exp!
  ): token_mutation_response

  """
  update data of the table: "tokenTag"
  """
  update_tokenTag(
    """sets the columns of the filtered rows to the given values"""
    _set: tokenTag_set_input

    """filter the rows which have to be updated"""
    where: tokenTag_bool_exp!
  ): tokenTag_mutation_response

  """
  update single row of the table: "tokenTag"
  """
  update_tokenTag_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: tokenTag_set_input
    pk_columns: tokenTag_pk_columns_input!
  ): tokenTag

  """
  update multiples rows of table: "tokenTag"
  """
  update_tokenTag_many(
    """updates to execute, in order"""
    updates: [tokenTag_updates!]!
  ): [tokenTag_mutation_response]

  """
  update data of the table: "tokenTeam"
  """
  update_tokenTeam(
    """sets the columns of the filtered rows to the given values"""
    _set: tokenTeam_set_input

    """filter the rows which have to be updated"""
    where: tokenTeam_bool_exp!
  ): tokenTeam_mutation_response

  """
  update single row of the table: "tokenTeam"
  """
  update_tokenTeam_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: tokenTeam_set_input
    pk_columns: tokenTeam_pk_columns_input!
  ): tokenTeam

  """
  update multiples rows of table: "tokenTeam"
  """
  update_tokenTeam_many(
    """updates to execute, in order"""
    updates: [tokenTeam_updates!]!
  ): [tokenTeam_mutation_response]

  """
  update single row of the table: "token"
  """
  update_token_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: token_set_input
    pk_columns: token_pk_columns_input!
  ): token

  """
  update multiples rows of table: "token"
  """
  update_token_many(
    """updates to execute, in order"""
    updates: [token_updates!]!
  ): [token_mutation_response]

  """
  update data of the table: "usageHistory"
  """
  update_usageHistory(
    """sets the columns of the filtered rows to the given values"""
    _set: usageHistory_set_input

    """filter the rows which have to be updated"""
    where: usageHistory_bool_exp!
  ): usageHistory_mutation_response

  """
  update data of the table: "usageHistorySecret"
  """
  update_usageHistorySecret(
    """sets the columns of the filtered rows to the given values"""
    _set: usageHistorySecret_set_input

    """filter the rows which have to be updated"""
    where: usageHistorySecret_bool_exp!
  ): usageHistorySecret_mutation_response

  """
  update single row of the table: "usageHistorySecret"
  """
  update_usageHistorySecret_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: usageHistorySecret_set_input
    pk_columns: usageHistorySecret_pk_columns_input!
  ): usageHistorySecret

  """
  update multiples rows of table: "usageHistorySecret"
  """
  update_usageHistorySecret_many(
    """updates to execute, in order"""
    updates: [usageHistorySecret_updates!]!
  ): [usageHistorySecret_mutation_response]

  """
  update single row of the table: "usageHistory"
  """
  update_usageHistory_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: usageHistory_set_input
    pk_columns: usageHistory_pk_columns_input!
  ): usageHistory

  """
  update multiples rows of table: "usageHistory"
  """
  update_usageHistory_many(
    """updates to execute, in order"""
    updates: [usageHistory_updates!]!
  ): [usageHistory_mutation_response]

  """
  update data of the table: "user"
  """
  update_user(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update data of the table: "userEmailChangeCode"
  """
  update_userEmailChangeCode(
    """sets the columns of the filtered rows to the given values"""
    _set: userEmailChangeCode_set_input

    """filter the rows which have to be updated"""
    where: userEmailChangeCode_bool_exp!
  ): userEmailChangeCode_mutation_response

  """
  update single row of the table: "userEmailChangeCode"
  """
  update_userEmailChangeCode_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: userEmailChangeCode_set_input
    pk_columns: userEmailChangeCode_pk_columns_input!
  ): userEmailChangeCode

  """
  update multiples rows of table: "userEmailChangeCode"
  """
  update_userEmailChangeCode_many(
    """updates to execute, in order"""
    updates: [userEmailChangeCode_updates!]!
  ): [userEmailChangeCode_mutation_response]

  """
  update data of the table: "userSecret"
  """
  update_userSecret(
    """sets the columns of the filtered rows to the given values"""
    _set: userSecret_set_input

    """filter the rows which have to be updated"""
    where: userSecret_bool_exp!
  ): userSecret_mutation_response

  """
  update data of the table: "userSecretField"
  """
  update_userSecretField(
    """sets the columns of the filtered rows to the given values"""
    _set: userSecretField_set_input

    """filter the rows which have to be updated"""
    where: userSecretField_bool_exp!
  ): userSecretField_mutation_response

  """
  update single row of the table: "userSecretField"
  """
  update_userSecretField_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: userSecretField_set_input
    pk_columns: userSecretField_pk_columns_input!
  ): userSecretField

  """
  update multiples rows of table: "userSecretField"
  """
  update_userSecretField_many(
    """updates to execute, in order"""
    updates: [userSecretField_updates!]!
  ): [userSecretField_mutation_response]

  """
  update single row of the table: "userSecret"
  """
  update_userSecret_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: userSecret_set_input
    pk_columns: userSecret_pk_columns_input!
  ): userSecret

  """
  update multiples rows of table: "userSecret"
  """
  update_userSecret_many(
    """updates to execute, in order"""
    updates: [userSecret_updates!]!
  ): [userSecret_mutation_response]

  """
  update data of the table: "userSubscription"
  """
  update_userSubscription(
    """increments the numeric columns with given value of the filtered values"""
    _inc: userSubscription_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: userSubscription_set_input

    """filter the rows which have to be updated"""
    where: userSubscription_bool_exp!
  ): userSubscription_mutation_response

  """
  update single row of the table: "userSubscription"
  """
  update_userSubscription_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: userSubscription_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: userSubscription_set_input
    pk_columns: userSubscription_pk_columns_input!
  ): userSubscription

  """
  update multiples rows of table: "userSubscription"
  """
  update_userSubscription_many(
    """updates to execute, in order"""
    updates: [userSubscription_updates!]!
  ): [userSubscription_mutation_response]

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  update multiples rows of table: "user"
  """
  update_user_many(
    """updates to execute, in order"""
    updates: [user_updates!]!
  ): [user_mutation_response]

  """
  update data of the table: "vendorEnum"
  """
  update_vendorEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: vendorEnum_set_input

    """filter the rows which have to be updated"""
    where: vendorEnum_bool_exp!
  ): vendorEnum_mutation_response

  """
  update single row of the table: "vendorEnum"
  """
  update_vendorEnum_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: vendorEnum_set_input
    pk_columns: vendorEnum_pk_columns_input!
  ): vendorEnum

  """
  update multiples rows of table: "vendorEnum"
  """
  update_vendorEnum_many(
    """updates to execute, in order"""
    updates: [vendorEnum_updates!]!
  ): [vendorEnum_mutation_response]

  """
  update data of the table: "verification"
  """
  update_verification(
    """sets the columns of the filtered rows to the given values"""
    _set: verification_set_input

    """filter the rows which have to be updated"""
    where: verification_bool_exp!
  ): verification_mutation_response

  """
  update data of the table: "verificationTypeEnum"
  """
  update_verificationTypeEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: verificationTypeEnum_set_input

    """filter the rows which have to be updated"""
    where: verificationTypeEnum_bool_exp!
  ): verificationTypeEnum_mutation_response

  """
  update single row of the table: "verificationTypeEnum"
  """
  update_verificationTypeEnum_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: verificationTypeEnum_set_input
    pk_columns: verificationTypeEnum_pk_columns_input!
  ): verificationTypeEnum

  """
  update multiples rows of table: "verificationTypeEnum"
  """
  update_verificationTypeEnum_many(
    """updates to execute, in order"""
    updates: [verificationTypeEnum_updates!]!
  ): [verificationTypeEnum_mutation_response]

  """
  update single row of the table: "verification"
  """
  update_verification_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: verification_set_input
    pk_columns: verification_pk_columns_input!
  ): verification

  """
  update multiples rows of table: "verification"
  """
  update_verification_many(
    """updates to execute, in order"""
    updates: [verification_updates!]!
  ): [verification_mutation_response]
}

"""
columns and relationships of "notification"
"""
type notification {
  createdAt: timestamp!
  id: uuid!
  isViewed: Boolean!
  message: String!
  updatedAt: timestamp!

  """An object relationship"""
  user: user!
  userId: uuid!

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): notificationUser_aggregate!
}

"""
columns and relationships of "notificationUser"
"""
type notificationUser {
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  notification: notification!
  notificationId: uuid!
  updatedAt: timestamptz!

  """An object relationship"""
  user: user!
  userId: uuid!
}

"""
aggregated selection of "notificationUser"
"""
type notificationUser_aggregate {
  aggregate: notificationUser_aggregate_fields
  nodes: [notificationUser!]!
}

input notificationUser_aggregate_bool_exp {
  count: notificationUser_aggregate_bool_exp_count
}

input notificationUser_aggregate_bool_exp_count {
  arguments: [notificationUser_select_column!]
  distinct: Boolean
  filter: notificationUser_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "notificationUser"
"""
type notificationUser_aggregate_fields {
  count(columns: [notificationUser_select_column!], distinct: Boolean): Int!
  max: notificationUser_max_fields
  min: notificationUser_min_fields
}

"""
order by aggregate values of table "notificationUser"
"""
input notificationUser_aggregate_order_by {
  count: order_by
  max: notificationUser_max_order_by
  min: notificationUser_min_order_by
}

"""
input type for inserting array relation for remote table "notificationUser"
"""
input notificationUser_arr_rel_insert_input {
  data: [notificationUser_insert_input!]!

  """upsert condition"""
  on_conflict: notificationUser_on_conflict
}

"""
Boolean expression to filter rows from the table "notificationUser". All fields are combined with a logical 'AND'.
"""
input notificationUser_bool_exp {
  _and: [notificationUser_bool_exp!]
  _not: notificationUser_bool_exp
  _or: [notificationUser_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  notification: notification_bool_exp
  notificationId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: user_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "notificationUser"
"""
enum notificationUser_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notificationUser_pkey
}

"""
input type for inserting data into table "notificationUser"
"""
input notificationUser_insert_input {
  createdAt: timestamptz
  id: uuid
  notification: notification_obj_rel_insert_input
  notificationId: uuid
  updatedAt: timestamptz
  user: user_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type notificationUser_max_fields {
  createdAt: timestamptz
  id: uuid
  notificationId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "notificationUser"
"""
input notificationUser_max_order_by {
  createdAt: order_by
  id: order_by
  notificationId: order_by
  updatedAt: order_by
  userId: order_by
}

"""aggregate min on columns"""
type notificationUser_min_fields {
  createdAt: timestamptz
  id: uuid
  notificationId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "notificationUser"
"""
input notificationUser_min_order_by {
  createdAt: order_by
  id: order_by
  notificationId: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "notificationUser"
"""
type notificationUser_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notificationUser!]!
}

"""
on_conflict condition type for table "notificationUser"
"""
input notificationUser_on_conflict {
  constraint: notificationUser_constraint!
  update_columns: [notificationUser_update_column!]! = []
  where: notificationUser_bool_exp
}

"""Ordering options when selecting data from "notificationUser"."""
input notificationUser_order_by {
  createdAt: order_by
  id: order_by
  notification: notification_order_by
  notificationId: order_by
  updatedAt: order_by
  user: user_order_by
  userId: order_by
}

"""primary key columns input for table: notificationUser"""
input notificationUser_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notificationUser"
"""
enum notificationUser_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  notificationId

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "notificationUser"
"""
input notificationUser_set_input {
  createdAt: timestamptz
  id: uuid
  notificationId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "notificationUser"
"""
input notificationUser_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notificationUser_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notificationUser_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  notificationId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "notificationUser"
"""
enum notificationUser_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  notificationId

  """column name"""
  updatedAt

  """column name"""
  userId
}

input notificationUser_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notificationUser_set_input

  """filter the rows which have to be updated"""
  where: notificationUser_bool_exp!
}

"""
aggregated selection of "notification"
"""
type notification_aggregate {
  aggregate: notification_aggregate_fields
  nodes: [notification!]!
}

"""
aggregate fields of "notification"
"""
type notification_aggregate_fields {
  count(columns: [notification_select_column!], distinct: Boolean): Int!
  max: notification_max_fields
  min: notification_min_fields
}

"""
Boolean expression to filter rows from the table "notification". All fields are combined with a logical 'AND'.
"""
input notification_bool_exp {
  _and: [notification_bool_exp!]
  _not: notification_bool_exp
  _or: [notification_bool_exp!]
  createdAt: timestamp_comparison_exp
  id: uuid_comparison_exp
  isViewed: Boolean_comparison_exp
  message: String_comparison_exp
  updatedAt: timestamp_comparison_exp
  user: user_bool_exp
  userId: uuid_comparison_exp
  users: notificationUser_bool_exp
  users_aggregate: notificationUser_aggregate_bool_exp
}

"""
unique or primary key constraints on table "notification"
"""
enum notification_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notification_pkey
}

"""
input type for inserting data into table "notification"
"""
input notification_insert_input {
  createdAt: timestamp
  id: uuid
  isViewed: Boolean
  message: String
  updatedAt: timestamp
  user: user_obj_rel_insert_input
  userId: uuid
  users: notificationUser_arr_rel_insert_input
}

"""aggregate max on columns"""
type notification_max_fields {
  createdAt: timestamp
  id: uuid
  message: String
  updatedAt: timestamp
  userId: uuid
}

"""aggregate min on columns"""
type notification_min_fields {
  createdAt: timestamp
  id: uuid
  message: String
  updatedAt: timestamp
  userId: uuid
}

"""
response of any mutation on the table "notification"
"""
type notification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notification!]!
}

"""
input type for inserting object relation for remote table "notification"
"""
input notification_obj_rel_insert_input {
  data: notification_insert_input!

  """upsert condition"""
  on_conflict: notification_on_conflict
}

"""
on_conflict condition type for table "notification"
"""
input notification_on_conflict {
  constraint: notification_constraint!
  update_columns: [notification_update_column!]! = []
  where: notification_bool_exp
}

"""Ordering options when selecting data from "notification"."""
input notification_order_by {
  createdAt: order_by
  id: order_by
  isViewed: order_by
  message: order_by
  updatedAt: order_by
  user: user_order_by
  userId: order_by
  users_aggregate: notificationUser_aggregate_order_by
}

"""primary key columns input for table: notification"""
input notification_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notification"
"""
enum notification_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isViewed

  """column name"""
  message

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "notification"
"""
input notification_set_input {
  createdAt: timestamp
  id: uuid
  isViewed: Boolean
  message: String
  updatedAt: timestamp
  userId: uuid
}

"""
Streaming cursor of the table "notification"
"""
input notification_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notification_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notification_stream_cursor_value_input {
  createdAt: timestamp
  id: uuid
  isViewed: Boolean
  message: String
  updatedAt: timestamp
  userId: uuid
}

"""
update columns of table "notification"
"""
enum notification_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isViewed

  """column name"""
  message

  """column name"""
  updatedAt

  """column name"""
  userId
}

input notification_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notification_set_input

  """filter the rows which have to be updated"""
  where: notification_bool_exp!
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type query_root {
  IntegrationProjects(where: IntegrationProjectsInput!): IntegrationProjectsOutput!
  _emptyQuery: String
  checkIntegrationDeploy(integration: CheckIntegrationDeployInput!): CheckIntegrationDeployOutput!
  checkPaymentMethod(where: CheckPaymentMethodInput!): CheckPaymentMethodOutput!
  checkUserEmailExist(object: CheckUserEmailExistInput!): CheckUserEmailExistOutput!

  """
  fetch data from the table: "cli"
  """
  cli(
    """distinct select on columns"""
    distinct_on: [cli_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cli_order_by!]

    """filter the rows returned"""
    where: cli_bool_exp
  ): [cli!]!

  """
  fetch aggregated fields from the table: "cli"
  """
  cli_aggregate(
    """distinct select on columns"""
    distinct_on: [cli_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cli_order_by!]

    """filter the rows returned"""
    where: cli_bool_exp
  ): cli_aggregate!

  """fetch data from the table: "cli" using primary key columns"""
  cli_by_pk(id: uuid!): cli
  currentPlan(where: CurrentPlanInput!): CurrentPlanOutput!

  """
  fetch data from the table: "integration"
  """
  integration(
    """distinct select on columns"""
    distinct_on: [integration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integration_order_by!]

    """filter the rows returned"""
    where: integration_bool_exp
  ): [integration!]!

  """
  fetch data from the table: "integrationInstallation"
  """
  integrationInstallation(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): [integrationInstallation!]!

  """
  fetch data from the table: "integrationInstallationUserSecret"
  """
  integrationInstallationUserSecret(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): [integrationInstallationUserSecret!]!

  """
  fetch aggregated fields from the table: "integrationInstallationUserSecret"
  """
  integrationInstallationUserSecret_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): integrationInstallationUserSecret_aggregate!

  """
  fetch data from the table: "integrationInstallationUserSecret" using primary key columns
  """
  integrationInstallationUserSecret_by_pk(id: uuid!): integrationInstallationUserSecret

  """
  fetch aggregated fields from the table: "integrationInstallation"
  """
  integrationInstallation_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): integrationInstallation_aggregate!

  """
  fetch data from the table: "integrationInstallation" using primary key columns
  """
  integrationInstallation_by_pk(id: uuid!): integrationInstallation

  """
  fetch data from the table: "integrationVendorNameEnum"
  """
  integrationVendorNameEnum(
    """distinct select on columns"""
    distinct_on: [integrationVendorNameEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationVendorNameEnum_order_by!]

    """filter the rows returned"""
    where: integrationVendorNameEnum_bool_exp
  ): [integrationVendorNameEnum!]!

  """
  fetch aggregated fields from the table: "integrationVendorNameEnum"
  """
  integrationVendorNameEnum_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationVendorNameEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationVendorNameEnum_order_by!]

    """filter the rows returned"""
    where: integrationVendorNameEnum_bool_exp
  ): integrationVendorNameEnum_aggregate!

  """
  fetch data from the table: "integrationVendorNameEnum" using primary key columns
  """
  integrationVendorNameEnum_by_pk(value: String!): integrationVendorNameEnum

  """
  fetch aggregated fields from the table: "integration"
  """
  integration_aggregate(
    """distinct select on columns"""
    distinct_on: [integration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integration_order_by!]

    """filter the rows returned"""
    where: integration_bool_exp
  ): integration_aggregate!

  """fetch data from the table: "integration" using primary key columns"""
  integration_by_pk(id: uuid!): integration

  """
  fetch data from the table: "invitationStatusEnum"
  """
  invitationStatusEnum(
    """distinct select on columns"""
    distinct_on: [invitationStatusEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitationStatusEnum_order_by!]

    """filter the rows returned"""
    where: invitationStatusEnum_bool_exp
  ): [invitationStatusEnum!]!

  """
  fetch aggregated fields from the table: "invitationStatusEnum"
  """
  invitationStatusEnum_aggregate(
    """distinct select on columns"""
    distinct_on: [invitationStatusEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitationStatusEnum_order_by!]

    """filter the rows returned"""
    where: invitationStatusEnum_bool_exp
  ): invitationStatusEnum_aggregate!

  """
  fetch data from the table: "invitationStatusEnum" using primary key columns
  """
  invitationStatusEnum_by_pk(value: String!): invitationStatusEnum
  me: MeOutput!

  """
  fetch data from the table: "notification"
  """
  notification(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """
  fetch data from the table: "notificationUser"
  """
  notificationUser(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!

  """
  fetch aggregated fields from the table: "notificationUser"
  """
  notificationUser_aggregate(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): notificationUser_aggregate!

  """
  fetch data from the table: "notificationUser" using primary key columns
  """
  notificationUser_by_pk(id: uuid!): notificationUser

  """
  fetch aggregated fields from the table: "notification"
  """
  notification_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): notification_aggregate!

  """fetch data from the table: "notification" using primary key columns"""
  notification_by_pk(id: uuid!): notification
  paymentList(where: PaymentListInput!): PaymentListOutput!

  """
  fetch data from the table: "registrationStep"
  """
  registrationStep(
    """distinct select on columns"""
    distinct_on: [registrationStep_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [registrationStep_order_by!]

    """filter the rows returned"""
    where: registrationStep_bool_exp
  ): [registrationStep!]!

  """
  fetch aggregated fields from the table: "registrationStep"
  """
  registrationStep_aggregate(
    """distinct select on columns"""
    distinct_on: [registrationStep_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [registrationStep_order_by!]

    """filter the rows returned"""
    where: registrationStep_bool_exp
  ): registrationStep_aggregate!

  """
  fetch data from the table: "registrationStep" using primary key columns
  """
  registrationStep_by_pk(value: String!): registrationStep

  """
  execute function "search_project_by_id" which returns "token"
  """
  search_project_by_id(
    """
    input parameters for function "search_project_by_id"
    """
    args: search_project_by_id_args!

    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  execute function "search_project_by_id" and query aggregates on result of table type "token"
  """
  search_project_by_id_aggregate(
    """
    input parameters for function "search_project_by_id_aggregate"
    """
    args: search_project_by_id_args!

    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """
  execute function "search_team_by_id" which returns "team"
  """
  search_team_by_id(
    """
    input parameters for function "search_team_by_id"
    """
    args: search_team_by_id_args!

    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """
  execute function "search_team_by_id" and query aggregates on result of table type "team"
  """
  search_team_by_id_aggregate(
    """
    input parameters for function "search_team_by_id_aggregate"
    """
    args: search_team_by_id_args!

    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): team_aggregate!

  """
  execute function "search_usage_history_by_id" which returns "usageHistory"
  """
  search_usage_history_by_id(
    """
    input parameters for function "search_usage_history_by_id"
    """
    args: search_usage_history_by_id_args!

    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """
  execute function "search_usage_history_by_id" and query aggregates on result of table type "usageHistory"
  """
  search_usage_history_by_id_aggregate(
    """
    input parameters for function "search_usage_history_by_id_aggregate"
    """
    args: search_usage_history_by_id_args!

    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): usageHistory_aggregate!

  """
  execute function "search_user_by_id" which returns "user"
  """
  search_user_by_id(
    """
    input parameters for function "search_user_by_id"
    """
    args: search_user_by_id_args!

    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  execute function "search_user_by_id" and query aggregates on result of table type "user"
  """
  search_user_by_id_aggregate(
    """
    input parameters for function "search_user_by_id_aggregate"
    """
    args: search_user_by_id_args!

    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """
  execute function "search_user_secret_by_id" which returns "userSecret"
  """
  search_user_secret_by_id(
    """
    input parameters for function "search_user_secret_by_id"
    """
    args: search_user_secret_by_id_args!

    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """
  execute function "search_user_secret_by_id" and query aggregates on result of table type "userSecret"
  """
  search_user_secret_by_id_aggregate(
    """
    input parameters for function "search_user_secret_by_id_aggregate"
    """
    args: search_user_secret_by_id_args!

    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): userSecret_aggregate!

  """
  fetch data from the table: "secretSharing"
  """
  secretSharing(
    """distinct select on columns"""
    distinct_on: [secretSharing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [secretSharing_order_by!]

    """filter the rows returned"""
    where: secretSharing_bool_exp
  ): [secretSharing!]!

  """
  fetch aggregated fields from the table: "secretSharing"
  """
  secretSharing_aggregate(
    """distinct select on columns"""
    distinct_on: [secretSharing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [secretSharing_order_by!]

    """filter the rows returned"""
    where: secretSharing_bool_exp
  ): secretSharing_aggregate!

  """fetch data from the table: "secretSharing" using primary key columns"""
  secretSharing_by_pk(id: uuid!): secretSharing

  """Send notifications"""
  sendNotifications(
    """the unique id of an action"""
    id: uuid!
  ): sendNotifications

  """
  fetch data from the table: "subscriptionIntervalEnum"
  """
  subscriptionIntervalEnum(
    """distinct select on columns"""
    distinct_on: [subscriptionIntervalEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptionIntervalEnum_order_by!]

    """filter the rows returned"""
    where: subscriptionIntervalEnum_bool_exp
  ): [subscriptionIntervalEnum!]!

  """
  fetch aggregated fields from the table: "subscriptionIntervalEnum"
  """
  subscriptionIntervalEnum_aggregate(
    """distinct select on columns"""
    distinct_on: [subscriptionIntervalEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptionIntervalEnum_order_by!]

    """filter the rows returned"""
    where: subscriptionIntervalEnum_bool_exp
  ): subscriptionIntervalEnum_aggregate!

  """
  fetch data from the table: "subscriptionIntervalEnum" using primary key columns
  """
  subscriptionIntervalEnum_by_pk(value: String!): subscriptionIntervalEnum

  """
  fetch data from the table: "subscriptionPlanEnum"
  """
  subscriptionPlanEnum(
    """distinct select on columns"""
    distinct_on: [subscriptionPlanEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptionPlanEnum_order_by!]

    """filter the rows returned"""
    where: subscriptionPlanEnum_bool_exp
  ): [subscriptionPlanEnum!]!

  """
  fetch aggregated fields from the table: "subscriptionPlanEnum"
  """
  subscriptionPlanEnum_aggregate(
    """distinct select on columns"""
    distinct_on: [subscriptionPlanEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptionPlanEnum_order_by!]

    """filter the rows returned"""
    where: subscriptionPlanEnum_bool_exp
  ): subscriptionPlanEnum_aggregate!

  """
  fetch data from the table: "subscriptionPlanEnum" using primary key columns
  """
  subscriptionPlanEnum_by_pk(value: String!): subscriptionPlanEnum

  """
  fetch data from the table: "tag"
  """
  tag(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """
  fetch aggregated fields from the table: "tag"
  """
  tag_aggregate(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): tag_aggregate!

  """fetch data from the table: "tag" using primary key columns"""
  tag_by_pk(id: uuid!): tag

  """
  fetch data from the table: "team"
  """
  team(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """
  fetch data from the table: "teamInvitation"
  """
  teamInvitation(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!

  """
  fetch aggregated fields from the table: "teamInvitation"
  """
  teamInvitation_aggregate(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): teamInvitation_aggregate!

  """fetch data from the table: "teamInvitation" using primary key columns"""
  teamInvitation_by_pk(id: uuid!): teamInvitation

  """
  fetch data from the table: "teamUser"
  """
  teamUser(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """
  fetch aggregated fields from the table: "teamUser"
  """
  teamUser_aggregate(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!

  """fetch data from the table: "teamUser" using primary key columns"""
  teamUser_by_pk(id: uuid!): teamUser

  """
  fetch aggregated fields from the table: "team"
  """
  team_aggregate(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): team_aggregate!

  """fetch data from the table: "team" using primary key columns"""
  team_by_pk(id: uuid!): team

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  fetch data from the table: "tokenTag"
  """
  tokenTag(
    """distinct select on columns"""
    distinct_on: [tokenTag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTag_order_by!]

    """filter the rows returned"""
    where: tokenTag_bool_exp
  ): [tokenTag!]!

  """
  fetch aggregated fields from the table: "tokenTag"
  """
  tokenTag_aggregate(
    """distinct select on columns"""
    distinct_on: [tokenTag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTag_order_by!]

    """filter the rows returned"""
    where: tokenTag_bool_exp
  ): tokenTag_aggregate!

  """fetch data from the table: "tokenTag" using primary key columns"""
  tokenTag_by_pk(id: uuid!): tokenTag

  """
  fetch data from the table: "tokenTeam"
  """
  tokenTeam(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): [tokenTeam!]!

  """
  fetch aggregated fields from the table: "tokenTeam"
  """
  tokenTeam_aggregate(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): tokenTeam_aggregate!

  """fetch data from the table: "tokenTeam" using primary key columns"""
  tokenTeam_by_pk(id: uuid!): tokenTeam

  """
  fetch aggregated fields from the table: "token"
  """
  token_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """fetch data from the table: "token" using primary key columns"""
  token_by_pk(id: uuid!): token

  """An array relationship"""
  usageHistory(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """
  fetch data from the table: "usageHistorySecret"
  """
  usageHistorySecret(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): [usageHistorySecret!]!

  """
  fetch aggregated fields from the table: "usageHistorySecret"
  """
  usageHistorySecret_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): usageHistorySecret_aggregate!

  """
  fetch data from the table: "usageHistorySecret" using primary key columns
  """
  usageHistorySecret_by_pk(id: uuid!): usageHistorySecret

  """An aggregate relationship"""
  usageHistory_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): usageHistory_aggregate!

  """fetch data from the table: "usageHistory" using primary key columns"""
  usageHistory_by_pk(id: uuid!): usageHistory

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch data from the table: "userEmailChangeCode"
  """
  userEmailChangeCode(
    """distinct select on columns"""
    distinct_on: [userEmailChangeCode_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userEmailChangeCode_order_by!]

    """filter the rows returned"""
    where: userEmailChangeCode_bool_exp
  ): [userEmailChangeCode!]!

  """
  fetch aggregated fields from the table: "userEmailChangeCode"
  """
  userEmailChangeCode_aggregate(
    """distinct select on columns"""
    distinct_on: [userEmailChangeCode_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userEmailChangeCode_order_by!]

    """filter the rows returned"""
    where: userEmailChangeCode_bool_exp
  ): userEmailChangeCode_aggregate!

  """
  fetch data from the table: "userEmailChangeCode" using primary key columns
  """
  userEmailChangeCode_by_pk(id: uuid!): userEmailChangeCode

  """An array relationship"""
  userSecret(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """
  fetch data from the table: "userSecretField"
  """
  userSecretField(
    """distinct select on columns"""
    distinct_on: [userSecretField_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecretField_order_by!]

    """filter the rows returned"""
    where: userSecretField_bool_exp
  ): [userSecretField!]!

  """
  fetch aggregated fields from the table: "userSecretField"
  """
  userSecretField_aggregate(
    """distinct select on columns"""
    distinct_on: [userSecretField_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecretField_order_by!]

    """filter the rows returned"""
    where: userSecretField_bool_exp
  ): userSecretField_aggregate!

  """fetch data from the table: "userSecretField" using primary key columns"""
  userSecretField_by_pk(id: uuid!): userSecretField

  """An aggregate relationship"""
  userSecret_aggregate(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): userSecret_aggregate!

  """fetch data from the table: "userSecret" using primary key columns"""
  userSecret_by_pk(id: uuid!): userSecret

  """
  fetch data from the table: "userSubscription"
  """
  userSubscription(
    """distinct select on columns"""
    distinct_on: [userSubscription_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSubscription_order_by!]

    """filter the rows returned"""
    where: userSubscription_bool_exp
  ): [userSubscription!]!

  """
  fetch aggregated fields from the table: "userSubscription"
  """
  userSubscription_aggregate(
    """distinct select on columns"""
    distinct_on: [userSubscription_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSubscription_order_by!]

    """filter the rows returned"""
    where: userSubscription_bool_exp
  ): userSubscription_aggregate!

  """
  fetch data from the table: "userSubscription" using primary key columns
  """
  userSubscription_by_pk(id: uuid!): userSubscription

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: uuid!): user

  """
  fetch data from the table: "vendorEnum"
  """
  vendorEnum(
    """distinct select on columns"""
    distinct_on: [vendorEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vendorEnum_order_by!]

    """filter the rows returned"""
    where: vendorEnum_bool_exp
  ): [vendorEnum!]!

  """
  fetch aggregated fields from the table: "vendorEnum"
  """
  vendorEnum_aggregate(
    """distinct select on columns"""
    distinct_on: [vendorEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vendorEnum_order_by!]

    """filter the rows returned"""
    where: vendorEnum_bool_exp
  ): vendorEnum_aggregate!

  """fetch data from the table: "vendorEnum" using primary key columns"""
  vendorEnum_by_pk(value: String!): vendorEnum

  """
  fetch data from the table: "verification"
  """
  verification(
    """distinct select on columns"""
    distinct_on: [verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_order_by!]

    """filter the rows returned"""
    where: verification_bool_exp
  ): [verification!]!

  """
  fetch data from the table: "verificationTypeEnum"
  """
  verificationTypeEnum(
    """distinct select on columns"""
    distinct_on: [verificationTypeEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verificationTypeEnum_order_by!]

    """filter the rows returned"""
    where: verificationTypeEnum_bool_exp
  ): [verificationTypeEnum!]!

  """
  fetch aggregated fields from the table: "verificationTypeEnum"
  """
  verificationTypeEnum_aggregate(
    """distinct select on columns"""
    distinct_on: [verificationTypeEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verificationTypeEnum_order_by!]

    """filter the rows returned"""
    where: verificationTypeEnum_bool_exp
  ): verificationTypeEnum_aggregate!

  """
  fetch data from the table: "verificationTypeEnum" using primary key columns
  """
  verificationTypeEnum_by_pk(value: String!): verificationTypeEnum

  """
  fetch aggregated fields from the table: "verification"
  """
  verification_aggregate(
    """distinct select on columns"""
    distinct_on: [verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_order_by!]

    """filter the rows returned"""
    where: verification_bool_exp
  ): verification_aggregate!

  """fetch data from the table: "verification" using primary key columns"""
  verification_by_pk(id: uuid!): verification
  viewSecretFields(secretField: ViewSecretFieldsInput!): ViewSecretFieldsOutput!
}

"""enumeration of the steps of registration"""
type registrationStep {
  description: String!
  value: String!
}

"""
aggregated selection of "registrationStep"
"""
type registrationStep_aggregate {
  aggregate: registrationStep_aggregate_fields
  nodes: [registrationStep!]!
}

"""
aggregate fields of "registrationStep"
"""
type registrationStep_aggregate_fields {
  count(columns: [registrationStep_select_column!], distinct: Boolean): Int!
  max: registrationStep_max_fields
  min: registrationStep_min_fields
}

"""
Boolean expression to filter rows from the table "registrationStep". All fields are combined with a logical 'AND'.
"""
input registrationStep_bool_exp {
  _and: [registrationStep_bool_exp!]
  _not: registrationStep_bool_exp
  _or: [registrationStep_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "registrationStep"
"""
enum registrationStep_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  registrationStep_pkey
}

enum registrationStep_enum {
  """billing information collection step"""
  billingInformation

  """registration is complete"""
  complete

  """email verification step"""
  emailVerification
}

"""
Boolean expression to compare columns of type "registrationStep_enum". All fields are combined with logical 'AND'.
"""
input registrationStep_enum_comparison_exp {
  _eq: registrationStep_enum
  _in: [registrationStep_enum!]
  _is_null: Boolean
  _neq: registrationStep_enum
  _nin: [registrationStep_enum!]
}

"""
input type for inserting data into table "registrationStep"
"""
input registrationStep_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type registrationStep_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type registrationStep_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "registrationStep"
"""
type registrationStep_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [registrationStep!]!
}

"""
on_conflict condition type for table "registrationStep"
"""
input registrationStep_on_conflict {
  constraint: registrationStep_constraint!
  update_columns: [registrationStep_update_column!]! = []
  where: registrationStep_bool_exp
}

"""Ordering options when selecting data from "registrationStep"."""
input registrationStep_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: registrationStep"""
input registrationStep_pk_columns_input {
  value: String!
}

"""
select columns of table "registrationStep"
"""
enum registrationStep_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "registrationStep"
"""
input registrationStep_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "registrationStep"
"""
input registrationStep_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: registrationStep_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input registrationStep_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "registrationStep"
"""
enum registrationStep_update_column {
  """column name"""
  description

  """column name"""
  value
}

input registrationStep_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: registrationStep_set_input

  """filter the rows which have to be updated"""
  where: registrationStep_bool_exp!
}

input search_project_by_id_args {
  match: String
}

input search_team_by_id_args {
  match: String
}

input search_usage_history_by_id_args {
  match: String
}

input search_user_by_id_args {
  match: String
}

input search_user_secret_by_id_args {
  match: String
}

"""
columns and relationships of "secretSharing"
"""
type secretSharing {
  createdAt: timestamptz!
  expiresAt: timestamptz!
  id: uuid!
  releasedAt: timestamptz
  sharedByUserId: uuid!
  updatedAt: timestamptz!

  """An object relationship"""
  user: user!
}

"""
aggregated selection of "secretSharing"
"""
type secretSharing_aggregate {
  aggregate: secretSharing_aggregate_fields
  nodes: [secretSharing!]!
}

"""
aggregate fields of "secretSharing"
"""
type secretSharing_aggregate_fields {
  count(columns: [secretSharing_select_column!], distinct: Boolean): Int!
  max: secretSharing_max_fields
  min: secretSharing_min_fields
}

"""
Boolean expression to filter rows from the table "secretSharing". All fields are combined with a logical 'AND'.
"""
input secretSharing_bool_exp {
  _and: [secretSharing_bool_exp!]
  _not: secretSharing_bool_exp
  _or: [secretSharing_bool_exp!]
  createdAt: timestamptz_comparison_exp
  expiresAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  releasedAt: timestamptz_comparison_exp
  sharedByUserId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: user_bool_exp
}

"""
unique or primary key constraints on table "secretSharing"
"""
enum secretSharing_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  secretSharing_pkey
}

"""
input type for inserting data into table "secretSharing"
"""
input secretSharing_insert_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  releasedAt: timestamptz
  sharedByUserId: uuid
  updatedAt: timestamptz
  user: user_obj_rel_insert_input
}

"""aggregate max on columns"""
type secretSharing_max_fields {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  releasedAt: timestamptz
  sharedByUserId: uuid
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type secretSharing_min_fields {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  releasedAt: timestamptz
  sharedByUserId: uuid
  updatedAt: timestamptz
}

"""
response of any mutation on the table "secretSharing"
"""
type secretSharing_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [secretSharing!]!
}

"""
on_conflict condition type for table "secretSharing"
"""
input secretSharing_on_conflict {
  constraint: secretSharing_constraint!
  update_columns: [secretSharing_update_column!]! = []
  where: secretSharing_bool_exp
}

"""Ordering options when selecting data from "secretSharing"."""
input secretSharing_order_by {
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  releasedAt: order_by
  sharedByUserId: order_by
  updatedAt: order_by
  user: user_order_by
}

"""primary key columns input for table: secretSharing"""
input secretSharing_pk_columns_input {
  id: uuid!
}

"""
select columns of table "secretSharing"
"""
enum secretSharing_select_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  releasedAt

  """column name"""
  sharedByUserId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "secretSharing"
"""
input secretSharing_set_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  releasedAt: timestamptz
  sharedByUserId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "secretSharing"
"""
input secretSharing_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: secretSharing_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input secretSharing_stream_cursor_value_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  releasedAt: timestamptz
  sharedByUserId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "secretSharing"
"""
enum secretSharing_update_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  releasedAt

  """column name"""
  sharedByUserId

  """column name"""
  updatedAt
}

input secretSharing_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: secretSharing_set_input

  """filter the rows which have to be updated"""
  where: secretSharing_bool_exp!
}

"""
fields of action: "sendNotifications"
"""
type sendNotifications {
  """the time at which this action was created"""
  created_at: timestamptz!

  """errors related to the invocation"""
  errors: json

  """the unique id of an action"""
  id: uuid!

  """the output fields of this action"""
  output: SendNotificationsOutput
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"""
columns and relationships of "subscriptionIntervalEnum"
"""
type subscriptionIntervalEnum {
  value: String!
}

"""
aggregated selection of "subscriptionIntervalEnum"
"""
type subscriptionIntervalEnum_aggregate {
  aggregate: subscriptionIntervalEnum_aggregate_fields
  nodes: [subscriptionIntervalEnum!]!
}

"""
aggregate fields of "subscriptionIntervalEnum"
"""
type subscriptionIntervalEnum_aggregate_fields {
  count(columns: [subscriptionIntervalEnum_select_column!], distinct: Boolean): Int!
  max: subscriptionIntervalEnum_max_fields
  min: subscriptionIntervalEnum_min_fields
}

"""
Boolean expression to filter rows from the table "subscriptionIntervalEnum". All fields are combined with a logical 'AND'.
"""
input subscriptionIntervalEnum_bool_exp {
  _and: [subscriptionIntervalEnum_bool_exp!]
  _not: subscriptionIntervalEnum_bool_exp
  _or: [subscriptionIntervalEnum_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "subscriptionIntervalEnum"
"""
enum subscriptionIntervalEnum_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  subscriptionIntervalEnum_pkey
}

enum subscriptionIntervalEnum_enum {
  month
  year
}

"""
Boolean expression to compare columns of type "subscriptionIntervalEnum_enum". All fields are combined with logical 'AND'.
"""
input subscriptionIntervalEnum_enum_comparison_exp {
  _eq: subscriptionIntervalEnum_enum
  _in: [subscriptionIntervalEnum_enum!]
  _is_null: Boolean
  _neq: subscriptionIntervalEnum_enum
  _nin: [subscriptionIntervalEnum_enum!]
}

"""
input type for inserting data into table "subscriptionIntervalEnum"
"""
input subscriptionIntervalEnum_insert_input {
  value: String
}

"""aggregate max on columns"""
type subscriptionIntervalEnum_max_fields {
  value: String
}

"""aggregate min on columns"""
type subscriptionIntervalEnum_min_fields {
  value: String
}

"""
response of any mutation on the table "subscriptionIntervalEnum"
"""
type subscriptionIntervalEnum_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [subscriptionIntervalEnum!]!
}

"""
on_conflict condition type for table "subscriptionIntervalEnum"
"""
input subscriptionIntervalEnum_on_conflict {
  constraint: subscriptionIntervalEnum_constraint!
  update_columns: [subscriptionIntervalEnum_update_column!]! = []
  where: subscriptionIntervalEnum_bool_exp
}

"""Ordering options when selecting data from "subscriptionIntervalEnum"."""
input subscriptionIntervalEnum_order_by {
  value: order_by
}

"""primary key columns input for table: subscriptionIntervalEnum"""
input subscriptionIntervalEnum_pk_columns_input {
  value: String!
}

"""
select columns of table "subscriptionIntervalEnum"
"""
enum subscriptionIntervalEnum_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "subscriptionIntervalEnum"
"""
input subscriptionIntervalEnum_set_input {
  value: String
}

"""
Streaming cursor of the table "subscriptionIntervalEnum"
"""
input subscriptionIntervalEnum_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: subscriptionIntervalEnum_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input subscriptionIntervalEnum_stream_cursor_value_input {
  value: String
}

"""
update columns of table "subscriptionIntervalEnum"
"""
enum subscriptionIntervalEnum_update_column {
  """column name"""
  value
}

input subscriptionIntervalEnum_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: subscriptionIntervalEnum_set_input

  """filter the rows which have to be updated"""
  where: subscriptionIntervalEnum_bool_exp!
}

"""
columns and relationships of "subscriptionPlanEnum"
"""
type subscriptionPlanEnum {
  value: String!
}

"""
aggregated selection of "subscriptionPlanEnum"
"""
type subscriptionPlanEnum_aggregate {
  aggregate: subscriptionPlanEnum_aggregate_fields
  nodes: [subscriptionPlanEnum!]!
}

"""
aggregate fields of "subscriptionPlanEnum"
"""
type subscriptionPlanEnum_aggregate_fields {
  count(columns: [subscriptionPlanEnum_select_column!], distinct: Boolean): Int!
  max: subscriptionPlanEnum_max_fields
  min: subscriptionPlanEnum_min_fields
}

"""
Boolean expression to filter rows from the table "subscriptionPlanEnum". All fields are combined with a logical 'AND'.
"""
input subscriptionPlanEnum_bool_exp {
  _and: [subscriptionPlanEnum_bool_exp!]
  _not: subscriptionPlanEnum_bool_exp
  _or: [subscriptionPlanEnum_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "subscriptionPlanEnum"
"""
enum subscriptionPlanEnum_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  subscriptionPlanEnum_pkey
}

enum subscriptionPlanEnum_enum {
  enterprise
  free
  lifetime
  professional
}

"""
Boolean expression to compare columns of type "subscriptionPlanEnum_enum". All fields are combined with logical 'AND'.
"""
input subscriptionPlanEnum_enum_comparison_exp {
  _eq: subscriptionPlanEnum_enum
  _in: [subscriptionPlanEnum_enum!]
  _is_null: Boolean
  _neq: subscriptionPlanEnum_enum
  _nin: [subscriptionPlanEnum_enum!]
}

"""
input type for inserting data into table "subscriptionPlanEnum"
"""
input subscriptionPlanEnum_insert_input {
  value: String
}

"""aggregate max on columns"""
type subscriptionPlanEnum_max_fields {
  value: String
}

"""aggregate min on columns"""
type subscriptionPlanEnum_min_fields {
  value: String
}

"""
response of any mutation on the table "subscriptionPlanEnum"
"""
type subscriptionPlanEnum_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [subscriptionPlanEnum!]!
}

"""
on_conflict condition type for table "subscriptionPlanEnum"
"""
input subscriptionPlanEnum_on_conflict {
  constraint: subscriptionPlanEnum_constraint!
  update_columns: [subscriptionPlanEnum_update_column!]! = []
  where: subscriptionPlanEnum_bool_exp
}

"""Ordering options when selecting data from "subscriptionPlanEnum"."""
input subscriptionPlanEnum_order_by {
  value: order_by
}

"""primary key columns input for table: subscriptionPlanEnum"""
input subscriptionPlanEnum_pk_columns_input {
  value: String!
}

"""
select columns of table "subscriptionPlanEnum"
"""
enum subscriptionPlanEnum_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "subscriptionPlanEnum"
"""
input subscriptionPlanEnum_set_input {
  value: String
}

"""
Streaming cursor of the table "subscriptionPlanEnum"
"""
input subscriptionPlanEnum_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: subscriptionPlanEnum_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input subscriptionPlanEnum_stream_cursor_value_input {
  value: String
}

"""
update columns of table "subscriptionPlanEnum"
"""
enum subscriptionPlanEnum_update_column {
  """column name"""
  value
}

input subscriptionPlanEnum_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: subscriptionPlanEnum_set_input

  """filter the rows which have to be updated"""
  where: subscriptionPlanEnum_bool_exp!
}

type subscription_root {
  """
  fetch data from the table: "cli"
  """
  cli(
    """distinct select on columns"""
    distinct_on: [cli_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cli_order_by!]

    """filter the rows returned"""
    where: cli_bool_exp
  ): [cli!]!

  """
  fetch aggregated fields from the table: "cli"
  """
  cli_aggregate(
    """distinct select on columns"""
    distinct_on: [cli_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cli_order_by!]

    """filter the rows returned"""
    where: cli_bool_exp
  ): cli_aggregate!

  """fetch data from the table: "cli" using primary key columns"""
  cli_by_pk(id: uuid!): cli

  """
  fetch data from the table in a streaming manner: "cli"
  """
  cli_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [cli_stream_cursor_input]!

    """filter the rows returned"""
    where: cli_bool_exp
  ): [cli!]!

  """
  fetch data from the table: "integration"
  """
  integration(
    """distinct select on columns"""
    distinct_on: [integration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integration_order_by!]

    """filter the rows returned"""
    where: integration_bool_exp
  ): [integration!]!

  """
  fetch data from the table: "integrationInstallation"
  """
  integrationInstallation(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): [integrationInstallation!]!

  """
  fetch data from the table: "integrationInstallationUserSecret"
  """
  integrationInstallationUserSecret(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): [integrationInstallationUserSecret!]!

  """
  fetch aggregated fields from the table: "integrationInstallationUserSecret"
  """
  integrationInstallationUserSecret_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): integrationInstallationUserSecret_aggregate!

  """
  fetch data from the table: "integrationInstallationUserSecret" using primary key columns
  """
  integrationInstallationUserSecret_by_pk(id: uuid!): integrationInstallationUserSecret

  """
  fetch data from the table in a streaming manner: "integrationInstallationUserSecret"
  """
  integrationInstallationUserSecret_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [integrationInstallationUserSecret_stream_cursor_input]!

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): [integrationInstallationUserSecret!]!

  """
  fetch aggregated fields from the table: "integrationInstallation"
  """
  integrationInstallation_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): integrationInstallation_aggregate!

  """
  fetch data from the table: "integrationInstallation" using primary key columns
  """
  integrationInstallation_by_pk(id: uuid!): integrationInstallation

  """
  fetch data from the table in a streaming manner: "integrationInstallation"
  """
  integrationInstallation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [integrationInstallation_stream_cursor_input]!

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): [integrationInstallation!]!

  """
  fetch data from the table: "integrationVendorNameEnum"
  """
  integrationVendorNameEnum(
    """distinct select on columns"""
    distinct_on: [integrationVendorNameEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationVendorNameEnum_order_by!]

    """filter the rows returned"""
    where: integrationVendorNameEnum_bool_exp
  ): [integrationVendorNameEnum!]!

  """
  fetch aggregated fields from the table: "integrationVendorNameEnum"
  """
  integrationVendorNameEnum_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationVendorNameEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationVendorNameEnum_order_by!]

    """filter the rows returned"""
    where: integrationVendorNameEnum_bool_exp
  ): integrationVendorNameEnum_aggregate!

  """
  fetch data from the table: "integrationVendorNameEnum" using primary key columns
  """
  integrationVendorNameEnum_by_pk(value: String!): integrationVendorNameEnum

  """
  fetch data from the table in a streaming manner: "integrationVendorNameEnum"
  """
  integrationVendorNameEnum_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [integrationVendorNameEnum_stream_cursor_input]!

    """filter the rows returned"""
    where: integrationVendorNameEnum_bool_exp
  ): [integrationVendorNameEnum!]!

  """
  fetch aggregated fields from the table: "integration"
  """
  integration_aggregate(
    """distinct select on columns"""
    distinct_on: [integration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integration_order_by!]

    """filter the rows returned"""
    where: integration_bool_exp
  ): integration_aggregate!

  """fetch data from the table: "integration" using primary key columns"""
  integration_by_pk(id: uuid!): integration

  """
  fetch data from the table in a streaming manner: "integration"
  """
  integration_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [integration_stream_cursor_input]!

    """filter the rows returned"""
    where: integration_bool_exp
  ): [integration!]!

  """
  fetch data from the table: "invitationStatusEnum"
  """
  invitationStatusEnum(
    """distinct select on columns"""
    distinct_on: [invitationStatusEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitationStatusEnum_order_by!]

    """filter the rows returned"""
    where: invitationStatusEnum_bool_exp
  ): [invitationStatusEnum!]!

  """
  fetch aggregated fields from the table: "invitationStatusEnum"
  """
  invitationStatusEnum_aggregate(
    """distinct select on columns"""
    distinct_on: [invitationStatusEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitationStatusEnum_order_by!]

    """filter the rows returned"""
    where: invitationStatusEnum_bool_exp
  ): invitationStatusEnum_aggregate!

  """
  fetch data from the table: "invitationStatusEnum" using primary key columns
  """
  invitationStatusEnum_by_pk(value: String!): invitationStatusEnum

  """
  fetch data from the table in a streaming manner: "invitationStatusEnum"
  """
  invitationStatusEnum_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [invitationStatusEnum_stream_cursor_input]!

    """filter the rows returned"""
    where: invitationStatusEnum_bool_exp
  ): [invitationStatusEnum!]!

  """
  fetch data from the table: "notification"
  """
  notification(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """
  fetch data from the table: "notificationUser"
  """
  notificationUser(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!

  """
  fetch aggregated fields from the table: "notificationUser"
  """
  notificationUser_aggregate(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): notificationUser_aggregate!

  """
  fetch data from the table: "notificationUser" using primary key columns
  """
  notificationUser_by_pk(id: uuid!): notificationUser

  """
  fetch data from the table in a streaming manner: "notificationUser"
  """
  notificationUser_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notificationUser_stream_cursor_input]!

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!

  """
  fetch aggregated fields from the table: "notification"
  """
  notification_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): notification_aggregate!

  """fetch data from the table: "notification" using primary key columns"""
  notification_by_pk(id: uuid!): notification

  """
  fetch data from the table in a streaming manner: "notification"
  """
  notification_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notification_stream_cursor_input]!

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """
  fetch data from the table: "registrationStep"
  """
  registrationStep(
    """distinct select on columns"""
    distinct_on: [registrationStep_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [registrationStep_order_by!]

    """filter the rows returned"""
    where: registrationStep_bool_exp
  ): [registrationStep!]!

  """
  fetch aggregated fields from the table: "registrationStep"
  """
  registrationStep_aggregate(
    """distinct select on columns"""
    distinct_on: [registrationStep_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [registrationStep_order_by!]

    """filter the rows returned"""
    where: registrationStep_bool_exp
  ): registrationStep_aggregate!

  """
  fetch data from the table: "registrationStep" using primary key columns
  """
  registrationStep_by_pk(value: String!): registrationStep

  """
  fetch data from the table in a streaming manner: "registrationStep"
  """
  registrationStep_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [registrationStep_stream_cursor_input]!

    """filter the rows returned"""
    where: registrationStep_bool_exp
  ): [registrationStep!]!

  """
  execute function "search_project_by_id" which returns "token"
  """
  search_project_by_id(
    """
    input parameters for function "search_project_by_id"
    """
    args: search_project_by_id_args!

    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  execute function "search_project_by_id" and query aggregates on result of table type "token"
  """
  search_project_by_id_aggregate(
    """
    input parameters for function "search_project_by_id_aggregate"
    """
    args: search_project_by_id_args!

    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """
  execute function "search_team_by_id" which returns "team"
  """
  search_team_by_id(
    """
    input parameters for function "search_team_by_id"
    """
    args: search_team_by_id_args!

    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """
  execute function "search_team_by_id" and query aggregates on result of table type "team"
  """
  search_team_by_id_aggregate(
    """
    input parameters for function "search_team_by_id_aggregate"
    """
    args: search_team_by_id_args!

    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): team_aggregate!

  """
  execute function "search_usage_history_by_id" which returns "usageHistory"
  """
  search_usage_history_by_id(
    """
    input parameters for function "search_usage_history_by_id"
    """
    args: search_usage_history_by_id_args!

    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """
  execute function "search_usage_history_by_id" and query aggregates on result of table type "usageHistory"
  """
  search_usage_history_by_id_aggregate(
    """
    input parameters for function "search_usage_history_by_id_aggregate"
    """
    args: search_usage_history_by_id_args!

    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): usageHistory_aggregate!

  """
  execute function "search_user_by_id" which returns "user"
  """
  search_user_by_id(
    """
    input parameters for function "search_user_by_id"
    """
    args: search_user_by_id_args!

    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  execute function "search_user_by_id" and query aggregates on result of table type "user"
  """
  search_user_by_id_aggregate(
    """
    input parameters for function "search_user_by_id_aggregate"
    """
    args: search_user_by_id_args!

    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """
  execute function "search_user_secret_by_id" which returns "userSecret"
  """
  search_user_secret_by_id(
    """
    input parameters for function "search_user_secret_by_id"
    """
    args: search_user_secret_by_id_args!

    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """
  execute function "search_user_secret_by_id" and query aggregates on result of table type "userSecret"
  """
  search_user_secret_by_id_aggregate(
    """
    input parameters for function "search_user_secret_by_id_aggregate"
    """
    args: search_user_secret_by_id_args!

    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): userSecret_aggregate!

  """
  fetch data from the table: "secretSharing"
  """
  secretSharing(
    """distinct select on columns"""
    distinct_on: [secretSharing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [secretSharing_order_by!]

    """filter the rows returned"""
    where: secretSharing_bool_exp
  ): [secretSharing!]!

  """
  fetch aggregated fields from the table: "secretSharing"
  """
  secretSharing_aggregate(
    """distinct select on columns"""
    distinct_on: [secretSharing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [secretSharing_order_by!]

    """filter the rows returned"""
    where: secretSharing_bool_exp
  ): secretSharing_aggregate!

  """fetch data from the table: "secretSharing" using primary key columns"""
  secretSharing_by_pk(id: uuid!): secretSharing

  """
  fetch data from the table in a streaming manner: "secretSharing"
  """
  secretSharing_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [secretSharing_stream_cursor_input]!

    """filter the rows returned"""
    where: secretSharing_bool_exp
  ): [secretSharing!]!

  """Send notifications"""
  sendNotifications(
    """the unique id of an action"""
    id: uuid!
  ): sendNotifications

  """
  fetch data from the table: "subscriptionIntervalEnum"
  """
  subscriptionIntervalEnum(
    """distinct select on columns"""
    distinct_on: [subscriptionIntervalEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptionIntervalEnum_order_by!]

    """filter the rows returned"""
    where: subscriptionIntervalEnum_bool_exp
  ): [subscriptionIntervalEnum!]!

  """
  fetch aggregated fields from the table: "subscriptionIntervalEnum"
  """
  subscriptionIntervalEnum_aggregate(
    """distinct select on columns"""
    distinct_on: [subscriptionIntervalEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptionIntervalEnum_order_by!]

    """filter the rows returned"""
    where: subscriptionIntervalEnum_bool_exp
  ): subscriptionIntervalEnum_aggregate!

  """
  fetch data from the table: "subscriptionIntervalEnum" using primary key columns
  """
  subscriptionIntervalEnum_by_pk(value: String!): subscriptionIntervalEnum

  """
  fetch data from the table in a streaming manner: "subscriptionIntervalEnum"
  """
  subscriptionIntervalEnum_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [subscriptionIntervalEnum_stream_cursor_input]!

    """filter the rows returned"""
    where: subscriptionIntervalEnum_bool_exp
  ): [subscriptionIntervalEnum!]!

  """
  fetch data from the table: "subscriptionPlanEnum"
  """
  subscriptionPlanEnum(
    """distinct select on columns"""
    distinct_on: [subscriptionPlanEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptionPlanEnum_order_by!]

    """filter the rows returned"""
    where: subscriptionPlanEnum_bool_exp
  ): [subscriptionPlanEnum!]!

  """
  fetch aggregated fields from the table: "subscriptionPlanEnum"
  """
  subscriptionPlanEnum_aggregate(
    """distinct select on columns"""
    distinct_on: [subscriptionPlanEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptionPlanEnum_order_by!]

    """filter the rows returned"""
    where: subscriptionPlanEnum_bool_exp
  ): subscriptionPlanEnum_aggregate!

  """
  fetch data from the table: "subscriptionPlanEnum" using primary key columns
  """
  subscriptionPlanEnum_by_pk(value: String!): subscriptionPlanEnum

  """
  fetch data from the table in a streaming manner: "subscriptionPlanEnum"
  """
  subscriptionPlanEnum_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [subscriptionPlanEnum_stream_cursor_input]!

    """filter the rows returned"""
    where: subscriptionPlanEnum_bool_exp
  ): [subscriptionPlanEnum!]!

  """
  fetch data from the table: "tag"
  """
  tag(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """
  fetch aggregated fields from the table: "tag"
  """
  tag_aggregate(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): tag_aggregate!

  """fetch data from the table: "tag" using primary key columns"""
  tag_by_pk(id: uuid!): tag

  """
  fetch data from the table in a streaming manner: "tag"
  """
  tag_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tag_stream_cursor_input]!

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """
  fetch data from the table: "team"
  """
  team(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """
  fetch data from the table: "teamInvitation"
  """
  teamInvitation(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!

  """
  fetch aggregated fields from the table: "teamInvitation"
  """
  teamInvitation_aggregate(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): teamInvitation_aggregate!

  """fetch data from the table: "teamInvitation" using primary key columns"""
  teamInvitation_by_pk(id: uuid!): teamInvitation

  """
  fetch data from the table in a streaming manner: "teamInvitation"
  """
  teamInvitation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [teamInvitation_stream_cursor_input]!

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!

  """
  fetch data from the table: "teamUser"
  """
  teamUser(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """
  fetch aggregated fields from the table: "teamUser"
  """
  teamUser_aggregate(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!

  """fetch data from the table: "teamUser" using primary key columns"""
  teamUser_by_pk(id: uuid!): teamUser

  """
  fetch data from the table in a streaming manner: "teamUser"
  """
  teamUser_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [teamUser_stream_cursor_input]!

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """
  fetch aggregated fields from the table: "team"
  """
  team_aggregate(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): team_aggregate!

  """fetch data from the table: "team" using primary key columns"""
  team_by_pk(id: uuid!): team

  """
  fetch data from the table in a streaming manner: "team"
  """
  team_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [team_stream_cursor_input]!

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  fetch data from the table: "tokenTag"
  """
  tokenTag(
    """distinct select on columns"""
    distinct_on: [tokenTag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTag_order_by!]

    """filter the rows returned"""
    where: tokenTag_bool_exp
  ): [tokenTag!]!

  """
  fetch aggregated fields from the table: "tokenTag"
  """
  tokenTag_aggregate(
    """distinct select on columns"""
    distinct_on: [tokenTag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTag_order_by!]

    """filter the rows returned"""
    where: tokenTag_bool_exp
  ): tokenTag_aggregate!

  """fetch data from the table: "tokenTag" using primary key columns"""
  tokenTag_by_pk(id: uuid!): tokenTag

  """
  fetch data from the table in a streaming manner: "tokenTag"
  """
  tokenTag_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tokenTag_stream_cursor_input]!

    """filter the rows returned"""
    where: tokenTag_bool_exp
  ): [tokenTag!]!

  """
  fetch data from the table: "tokenTeam"
  """
  tokenTeam(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): [tokenTeam!]!

  """
  fetch aggregated fields from the table: "tokenTeam"
  """
  tokenTeam_aggregate(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): tokenTeam_aggregate!

  """fetch data from the table: "tokenTeam" using primary key columns"""
  tokenTeam_by_pk(id: uuid!): tokenTeam

  """
  fetch data from the table in a streaming manner: "tokenTeam"
  """
  tokenTeam_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tokenTeam_stream_cursor_input]!

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): [tokenTeam!]!

  """
  fetch aggregated fields from the table: "token"
  """
  token_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """fetch data from the table: "token" using primary key columns"""
  token_by_pk(id: uuid!): token

  """
  fetch data from the table in a streaming manner: "token"
  """
  token_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [token_stream_cursor_input]!

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """An array relationship"""
  usageHistory(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """
  fetch data from the table: "usageHistorySecret"
  """
  usageHistorySecret(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): [usageHistorySecret!]!

  """
  fetch aggregated fields from the table: "usageHistorySecret"
  """
  usageHistorySecret_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): usageHistorySecret_aggregate!

  """
  fetch data from the table: "usageHistorySecret" using primary key columns
  """
  usageHistorySecret_by_pk(id: uuid!): usageHistorySecret

  """
  fetch data from the table in a streaming manner: "usageHistorySecret"
  """
  usageHistorySecret_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [usageHistorySecret_stream_cursor_input]!

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): [usageHistorySecret!]!

  """An aggregate relationship"""
  usageHistory_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): usageHistory_aggregate!

  """fetch data from the table: "usageHistory" using primary key columns"""
  usageHistory_by_pk(id: uuid!): usageHistory

  """
  fetch data from the table in a streaming manner: "usageHistory"
  """
  usageHistory_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [usageHistory_stream_cursor_input]!

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch data from the table: "userEmailChangeCode"
  """
  userEmailChangeCode(
    """distinct select on columns"""
    distinct_on: [userEmailChangeCode_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userEmailChangeCode_order_by!]

    """filter the rows returned"""
    where: userEmailChangeCode_bool_exp
  ): [userEmailChangeCode!]!

  """
  fetch aggregated fields from the table: "userEmailChangeCode"
  """
  userEmailChangeCode_aggregate(
    """distinct select on columns"""
    distinct_on: [userEmailChangeCode_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userEmailChangeCode_order_by!]

    """filter the rows returned"""
    where: userEmailChangeCode_bool_exp
  ): userEmailChangeCode_aggregate!

  """
  fetch data from the table: "userEmailChangeCode" using primary key columns
  """
  userEmailChangeCode_by_pk(id: uuid!): userEmailChangeCode

  """
  fetch data from the table in a streaming manner: "userEmailChangeCode"
  """
  userEmailChangeCode_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [userEmailChangeCode_stream_cursor_input]!

    """filter the rows returned"""
    where: userEmailChangeCode_bool_exp
  ): [userEmailChangeCode!]!

  """An array relationship"""
  userSecret(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """
  fetch data from the table: "userSecretField"
  """
  userSecretField(
    """distinct select on columns"""
    distinct_on: [userSecretField_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecretField_order_by!]

    """filter the rows returned"""
    where: userSecretField_bool_exp
  ): [userSecretField!]!

  """
  fetch aggregated fields from the table: "userSecretField"
  """
  userSecretField_aggregate(
    """distinct select on columns"""
    distinct_on: [userSecretField_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecretField_order_by!]

    """filter the rows returned"""
    where: userSecretField_bool_exp
  ): userSecretField_aggregate!

  """fetch data from the table: "userSecretField" using primary key columns"""
  userSecretField_by_pk(id: uuid!): userSecretField

  """
  fetch data from the table in a streaming manner: "userSecretField"
  """
  userSecretField_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [userSecretField_stream_cursor_input]!

    """filter the rows returned"""
    where: userSecretField_bool_exp
  ): [userSecretField!]!

  """An aggregate relationship"""
  userSecret_aggregate(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): userSecret_aggregate!

  """fetch data from the table: "userSecret" using primary key columns"""
  userSecret_by_pk(id: uuid!): userSecret

  """
  fetch data from the table in a streaming manner: "userSecret"
  """
  userSecret_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [userSecret_stream_cursor_input]!

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """
  fetch data from the table: "userSubscription"
  """
  userSubscription(
    """distinct select on columns"""
    distinct_on: [userSubscription_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSubscription_order_by!]

    """filter the rows returned"""
    where: userSubscription_bool_exp
  ): [userSubscription!]!

  """
  fetch aggregated fields from the table: "userSubscription"
  """
  userSubscription_aggregate(
    """distinct select on columns"""
    distinct_on: [userSubscription_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSubscription_order_by!]

    """filter the rows returned"""
    where: userSubscription_bool_exp
  ): userSubscription_aggregate!

  """
  fetch data from the table: "userSubscription" using primary key columns
  """
  userSubscription_by_pk(id: uuid!): userSubscription

  """
  fetch data from the table in a streaming manner: "userSubscription"
  """
  userSubscription_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [userSubscription_stream_cursor_input]!

    """filter the rows returned"""
    where: userSubscription_bool_exp
  ): [userSubscription!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: uuid!): user

  """
  fetch data from the table in a streaming manner: "user"
  """
  user_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_stream_cursor_input]!

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch data from the table: "vendorEnum"
  """
  vendorEnum(
    """distinct select on columns"""
    distinct_on: [vendorEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vendorEnum_order_by!]

    """filter the rows returned"""
    where: vendorEnum_bool_exp
  ): [vendorEnum!]!

  """
  fetch aggregated fields from the table: "vendorEnum"
  """
  vendorEnum_aggregate(
    """distinct select on columns"""
    distinct_on: [vendorEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vendorEnum_order_by!]

    """filter the rows returned"""
    where: vendorEnum_bool_exp
  ): vendorEnum_aggregate!

  """fetch data from the table: "vendorEnum" using primary key columns"""
  vendorEnum_by_pk(value: String!): vendorEnum

  """
  fetch data from the table in a streaming manner: "vendorEnum"
  """
  vendorEnum_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [vendorEnum_stream_cursor_input]!

    """filter the rows returned"""
    where: vendorEnum_bool_exp
  ): [vendorEnum!]!

  """
  fetch data from the table: "verification"
  """
  verification(
    """distinct select on columns"""
    distinct_on: [verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_order_by!]

    """filter the rows returned"""
    where: verification_bool_exp
  ): [verification!]!

  """
  fetch data from the table: "verificationTypeEnum"
  """
  verificationTypeEnum(
    """distinct select on columns"""
    distinct_on: [verificationTypeEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verificationTypeEnum_order_by!]

    """filter the rows returned"""
    where: verificationTypeEnum_bool_exp
  ): [verificationTypeEnum!]!

  """
  fetch aggregated fields from the table: "verificationTypeEnum"
  """
  verificationTypeEnum_aggregate(
    """distinct select on columns"""
    distinct_on: [verificationTypeEnum_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verificationTypeEnum_order_by!]

    """filter the rows returned"""
    where: verificationTypeEnum_bool_exp
  ): verificationTypeEnum_aggregate!

  """
  fetch data from the table: "verificationTypeEnum" using primary key columns
  """
  verificationTypeEnum_by_pk(value: String!): verificationTypeEnum

  """
  fetch data from the table in a streaming manner: "verificationTypeEnum"
  """
  verificationTypeEnum_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [verificationTypeEnum_stream_cursor_input]!

    """filter the rows returned"""
    where: verificationTypeEnum_bool_exp
  ): [verificationTypeEnum!]!

  """
  fetch aggregated fields from the table: "verification"
  """
  verification_aggregate(
    """distinct select on columns"""
    distinct_on: [verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_order_by!]

    """filter the rows returned"""
    where: verification_bool_exp
  ): verification_aggregate!

  """fetch data from the table: "verification" using primary key columns"""
  verification_by_pk(id: uuid!): verification

  """
  fetch data from the table in a streaming manner: "verification"
  """
  verification_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [verification_stream_cursor_input]!

    """filter the rows returned"""
    where: verification_bool_exp
  ): [verification!]!
}

"""
columns and relationships of "tag"
"""
type tag {
  color: String!
  createdAt: timestamptz!
  id: uuid!
  name: String!

  """An array relationship"""
  tokenTags(
    """distinct select on columns"""
    distinct_on: [tokenTag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTag_order_by!]

    """filter the rows returned"""
    where: tokenTag_bool_exp
  ): [tokenTag!]!

  """An aggregate relationship"""
  tokenTags_aggregate(
    """distinct select on columns"""
    distinct_on: [tokenTag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTag_order_by!]

    """filter the rows returned"""
    where: tokenTag_bool_exp
  ): tokenTag_aggregate!
  updatedAt: timestamptz!

  """An object relationship"""
  user: user
  userId: uuid!
}

"""
aggregated selection of "tag"
"""
type tag_aggregate {
  aggregate: tag_aggregate_fields
  nodes: [tag!]!
}

"""
aggregate fields of "tag"
"""
type tag_aggregate_fields {
  count(columns: [tag_select_column!], distinct: Boolean): Int!
  max: tag_max_fields
  min: tag_min_fields
}

"""
Boolean expression to filter rows from the table "tag". All fields are combined with a logical 'AND'.
"""
input tag_bool_exp {
  _and: [tag_bool_exp!]
  _not: tag_bool_exp
  _or: [tag_bool_exp!]
  color: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  tokenTags: tokenTag_bool_exp
  tokenTags_aggregate: tokenTag_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
  user: user_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "tag"
"""
enum tag_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tag_id_key

  """
  unique or primary key constraint on columns "id"
  """
  tag_pkey
}

"""
input type for inserting data into table "tag"
"""
input tag_insert_input {
  color: String
  createdAt: timestamptz
  id: uuid
  name: String
  tokenTags: tokenTag_arr_rel_insert_input
  updatedAt: timestamptz
  user: user_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type tag_max_fields {
  color: String
  createdAt: timestamptz
  id: uuid
  name: String
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate min on columns"""
type tag_min_fields {
  color: String
  createdAt: timestamptz
  id: uuid
  name: String
  updatedAt: timestamptz
  userId: uuid
}

"""
response of any mutation on the table "tag"
"""
type tag_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tag!]!
}

"""
input type for inserting object relation for remote table "tag"
"""
input tag_obj_rel_insert_input {
  data: tag_insert_input!

  """upsert condition"""
  on_conflict: tag_on_conflict
}

"""
on_conflict condition type for table "tag"
"""
input tag_on_conflict {
  constraint: tag_constraint!
  update_columns: [tag_update_column!]! = []
  where: tag_bool_exp
}

"""Ordering options when selecting data from "tag"."""
input tag_order_by {
  color: order_by
  createdAt: order_by
  id: order_by
  name: order_by
  tokenTags_aggregate: tokenTag_aggregate_order_by
  updatedAt: order_by
  user: user_order_by
  userId: order_by
}

"""primary key columns input for table: tag"""
input tag_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tag"
"""
enum tag_select_column {
  """column name"""
  color

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "tag"
"""
input tag_set_input {
  color: String
  createdAt: timestamptz
  id: uuid
  name: String
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "tag"
"""
input tag_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tag_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tag_stream_cursor_value_input {
  color: String
  createdAt: timestamptz
  id: uuid
  name: String
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "tag"
"""
enum tag_update_column {
  """column name"""
  color

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updatedAt

  """column name"""
  userId
}

input tag_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: tag_set_input

  """filter the rows which have to be updated"""
  where: tag_bool_exp!
}

"""
columns and relationships of "team"
"""
type team {
  createdAt: timestamptz!
  description: String
  id: uuid!
  lastUpdatedAt: timestamptz

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!
  name: String!

  """An object relationship"""
  owner: user
  ownerUserId: uuid!

  """An array relationship"""
  tokenTeams(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): [tokenTeam!]!

  """An aggregate relationship"""
  tokenTeams_aggregate(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): tokenTeam_aggregate!
  updatedAt: timestamptz!
}

"""
columns and relationships of "teamInvitation"
"""
type teamInvitation {
  createdAt: timestamptz!
  email: String!
  expiredAt: timestamptz!
  id: uuid!
  invitedBy: uuid!

  """An object relationship"""
  invitedUser: user

  """An object relationship"""
  ownerTeam: user!
  status: invitationStatusEnum_enum!

  """An object relationship"""
  team: team!
  teamId: uuid!
  teamName: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "teamInvitation"
"""
type teamInvitation_aggregate {
  aggregate: teamInvitation_aggregate_fields
  nodes: [teamInvitation!]!
}

input teamInvitation_aggregate_bool_exp {
  count: teamInvitation_aggregate_bool_exp_count
}

input teamInvitation_aggregate_bool_exp_count {
  arguments: [teamInvitation_select_column!]
  distinct: Boolean
  filter: teamInvitation_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "teamInvitation"
"""
type teamInvitation_aggregate_fields {
  count(columns: [teamInvitation_select_column!], distinct: Boolean): Int!
  max: teamInvitation_max_fields
  min: teamInvitation_min_fields
}

"""
order by aggregate values of table "teamInvitation"
"""
input teamInvitation_aggregate_order_by {
  count: order_by
  max: teamInvitation_max_order_by
  min: teamInvitation_min_order_by
}

"""
input type for inserting array relation for remote table "teamInvitation"
"""
input teamInvitation_arr_rel_insert_input {
  data: [teamInvitation_insert_input!]!

  """upsert condition"""
  on_conflict: teamInvitation_on_conflict
}

"""
Boolean expression to filter rows from the table "teamInvitation". All fields are combined with a logical 'AND'.
"""
input teamInvitation_bool_exp {
  _and: [teamInvitation_bool_exp!]
  _not: teamInvitation_bool_exp
  _or: [teamInvitation_bool_exp!]
  createdAt: timestamptz_comparison_exp
  email: String_comparison_exp
  expiredAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  invitedBy: uuid_comparison_exp
  invitedUser: user_bool_exp
  ownerTeam: user_bool_exp
  status: invitationStatusEnum_enum_comparison_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  teamName: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "teamInvitation"
"""
enum teamInvitation_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  teamInvitation_pkey
}

"""
input type for inserting data into table "teamInvitation"
"""
input teamInvitation_insert_input {
  createdAt: timestamptz
  email: String
  expiredAt: timestamptz
  id: uuid
  invitedBy: uuid
  invitedUser: user_obj_rel_insert_input
  ownerTeam: user_obj_rel_insert_input
  status: invitationStatusEnum_enum
  team: team_obj_rel_insert_input
  teamId: uuid
  teamName: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type teamInvitation_max_fields {
  createdAt: timestamptz
  email: String
  expiredAt: timestamptz
  id: uuid
  invitedBy: uuid
  teamId: uuid
  teamName: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "teamInvitation"
"""
input teamInvitation_max_order_by {
  createdAt: order_by
  email: order_by
  expiredAt: order_by
  id: order_by
  invitedBy: order_by
  teamId: order_by
  teamName: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type teamInvitation_min_fields {
  createdAt: timestamptz
  email: String
  expiredAt: timestamptz
  id: uuid
  invitedBy: uuid
  teamId: uuid
  teamName: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "teamInvitation"
"""
input teamInvitation_min_order_by {
  createdAt: order_by
  email: order_by
  expiredAt: order_by
  id: order_by
  invitedBy: order_by
  teamId: order_by
  teamName: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "teamInvitation"
"""
type teamInvitation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [teamInvitation!]!
}

"""
on_conflict condition type for table "teamInvitation"
"""
input teamInvitation_on_conflict {
  constraint: teamInvitation_constraint!
  update_columns: [teamInvitation_update_column!]! = []
  where: teamInvitation_bool_exp
}

"""Ordering options when selecting data from "teamInvitation"."""
input teamInvitation_order_by {
  createdAt: order_by
  email: order_by
  expiredAt: order_by
  id: order_by
  invitedBy: order_by
  invitedUser: user_order_by
  ownerTeam: user_order_by
  status: order_by
  team: team_order_by
  teamId: order_by
  teamName: order_by
  updatedAt: order_by
}

"""primary key columns input for table: teamInvitation"""
input teamInvitation_pk_columns_input {
  id: uuid!
}

"""
select columns of table "teamInvitation"
"""
enum teamInvitation_select_column {
  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  expiredAt

  """column name"""
  id

  """column name"""
  invitedBy

  """column name"""
  status

  """column name"""
  teamId

  """column name"""
  teamName

  """column name"""
  updatedAt
}

"""
input type for updating data in table "teamInvitation"
"""
input teamInvitation_set_input {
  createdAt: timestamptz
  email: String
  expiredAt: timestamptz
  id: uuid
  invitedBy: uuid
  status: invitationStatusEnum_enum
  teamId: uuid
  teamName: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "teamInvitation"
"""
input teamInvitation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: teamInvitation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input teamInvitation_stream_cursor_value_input {
  createdAt: timestamptz
  email: String
  expiredAt: timestamptz
  id: uuid
  invitedBy: uuid
  status: invitationStatusEnum_enum
  teamId: uuid
  teamName: String
  updatedAt: timestamptz
}

"""
update columns of table "teamInvitation"
"""
enum teamInvitation_update_column {
  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  expiredAt

  """column name"""
  id

  """column name"""
  invitedBy

  """column name"""
  status

  """column name"""
  teamId

  """column name"""
  teamName

  """column name"""
  updatedAt
}

input teamInvitation_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: teamInvitation_set_input

  """filter the rows which have to be updated"""
  where: teamInvitation_bool_exp!
}

"""
columns and relationships of "teamUser"
"""
type teamUser {
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  member: user!

  """An object relationship"""
  team: team!
  teamId: uuid!
  updatedAt: timestamptz!
  userId: uuid!
}

"""
aggregated selection of "teamUser"
"""
type teamUser_aggregate {
  aggregate: teamUser_aggregate_fields
  nodes: [teamUser!]!
}

input teamUser_aggregate_bool_exp {
  count: teamUser_aggregate_bool_exp_count
}

input teamUser_aggregate_bool_exp_count {
  arguments: [teamUser_select_column!]
  distinct: Boolean
  filter: teamUser_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "teamUser"
"""
type teamUser_aggregate_fields {
  count(columns: [teamUser_select_column!], distinct: Boolean): Int!
  max: teamUser_max_fields
  min: teamUser_min_fields
}

"""
order by aggregate values of table "teamUser"
"""
input teamUser_aggregate_order_by {
  count: order_by
  max: teamUser_max_order_by
  min: teamUser_min_order_by
}

"""
input type for inserting array relation for remote table "teamUser"
"""
input teamUser_arr_rel_insert_input {
  data: [teamUser_insert_input!]!

  """upsert condition"""
  on_conflict: teamUser_on_conflict
}

"""
Boolean expression to filter rows from the table "teamUser". All fields are combined with a logical 'AND'.
"""
input teamUser_bool_exp {
  _and: [teamUser_bool_exp!]
  _not: teamUser_bool_exp
  _or: [teamUser_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  member: user_bool_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "teamUser"
"""
enum teamUser_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  teamUser_pkey
}

"""
input type for inserting data into table "teamUser"
"""
input teamUser_insert_input {
  createdAt: timestamptz
  id: uuid
  member: user_obj_rel_insert_input
  team: team_obj_rel_insert_input
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate max on columns"""
type teamUser_max_fields {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "teamUser"
"""
input teamUser_max_order_by {
  createdAt: order_by
  id: order_by
  teamId: order_by
  updatedAt: order_by
  userId: order_by
}

"""aggregate min on columns"""
type teamUser_min_fields {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "teamUser"
"""
input teamUser_min_order_by {
  createdAt: order_by
  id: order_by
  teamId: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "teamUser"
"""
type teamUser_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [teamUser!]!
}

"""
on_conflict condition type for table "teamUser"
"""
input teamUser_on_conflict {
  constraint: teamUser_constraint!
  update_columns: [teamUser_update_column!]! = []
  where: teamUser_bool_exp
}

"""Ordering options when selecting data from "teamUser"."""
input teamUser_order_by {
  createdAt: order_by
  id: order_by
  member: user_order_by
  team: team_order_by
  teamId: order_by
  updatedAt: order_by
  userId: order_by
}

"""primary key columns input for table: teamUser"""
input teamUser_pk_columns_input {
  id: uuid!
}

"""
select columns of table "teamUser"
"""
enum teamUser_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  teamId

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "teamUser"
"""
input teamUser_set_input {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "teamUser"
"""
input teamUser_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: teamUser_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input teamUser_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "teamUser"
"""
enum teamUser_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  teamId

  """column name"""
  updatedAt

  """column name"""
  userId
}

input teamUser_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: teamUser_set_input

  """filter the rows which have to be updated"""
  where: teamUser_bool_exp!
}

type team_aggregate {
  aggregate: team_aggregate_fields
  nodes: [team!]!
}

"""
aggregate fields of "team"
"""
type team_aggregate_fields {
  count(columns: [team_select_column!], distinct: Boolean): Int!
  max: team_max_fields
  min: team_min_fields
}

"""
Boolean expression to filter rows from the table "team". All fields are combined with a logical 'AND'.
"""
input team_bool_exp {
  _and: [team_bool_exp!]
  _not: team_bool_exp
  _or: [team_bool_exp!]
  createdAt: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  lastUpdatedAt: timestamptz_comparison_exp
  members: teamUser_bool_exp
  members_aggregate: teamUser_aggregate_bool_exp
  name: String_comparison_exp
  owner: user_bool_exp
  ownerUserId: uuid_comparison_exp
  tokenTeams: tokenTeam_bool_exp
  tokenTeams_aggregate: tokenTeam_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "team"
"""
enum team_constraint {
  """
  unique or primary key constraint on columns "ownerUserId", "name"
  """
  team_name_ownerUserId_key

  """
  unique or primary key constraint on columns "id"
  """
  team_pkey
}

"""
input type for inserting data into table "team"
"""
input team_insert_input {
  createdAt: timestamptz
  description: String
  id: uuid
  lastUpdatedAt: timestamptz
  members: teamUser_arr_rel_insert_input
  name: String
  owner: user_obj_rel_insert_input
  ownerUserId: uuid
  tokenTeams: tokenTeam_arr_rel_insert_input
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type team_max_fields {
  createdAt: timestamptz
  description: String
  id: uuid
  lastUpdatedAt: timestamptz
  name: String
  ownerUserId: uuid
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type team_min_fields {
  createdAt: timestamptz
  description: String
  id: uuid
  lastUpdatedAt: timestamptz
  name: String
  ownerUserId: uuid
  updatedAt: timestamptz
}

"""
response of any mutation on the table "team"
"""
type team_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [team!]!
}

"""
input type for inserting object relation for remote table "team"
"""
input team_obj_rel_insert_input {
  data: team_insert_input!

  """upsert condition"""
  on_conflict: team_on_conflict
}

"""
on_conflict condition type for table "team"
"""
input team_on_conflict {
  constraint: team_constraint!
  update_columns: [team_update_column!]! = []
  where: team_bool_exp
}

"""Ordering options when selecting data from "team"."""
input team_order_by {
  createdAt: order_by
  description: order_by
  id: order_by
  lastUpdatedAt: order_by
  members_aggregate: teamUser_aggregate_order_by
  name: order_by
  owner: user_order_by
  ownerUserId: order_by
  tokenTeams_aggregate: tokenTeam_aggregate_order_by
  updatedAt: order_by
}

"""primary key columns input for table: team"""
input team_pk_columns_input {
  id: uuid!
}

"""
select columns of table "team"
"""
enum team_select_column {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  name

  """column name"""
  ownerUserId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "team"
"""
input team_set_input {
  createdAt: timestamptz
  description: String
  id: uuid
  lastUpdatedAt: timestamptz
  name: String
  ownerUserId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "team"
"""
input team_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: team_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input team_stream_cursor_value_input {
  createdAt: timestamptz
  description: String
  id: uuid
  lastUpdatedAt: timestamptz
  name: String
  ownerUserId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "team"
"""
enum team_update_column {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  name

  """column name"""
  ownerUserId

  """column name"""
  updatedAt
}

input team_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: team_set_input

  """filter the rows which have to be updated"""
  where: team_bool_exp!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "token"
"""
type token {
  createdAt: timestamptz!
  description: String
  icon: String!
  id: uuid!

  """An array relationship"""
  integrationInstallations(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): [integrationInstallation!]!

  """An aggregate relationship"""
  integrationInstallations_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): integrationInstallation_aggregate!
  lastUpdatedAt: timestamptz

  """
  A computed field, executes function "computeTokenLastUsedAt"
  """
  lastUsedAt: timestamptz
  name: String!

  """An object relationship"""
  owner: user!
  ownerUserId: uuid!
  publicId: String!
  slug: String!

  """An array relationship"""
  tags(
    """distinct select on columns"""
    distinct_on: [tokenTag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTag_order_by!]

    """filter the rows returned"""
    where: tokenTag_bool_exp
  ): [tokenTag!]!

  """An aggregate relationship"""
  tags_aggregate(
    """distinct select on columns"""
    distinct_on: [tokenTag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTag_order_by!]

    """filter the rows returned"""
    where: tokenTag_bool_exp
  ): tokenTag_aggregate!

  """An array relationship"""
  teams(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): [tokenTeam!]!

  """An aggregate relationship"""
  teams_aggregate(
    """distinct select on columns"""
    distinct_on: [tokenTeam_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokenTeam_order_by!]

    """filter the rows returned"""
    where: tokenTeam_bool_exp
  ): tokenTeam_aggregate!
  tokenHash: String!
  updatedAt: timestamptz!

  """An array relationship"""
  usageHistory(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """An aggregate relationship"""
  usageHistory_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): usageHistory_aggregate!

  """An array relationship"""
  userSecret(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """An aggregate relationship"""
  userSecret_aggregate(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): userSecret_aggregate!
}

"""
columns and relationships of "tokenTag"
"""
type tokenTag {
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  tag: tag!
  tagId: uuid!

  """An object relationship"""
  token: token!
  tokenId: uuid!
  updatedAt: timestamptz!
}

"""
aggregated selection of "tokenTag"
"""
type tokenTag_aggregate {
  aggregate: tokenTag_aggregate_fields
  nodes: [tokenTag!]!
}

input tokenTag_aggregate_bool_exp {
  count: tokenTag_aggregate_bool_exp_count
}

input tokenTag_aggregate_bool_exp_count {
  arguments: [tokenTag_select_column!]
  distinct: Boolean
  filter: tokenTag_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "tokenTag"
"""
type tokenTag_aggregate_fields {
  count(columns: [tokenTag_select_column!], distinct: Boolean): Int!
  max: tokenTag_max_fields
  min: tokenTag_min_fields
}

"""
order by aggregate values of table "tokenTag"
"""
input tokenTag_aggregate_order_by {
  count: order_by
  max: tokenTag_max_order_by
  min: tokenTag_min_order_by
}

"""
input type for inserting array relation for remote table "tokenTag"
"""
input tokenTag_arr_rel_insert_input {
  data: [tokenTag_insert_input!]!

  """upsert condition"""
  on_conflict: tokenTag_on_conflict
}

"""
Boolean expression to filter rows from the table "tokenTag". All fields are combined with a logical 'AND'.
"""
input tokenTag_bool_exp {
  _and: [tokenTag_bool_exp!]
  _not: tokenTag_bool_exp
  _or: [tokenTag_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  tag: tag_bool_exp
  tagId: uuid_comparison_exp
  token: token_bool_exp
  tokenId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "tokenTag"
"""
enum tokenTag_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tokenTag_pkey

  """
  unique or primary key constraint on columns "tagId", "tokenId"
  """
  tokenTag_tokenId_tagId_key
}

"""
input type for inserting data into table "tokenTag"
"""
input tokenTag_insert_input {
  createdAt: timestamptz
  id: uuid
  tag: tag_obj_rel_insert_input
  tagId: uuid
  token: token_obj_rel_insert_input
  tokenId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type tokenTag_max_fields {
  createdAt: timestamptz
  id: uuid
  tagId: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "tokenTag"
"""
input tokenTag_max_order_by {
  createdAt: order_by
  id: order_by
  tagId: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type tokenTag_min_fields {
  createdAt: timestamptz
  id: uuid
  tagId: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "tokenTag"
"""
input tokenTag_min_order_by {
  createdAt: order_by
  id: order_by
  tagId: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "tokenTag"
"""
type tokenTag_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tokenTag!]!
}

"""
on_conflict condition type for table "tokenTag"
"""
input tokenTag_on_conflict {
  constraint: tokenTag_constraint!
  update_columns: [tokenTag_update_column!]! = []
  where: tokenTag_bool_exp
}

"""Ordering options when selecting data from "tokenTag"."""
input tokenTag_order_by {
  createdAt: order_by
  id: order_by
  tag: tag_order_by
  tagId: order_by
  token: token_order_by
  tokenId: order_by
  updatedAt: order_by
}

"""primary key columns input for table: tokenTag"""
input tokenTag_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tokenTag"
"""
enum tokenTag_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  tagId

  """column name"""
  tokenId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "tokenTag"
"""
input tokenTag_set_input {
  createdAt: timestamptz
  id: uuid
  tagId: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "tokenTag"
"""
input tokenTag_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tokenTag_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tokenTag_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  tagId: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "tokenTag"
"""
enum tokenTag_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  tagId

  """column name"""
  tokenId

  """column name"""
  updatedAt
}

input tokenTag_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: tokenTag_set_input

  """filter the rows which have to be updated"""
  where: tokenTag_bool_exp!
}

"""
columns and relationships of "tokenTeam"
"""
type tokenTeam {
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  team: team!
  teamId: uuid!

  """An object relationship"""
  token: token!
  tokenId: uuid!
  updatedAt: timestamptz!
}

"""
aggregated selection of "tokenTeam"
"""
type tokenTeam_aggregate {
  aggregate: tokenTeam_aggregate_fields
  nodes: [tokenTeam!]!
}

input tokenTeam_aggregate_bool_exp {
  count: tokenTeam_aggregate_bool_exp_count
}

input tokenTeam_aggregate_bool_exp_count {
  arguments: [tokenTeam_select_column!]
  distinct: Boolean
  filter: tokenTeam_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "tokenTeam"
"""
type tokenTeam_aggregate_fields {
  count(columns: [tokenTeam_select_column!], distinct: Boolean): Int!
  max: tokenTeam_max_fields
  min: tokenTeam_min_fields
}

"""
order by aggregate values of table "tokenTeam"
"""
input tokenTeam_aggregate_order_by {
  count: order_by
  max: tokenTeam_max_order_by
  min: tokenTeam_min_order_by
}

"""
input type for inserting array relation for remote table "tokenTeam"
"""
input tokenTeam_arr_rel_insert_input {
  data: [tokenTeam_insert_input!]!

  """upsert condition"""
  on_conflict: tokenTeam_on_conflict
}

"""
Boolean expression to filter rows from the table "tokenTeam". All fields are combined with a logical 'AND'.
"""
input tokenTeam_bool_exp {
  _and: [tokenTeam_bool_exp!]
  _not: tokenTeam_bool_exp
  _or: [tokenTeam_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  token: token_bool_exp
  tokenId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "tokenTeam"
"""
enum tokenTeam_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tokenTeam_pkey

  """
  unique or primary key constraint on columns "teamId", "tokenId"
  """
  tokenTeam_tokenId_teamId_key
}

"""
input type for inserting data into table "tokenTeam"
"""
input tokenTeam_insert_input {
  createdAt: timestamptz
  id: uuid
  team: team_obj_rel_insert_input
  teamId: uuid
  token: token_obj_rel_insert_input
  tokenId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type tokenTeam_max_fields {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "tokenTeam"
"""
input tokenTeam_max_order_by {
  createdAt: order_by
  id: order_by
  teamId: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type tokenTeam_min_fields {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "tokenTeam"
"""
input tokenTeam_min_order_by {
  createdAt: order_by
  id: order_by
  teamId: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "tokenTeam"
"""
type tokenTeam_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tokenTeam!]!
}

"""
on_conflict condition type for table "tokenTeam"
"""
input tokenTeam_on_conflict {
  constraint: tokenTeam_constraint!
  update_columns: [tokenTeam_update_column!]! = []
  where: tokenTeam_bool_exp
}

"""Ordering options when selecting data from "tokenTeam"."""
input tokenTeam_order_by {
  createdAt: order_by
  id: order_by
  team: team_order_by
  teamId: order_by
  token: token_order_by
  tokenId: order_by
  updatedAt: order_by
}

"""primary key columns input for table: tokenTeam"""
input tokenTeam_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tokenTeam"
"""
enum tokenTeam_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  teamId

  """column name"""
  tokenId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "tokenTeam"
"""
input tokenTeam_set_input {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "tokenTeam"
"""
input tokenTeam_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tokenTeam_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tokenTeam_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "tokenTeam"
"""
enum tokenTeam_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  teamId

  """column name"""
  tokenId

  """column name"""
  updatedAt
}

input tokenTeam_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: tokenTeam_set_input

  """filter the rows which have to be updated"""
  where: tokenTeam_bool_exp!
}

"""
aggregated selection of "token"
"""
type token_aggregate {
  aggregate: token_aggregate_fields
  nodes: [token!]!
}

input token_aggregate_bool_exp {
  count: token_aggregate_bool_exp_count
}

input token_aggregate_bool_exp_count {
  arguments: [token_select_column!]
  distinct: Boolean
  filter: token_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "token"
"""
type token_aggregate_fields {
  count(columns: [token_select_column!], distinct: Boolean): Int!
  max: token_max_fields
  min: token_min_fields
}

"""
order by aggregate values of table "token"
"""
input token_aggregate_order_by {
  count: order_by
  max: token_max_order_by
  min: token_min_order_by
}

"""
input type for inserting array relation for remote table "token"
"""
input token_arr_rel_insert_input {
  data: [token_insert_input!]!

  """upsert condition"""
  on_conflict: token_on_conflict
}

"""
Boolean expression to filter rows from the table "token". All fields are combined with a logical 'AND'.
"""
input token_bool_exp {
  _and: [token_bool_exp!]
  _not: token_bool_exp
  _or: [token_bool_exp!]
  createdAt: timestamptz_comparison_exp
  description: String_comparison_exp
  icon: String_comparison_exp
  id: uuid_comparison_exp
  integrationInstallations: integrationInstallation_bool_exp
  integrationInstallations_aggregate: integrationInstallation_aggregate_bool_exp
  lastUpdatedAt: timestamptz_comparison_exp
  lastUsedAt: timestamptz_comparison_exp
  name: String_comparison_exp
  owner: user_bool_exp
  ownerUserId: uuid_comparison_exp
  publicId: String_comparison_exp
  slug: String_comparison_exp
  tags: tokenTag_bool_exp
  tags_aggregate: tokenTag_aggregate_bool_exp
  teams: tokenTeam_bool_exp
  teams_aggregate: tokenTeam_aggregate_bool_exp
  tokenHash: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  usageHistory: usageHistory_bool_exp
  usageHistory_aggregate: usageHistory_aggregate_bool_exp
  userSecret: userSecret_bool_exp
  userSecret_aggregate: userSecret_aggregate_bool_exp
}

"""
unique or primary key constraints on table "token"
"""
enum token_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  token_pkey

  """
  unique or primary key constraint on columns "token"
  """
  token_token_key
}

"""
input type for inserting data into table "token"
"""
input token_insert_input {
  createdAt: timestamptz
  description: String
  icon: String
  id: uuid
  integrationInstallations: integrationInstallation_arr_rel_insert_input
  lastUpdatedAt: timestamptz
  name: String
  owner: user_obj_rel_insert_input
  ownerUserId: uuid
  publicId: String
  slug: String
  tags: tokenTag_arr_rel_insert_input
  teams: tokenTeam_arr_rel_insert_input
  tokenHash: String
  updatedAt: timestamptz
  usageHistory: usageHistory_arr_rel_insert_input
  userSecret: userSecret_arr_rel_insert_input
}

"""aggregate max on columns"""
type token_max_fields {
  createdAt: timestamptz
  description: String
  icon: String
  id: uuid
  lastUpdatedAt: timestamptz

  """
  A computed field, executes function "computeTokenLastUsedAt"
  """
  lastUsedAt: timestamptz
  name: String
  ownerUserId: uuid
  publicId: String
  slug: String
  tokenHash: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "token"
"""
input token_max_order_by {
  createdAt: order_by
  description: order_by
  icon: order_by
  id: order_by
  lastUpdatedAt: order_by
  name: order_by
  ownerUserId: order_by
  publicId: order_by
  slug: order_by
  tokenHash: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type token_min_fields {
  createdAt: timestamptz
  description: String
  icon: String
  id: uuid
  lastUpdatedAt: timestamptz

  """
  A computed field, executes function "computeTokenLastUsedAt"
  """
  lastUsedAt: timestamptz
  name: String
  ownerUserId: uuid
  publicId: String
  slug: String
  tokenHash: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "token"
"""
input token_min_order_by {
  createdAt: order_by
  description: order_by
  icon: order_by
  id: order_by
  lastUpdatedAt: order_by
  name: order_by
  ownerUserId: order_by
  publicId: order_by
  slug: order_by
  tokenHash: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "token"
"""
type token_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [token!]!
}

"""
input type for inserting object relation for remote table "token"
"""
input token_obj_rel_insert_input {
  data: token_insert_input!

  """upsert condition"""
  on_conflict: token_on_conflict
}

"""
on_conflict condition type for table "token"
"""
input token_on_conflict {
  constraint: token_constraint!
  update_columns: [token_update_column!]! = []
  where: token_bool_exp
}

"""Ordering options when selecting data from "token"."""
input token_order_by {
  createdAt: order_by
  description: order_by
  icon: order_by
  id: order_by
  integrationInstallations_aggregate: integrationInstallation_aggregate_order_by
  lastUpdatedAt: order_by
  lastUsedAt: order_by
  name: order_by
  owner: user_order_by
  ownerUserId: order_by
  publicId: order_by
  slug: order_by
  tags_aggregate: tokenTag_aggregate_order_by
  teams_aggregate: tokenTeam_aggregate_order_by
  tokenHash: order_by
  updatedAt: order_by
  usageHistory_aggregate: usageHistory_aggregate_order_by
  userSecret_aggregate: userSecret_aggregate_order_by
}

"""primary key columns input for table: token"""
input token_pk_columns_input {
  id: uuid!
}

"""
select columns of table "token"
"""
enum token_select_column {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  name

  """column name"""
  ownerUserId

  """column name"""
  publicId

  """column name"""
  slug

  """column name"""
  tokenHash

  """column name"""
  updatedAt
}

"""
input type for updating data in table "token"
"""
input token_set_input {
  createdAt: timestamptz
  description: String
  icon: String
  id: uuid
  lastUpdatedAt: timestamptz
  name: String
  ownerUserId: uuid
  publicId: String
  slug: String
  tokenHash: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "token"
"""
input token_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: token_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input token_stream_cursor_value_input {
  createdAt: timestamptz
  description: String
  icon: String
  id: uuid
  lastUpdatedAt: timestamptz
  name: String
  ownerUserId: uuid
  publicId: String
  slug: String
  tokenHash: String
  updatedAt: timestamptz
}

"""
update columns of table "token"
"""
enum token_update_column {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  name

  """column name"""
  ownerUserId

  """column name"""
  publicId

  """column name"""
  slug

  """column name"""
  tokenHash

  """column name"""
  updatedAt
}

input token_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: token_set_input

  """filter the rows which have to be updated"""
  where: token_bool_exp!
}

"""
columns and relationships of "usageHistory"
"""
type usageHistory {
  callerName: String
  createdAt: timestamptz!
  id: uuid!
  remoteIp: inet!

  """An array relationship"""
  secrets(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): [usageHistorySecret!]!

  """An aggregate relationship"""
  secrets_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): usageHistorySecret_aggregate!

  """An object relationship"""
  token: token!
  tokenId: uuid!
  updatedAt: timestamptz!
}

"""
columns and relationships of "usageHistorySecret"
"""
type usageHistorySecret {
  createdAt: timestamptz!
  id: uuid!
  updatedAt: timestamptz!

  """An object relationship"""
  usageHistory: usageHistory!
  usageHistoryId: uuid!

  """An object relationship"""
  userSecret: userSecret
  userSecretId: uuid
}

"""
aggregated selection of "usageHistorySecret"
"""
type usageHistorySecret_aggregate {
  aggregate: usageHistorySecret_aggregate_fields
  nodes: [usageHistorySecret!]!
}

input usageHistorySecret_aggregate_bool_exp {
  count: usageHistorySecret_aggregate_bool_exp_count
}

input usageHistorySecret_aggregate_bool_exp_count {
  arguments: [usageHistorySecret_select_column!]
  distinct: Boolean
  filter: usageHistorySecret_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "usageHistorySecret"
"""
type usageHistorySecret_aggregate_fields {
  count(columns: [usageHistorySecret_select_column!], distinct: Boolean): Int!
  max: usageHistorySecret_max_fields
  min: usageHistorySecret_min_fields
}

"""
order by aggregate values of table "usageHistorySecret"
"""
input usageHistorySecret_aggregate_order_by {
  count: order_by
  max: usageHistorySecret_max_order_by
  min: usageHistorySecret_min_order_by
}

"""
input type for inserting array relation for remote table "usageHistorySecret"
"""
input usageHistorySecret_arr_rel_insert_input {
  data: [usageHistorySecret_insert_input!]!

  """upsert condition"""
  on_conflict: usageHistorySecret_on_conflict
}

"""
Boolean expression to filter rows from the table "usageHistorySecret". All fields are combined with a logical 'AND'.
"""
input usageHistorySecret_bool_exp {
  _and: [usageHistorySecret_bool_exp!]
  _not: usageHistorySecret_bool_exp
  _or: [usageHistorySecret_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  usageHistory: usageHistory_bool_exp
  usageHistoryId: uuid_comparison_exp
  userSecret: userSecret_bool_exp
  userSecretId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "usageHistorySecret"
"""
enum usageHistorySecret_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  usageHistorySecret_pkey
}

"""
input type for inserting data into table "usageHistorySecret"
"""
input usageHistorySecret_insert_input {
  createdAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usageHistory: usageHistory_obj_rel_insert_input
  usageHistoryId: uuid
  userSecret: userSecret_obj_rel_insert_input
  userSecretId: uuid
}

"""aggregate max on columns"""
type usageHistorySecret_max_fields {
  createdAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usageHistoryId: uuid
  userSecretId: uuid
}

"""
order by max() on columns of table "usageHistorySecret"
"""
input usageHistorySecret_max_order_by {
  createdAt: order_by
  id: order_by
  updatedAt: order_by
  usageHistoryId: order_by
  userSecretId: order_by
}

"""aggregate min on columns"""
type usageHistorySecret_min_fields {
  createdAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usageHistoryId: uuid
  userSecretId: uuid
}

"""
order by min() on columns of table "usageHistorySecret"
"""
input usageHistorySecret_min_order_by {
  createdAt: order_by
  id: order_by
  updatedAt: order_by
  usageHistoryId: order_by
  userSecretId: order_by
}

"""
response of any mutation on the table "usageHistorySecret"
"""
type usageHistorySecret_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [usageHistorySecret!]!
}

"""
on_conflict condition type for table "usageHistorySecret"
"""
input usageHistorySecret_on_conflict {
  constraint: usageHistorySecret_constraint!
  update_columns: [usageHistorySecret_update_column!]! = []
  where: usageHistorySecret_bool_exp
}

"""Ordering options when selecting data from "usageHistorySecret"."""
input usageHistorySecret_order_by {
  createdAt: order_by
  id: order_by
  updatedAt: order_by
  usageHistory: usageHistory_order_by
  usageHistoryId: order_by
  userSecret: userSecret_order_by
  userSecretId: order_by
}

"""primary key columns input for table: usageHistorySecret"""
input usageHistorySecret_pk_columns_input {
  id: uuid!
}

"""
select columns of table "usageHistorySecret"
"""
enum usageHistorySecret_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  updatedAt

  """column name"""
  usageHistoryId

  """column name"""
  userSecretId
}

"""
input type for updating data in table "usageHistorySecret"
"""
input usageHistorySecret_set_input {
  createdAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usageHistoryId: uuid
  userSecretId: uuid
}

"""
Streaming cursor of the table "usageHistorySecret"
"""
input usageHistorySecret_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: usageHistorySecret_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input usageHistorySecret_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usageHistoryId: uuid
  userSecretId: uuid
}

"""
update columns of table "usageHistorySecret"
"""
enum usageHistorySecret_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  updatedAt

  """column name"""
  usageHistoryId

  """column name"""
  userSecretId
}

input usageHistorySecret_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: usageHistorySecret_set_input

  """filter the rows which have to be updated"""
  where: usageHistorySecret_bool_exp!
}

"""
aggregated selection of "usageHistory"
"""
type usageHistory_aggregate {
  aggregate: usageHistory_aggregate_fields
  nodes: [usageHistory!]!
}

input usageHistory_aggregate_bool_exp {
  count: usageHistory_aggregate_bool_exp_count
}

input usageHistory_aggregate_bool_exp_count {
  arguments: [usageHistory_select_column!]
  distinct: Boolean
  filter: usageHistory_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "usageHistory"
"""
type usageHistory_aggregate_fields {
  count(columns: [usageHistory_select_column!], distinct: Boolean): Int!
  max: usageHistory_max_fields
  min: usageHistory_min_fields
}

"""
order by aggregate values of table "usageHistory"
"""
input usageHistory_aggregate_order_by {
  count: order_by
  max: usageHistory_max_order_by
  min: usageHistory_min_order_by
}

"""
input type for inserting array relation for remote table "usageHistory"
"""
input usageHistory_arr_rel_insert_input {
  data: [usageHistory_insert_input!]!

  """upsert condition"""
  on_conflict: usageHistory_on_conflict
}

"""
Boolean expression to filter rows from the table "usageHistory". All fields are combined with a logical 'AND'.
"""
input usageHistory_bool_exp {
  _and: [usageHistory_bool_exp!]
  _not: usageHistory_bool_exp
  _or: [usageHistory_bool_exp!]
  callerName: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  remoteIp: inet_comparison_exp
  secrets: usageHistorySecret_bool_exp
  secrets_aggregate: usageHistorySecret_aggregate_bool_exp
  token: token_bool_exp
  tokenId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "usageHistory"
"""
enum usageHistory_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  usageHistory_pkey
}

"""
input type for inserting data into table "usageHistory"
"""
input usageHistory_insert_input {
  callerName: String
  createdAt: timestamptz
  id: uuid
  remoteIp: inet
  secrets: usageHistorySecret_arr_rel_insert_input
  token: token_obj_rel_insert_input
  tokenId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type usageHistory_max_fields {
  callerName: String
  createdAt: timestamptz
  id: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "usageHistory"
"""
input usageHistory_max_order_by {
  callerName: order_by
  createdAt: order_by
  id: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type usageHistory_min_fields {
  callerName: String
  createdAt: timestamptz
  id: uuid
  tokenId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "usageHistory"
"""
input usageHistory_min_order_by {
  callerName: order_by
  createdAt: order_by
  id: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "usageHistory"
"""
type usageHistory_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [usageHistory!]!
}

"""
input type for inserting object relation for remote table "usageHistory"
"""
input usageHistory_obj_rel_insert_input {
  data: usageHistory_insert_input!

  """upsert condition"""
  on_conflict: usageHistory_on_conflict
}

"""
on_conflict condition type for table "usageHistory"
"""
input usageHistory_on_conflict {
  constraint: usageHistory_constraint!
  update_columns: [usageHistory_update_column!]! = []
  where: usageHistory_bool_exp
}

"""Ordering options when selecting data from "usageHistory"."""
input usageHistory_order_by {
  callerName: order_by
  createdAt: order_by
  id: order_by
  remoteIp: order_by
  secrets_aggregate: usageHistorySecret_aggregate_order_by
  token: token_order_by
  tokenId: order_by
  updatedAt: order_by
}

"""primary key columns input for table: usageHistory"""
input usageHistory_pk_columns_input {
  id: uuid!
}

"""
select columns of table "usageHistory"
"""
enum usageHistory_select_column {
  """column name"""
  callerName

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  remoteIp

  """column name"""
  tokenId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "usageHistory"
"""
input usageHistory_set_input {
  callerName: String
  createdAt: timestamptz
  id: uuid
  remoteIp: inet
  tokenId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "usageHistory"
"""
input usageHistory_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: usageHistory_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input usageHistory_stream_cursor_value_input {
  callerName: String
  createdAt: timestamptz
  id: uuid
  remoteIp: inet
  tokenId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "usageHistory"
"""
enum usageHistory_update_column {
  """column name"""
  callerName

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  remoteIp

  """column name"""
  tokenId

  """column name"""
  updatedAt
}

input usageHistory_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: usageHistory_set_input

  """filter the rows which have to be updated"""
  where: usageHistory_bool_exp!
}

"""
columns and relationships of "user"
"""
type user {
  activeTeamId: uuid
  avatarUrl: String
  createdAt: timestamptz!
  email: String!
  githubId: Int
  googleId: String

  """A computed field which return the hasPassword boolean value"""
  hasPassword: Boolean
  id: uuid!

  """An array relationship"""
  invitation(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!

  """An aggregate relationship"""
  invitation_aggregate(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): teamInvitation_aggregate!
  isMarketingEmailsRequested: Boolean!
  name: String!

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): notificationUser_aggregate!
  password: String
  registrationStep: registrationStep_enum

  """An array relationship"""
  teams(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """An aggregate relationship"""
  teams_aggregate(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!

  """An array relationship"""
  tokens(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """An aggregate relationship"""
  tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!
  updatedAt: timestamptz!

  """An object relationship"""
  userSubscription: userSubscription

  """An object relationship"""
  user_activeTeam: team

  """An array relationship"""
  user_notificationUsers(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!

  """An aggregate relationship"""
  user_notificationUsers_aggregate(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): notificationUser_aggregate!

  """An array relationship"""
  user_teamInvitation(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!

  """An aggregate relationship"""
  user_teamInvitation_aggregate(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): teamInvitation_aggregate!
}

"""
columns and relationships of "userEmailChangeCode"
"""
type userEmailChangeCode {
  code: String!
  createdAt: timestamptz!
  expiresAt: timestamptz!
  id: uuid!
  updatedAt: timestamptz!
  usedAt: timestamptz
}

"""
aggregated selection of "userEmailChangeCode"
"""
type userEmailChangeCode_aggregate {
  aggregate: userEmailChangeCode_aggregate_fields
  nodes: [userEmailChangeCode!]!
}

"""
aggregate fields of "userEmailChangeCode"
"""
type userEmailChangeCode_aggregate_fields {
  count(columns: [userEmailChangeCode_select_column!], distinct: Boolean): Int!
  max: userEmailChangeCode_max_fields
  min: userEmailChangeCode_min_fields
}

"""
Boolean expression to filter rows from the table "userEmailChangeCode". All fields are combined with a logical 'AND'.
"""
input userEmailChangeCode_bool_exp {
  _and: [userEmailChangeCode_bool_exp!]
  _not: userEmailChangeCode_bool_exp
  _or: [userEmailChangeCode_bool_exp!]
  code: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  expiresAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  usedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "userEmailChangeCode"
"""
enum userEmailChangeCode_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  userEmailChangeCode_pkey
}

"""
input type for inserting data into table "userEmailChangeCode"
"""
input userEmailChangeCode_insert_input {
  code: String
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usedAt: timestamptz
}

"""aggregate max on columns"""
type userEmailChangeCode_max_fields {
  code: String
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usedAt: timestamptz
}

"""aggregate min on columns"""
type userEmailChangeCode_min_fields {
  code: String
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usedAt: timestamptz
}

"""
response of any mutation on the table "userEmailChangeCode"
"""
type userEmailChangeCode_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [userEmailChangeCode!]!
}

"""
on_conflict condition type for table "userEmailChangeCode"
"""
input userEmailChangeCode_on_conflict {
  constraint: userEmailChangeCode_constraint!
  update_columns: [userEmailChangeCode_update_column!]! = []
  where: userEmailChangeCode_bool_exp
}

"""Ordering options when selecting data from "userEmailChangeCode"."""
input userEmailChangeCode_order_by {
  code: order_by
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  updatedAt: order_by
  usedAt: order_by
}

"""primary key columns input for table: userEmailChangeCode"""
input userEmailChangeCode_pk_columns_input {
  id: uuid!
}

"""
select columns of table "userEmailChangeCode"
"""
enum userEmailChangeCode_select_column {
  """column name"""
  code

  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  updatedAt

  """column name"""
  usedAt
}

"""
input type for updating data in table "userEmailChangeCode"
"""
input userEmailChangeCode_set_input {
  code: String
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usedAt: timestamptz
}

"""
Streaming cursor of the table "userEmailChangeCode"
"""
input userEmailChangeCode_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: userEmailChangeCode_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input userEmailChangeCode_stream_cursor_value_input {
  code: String
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usedAt: timestamptz
}

"""
update columns of table "userEmailChangeCode"
"""
enum userEmailChangeCode_update_column {
  """column name"""
  code

  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  updatedAt

  """column name"""
  usedAt
}

input userEmailChangeCode_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: userEmailChangeCode_set_input

  """filter the rows which have to be updated"""
  where: userEmailChangeCode_bool_exp!
}

"""
columns and relationships of "userSecret"
"""
type userSecret {
  createdAt: timestamptz!

  """An array relationship"""
  fields(
    """distinct select on columns"""
    distinct_on: [userSecretField_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecretField_order_by!]

    """filter the rows returned"""
    where: userSecretField_bool_exp
  ): [userSecretField!]!

  """An aggregate relationship"""
  fields_aggregate(
    """distinct select on columns"""
    distinct_on: [userSecretField_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecretField_order_by!]

    """filter the rows returned"""
    where: userSecretField_bool_exp
  ): userSecretField_aggregate!
  id: uuid!

  """An array relationship"""
  installations(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): [integrationInstallationUserSecret!]!

  """An aggregate relationship"""
  installations_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): integrationInstallationUserSecret_aggregate!
  name: String!
  note: String!
  slug: String!

  """An object relationship"""
  token: token
  tokenId: uuid!
  updatedAt: timestamptz!

  """An array relationship"""
  userSecret_usageHistorySecrets(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): [usageHistorySecret!]!

  """An aggregate relationship"""
  userSecret_usageHistorySecrets_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): usageHistorySecret_aggregate!
  vendor: vendorEnum_enum!

  """An object relationship"""
  vendorEnum: vendorEnum!
}

"""
columns and relationships of "userSecretField"
"""
type userSecretField {
  createdAt: timestamptz!
  id: uuid!
  name: String!
  slug: String!
  updatedAt: timestamptz!

  """An object relationship"""
  userSecret: userSecret
  userSecretId: uuid!
  value: String!
}

"""
aggregated selection of "userSecretField"
"""
type userSecretField_aggregate {
  aggregate: userSecretField_aggregate_fields
  nodes: [userSecretField!]!
}

input userSecretField_aggregate_bool_exp {
  count: userSecretField_aggregate_bool_exp_count
}

input userSecretField_aggregate_bool_exp_count {
  arguments: [userSecretField_select_column!]
  distinct: Boolean
  filter: userSecretField_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "userSecretField"
"""
type userSecretField_aggregate_fields {
  count(columns: [userSecretField_select_column!], distinct: Boolean): Int!
  max: userSecretField_max_fields
  min: userSecretField_min_fields
}

"""
order by aggregate values of table "userSecretField"
"""
input userSecretField_aggregate_order_by {
  count: order_by
  max: userSecretField_max_order_by
  min: userSecretField_min_order_by
}

"""
input type for inserting array relation for remote table "userSecretField"
"""
input userSecretField_arr_rel_insert_input {
  data: [userSecretField_insert_input!]!

  """upsert condition"""
  on_conflict: userSecretField_on_conflict
}

"""
Boolean expression to filter rows from the table "userSecretField". All fields are combined with a logical 'AND'.
"""
input userSecretField_bool_exp {
  _and: [userSecretField_bool_exp!]
  _not: userSecretField_bool_exp
  _or: [userSecretField_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  slug: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userSecret: userSecret_bool_exp
  userSecretId: uuid_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "userSecretField"
"""
enum userSecretField_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  userSecretField_pkey
}

"""
input type for inserting data into table "userSecretField"
"""
input userSecretField_insert_input {
  createdAt: timestamptz
  id: uuid
  name: String
  slug: String
  updatedAt: timestamptz
  userSecret: userSecret_obj_rel_insert_input
  userSecretId: uuid
  value: String
}

"""aggregate max on columns"""
type userSecretField_max_fields {
  createdAt: timestamptz
  id: uuid
  name: String
  slug: String
  updatedAt: timestamptz
  userSecretId: uuid
  value: String
}

"""
order by max() on columns of table "userSecretField"
"""
input userSecretField_max_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  slug: order_by
  updatedAt: order_by
  userSecretId: order_by
  value: order_by
}

"""aggregate min on columns"""
type userSecretField_min_fields {
  createdAt: timestamptz
  id: uuid
  name: String
  slug: String
  updatedAt: timestamptz
  userSecretId: uuid
  value: String
}

"""
order by min() on columns of table "userSecretField"
"""
input userSecretField_min_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  slug: order_by
  updatedAt: order_by
  userSecretId: order_by
  value: order_by
}

"""
response of any mutation on the table "userSecretField"
"""
type userSecretField_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [userSecretField!]!
}

"""
on_conflict condition type for table "userSecretField"
"""
input userSecretField_on_conflict {
  constraint: userSecretField_constraint!
  update_columns: [userSecretField_update_column!]! = []
  where: userSecretField_bool_exp
}

"""Ordering options when selecting data from "userSecretField"."""
input userSecretField_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  slug: order_by
  updatedAt: order_by
  userSecret: userSecret_order_by
  userSecretId: order_by
  value: order_by
}

"""primary key columns input for table: userSecretField"""
input userSecretField_pk_columns_input {
  id: uuid!
}

"""
select columns of table "userSecretField"
"""
enum userSecretField_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  updatedAt

  """column name"""
  userSecretId

  """column name"""
  value
}

"""
input type for updating data in table "userSecretField"
"""
input userSecretField_set_input {
  createdAt: timestamptz
  id: uuid
  name: String
  slug: String
  updatedAt: timestamptz
  userSecretId: uuid
  value: String
}

"""
Streaming cursor of the table "userSecretField"
"""
input userSecretField_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: userSecretField_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input userSecretField_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  name: String
  slug: String
  updatedAt: timestamptz
  userSecretId: uuid
  value: String
}

"""
update columns of table "userSecretField"
"""
enum userSecretField_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  updatedAt

  """column name"""
  userSecretId

  """column name"""
  value
}

input userSecretField_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: userSecretField_set_input

  """filter the rows which have to be updated"""
  where: userSecretField_bool_exp!
}

"""
aggregated selection of "userSecret"
"""
type userSecret_aggregate {
  aggregate: userSecret_aggregate_fields
  nodes: [userSecret!]!
}

input userSecret_aggregate_bool_exp {
  count: userSecret_aggregate_bool_exp_count
}

input userSecret_aggregate_bool_exp_count {
  arguments: [userSecret_select_column!]
  distinct: Boolean
  filter: userSecret_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "userSecret"
"""
type userSecret_aggregate_fields {
  count(columns: [userSecret_select_column!], distinct: Boolean): Int!
  max: userSecret_max_fields
  min: userSecret_min_fields
}

"""
order by aggregate values of table "userSecret"
"""
input userSecret_aggregate_order_by {
  count: order_by
  max: userSecret_max_order_by
  min: userSecret_min_order_by
}

"""
input type for inserting array relation for remote table "userSecret"
"""
input userSecret_arr_rel_insert_input {
  data: [userSecret_insert_input!]!

  """upsert condition"""
  on_conflict: userSecret_on_conflict
}

"""
Boolean expression to filter rows from the table "userSecret". All fields are combined with a logical 'AND'.
"""
input userSecret_bool_exp {
  _and: [userSecret_bool_exp!]
  _not: userSecret_bool_exp
  _or: [userSecret_bool_exp!]
  createdAt: timestamptz_comparison_exp
  fields: userSecretField_bool_exp
  fields_aggregate: userSecretField_aggregate_bool_exp
  id: uuid_comparison_exp
  installations: integrationInstallationUserSecret_bool_exp
  installations_aggregate: integrationInstallationUserSecret_aggregate_bool_exp
  name: String_comparison_exp
  note: String_comparison_exp
  slug: String_comparison_exp
  token: token_bool_exp
  tokenId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userSecret_usageHistorySecrets: usageHistorySecret_bool_exp
  userSecret_usageHistorySecrets_aggregate: usageHistorySecret_aggregate_bool_exp
  vendor: vendorEnum_enum_comparison_exp
  vendorEnum: vendorEnum_bool_exp
}

"""
unique or primary key constraints on table "userSecret"
"""
enum userSecret_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  userSecret_pkey
}

"""
input type for inserting data into table "userSecret"
"""
input userSecret_insert_input {
  createdAt: timestamptz
  fields: userSecretField_arr_rel_insert_input
  id: uuid
  installations: integrationInstallationUserSecret_arr_rel_insert_input
  name: String
  note: String
  slug: String
  token: token_obj_rel_insert_input
  tokenId: uuid
  updatedAt: timestamptz
  userSecret_usageHistorySecrets: usageHistorySecret_arr_rel_insert_input
  vendor: vendorEnum_enum
  vendorEnum: vendorEnum_obj_rel_insert_input
}

"""aggregate max on columns"""
type userSecret_max_fields {
  createdAt: timestamptz
  id: uuid
  name: String
  note: String
  slug: String
  tokenId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "userSecret"
"""
input userSecret_max_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  note: order_by
  slug: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type userSecret_min_fields {
  createdAt: timestamptz
  id: uuid
  name: String
  note: String
  slug: String
  tokenId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "userSecret"
"""
input userSecret_min_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  note: order_by
  slug: order_by
  tokenId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "userSecret"
"""
type userSecret_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [userSecret!]!
}

"""
input type for inserting object relation for remote table "userSecret"
"""
input userSecret_obj_rel_insert_input {
  data: userSecret_insert_input!

  """upsert condition"""
  on_conflict: userSecret_on_conflict
}

"""
on_conflict condition type for table "userSecret"
"""
input userSecret_on_conflict {
  constraint: userSecret_constraint!
  update_columns: [userSecret_update_column!]! = []
  where: userSecret_bool_exp
}

"""Ordering options when selecting data from "userSecret"."""
input userSecret_order_by {
  createdAt: order_by
  fields_aggregate: userSecretField_aggregate_order_by
  id: order_by
  installations_aggregate: integrationInstallationUserSecret_aggregate_order_by
  name: order_by
  note: order_by
  slug: order_by
  token: token_order_by
  tokenId: order_by
  updatedAt: order_by
  userSecret_usageHistorySecrets_aggregate: usageHistorySecret_aggregate_order_by
  vendor: order_by
  vendorEnum: vendorEnum_order_by
}

"""primary key columns input for table: userSecret"""
input userSecret_pk_columns_input {
  id: uuid!
}

"""
select columns of table "userSecret"
"""
enum userSecret_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  note

  """column name"""
  slug

  """column name"""
  tokenId

  """column name"""
  updatedAt

  """column name"""
  vendor
}

"""
input type for updating data in table "userSecret"
"""
input userSecret_set_input {
  createdAt: timestamptz
  id: uuid
  name: String
  note: String
  slug: String
  tokenId: uuid
  updatedAt: timestamptz
  vendor: vendorEnum_enum
}

"""
Streaming cursor of the table "userSecret"
"""
input userSecret_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: userSecret_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input userSecret_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  name: String
  note: String
  slug: String
  tokenId: uuid
  updatedAt: timestamptz
  vendor: vendorEnum_enum
}

"""
update columns of table "userSecret"
"""
enum userSecret_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  note

  """column name"""
  slug

  """column name"""
  tokenId

  """column name"""
  updatedAt

  """column name"""
  vendor
}

input userSecret_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: userSecret_set_input

  """filter the rows which have to be updated"""
  where: userSecret_bool_exp!
}

"""User subscription data"""
type userSubscription {
  availableSeats: smallint!
  createdAt: timestamptz!
  id: uuid!
  paidSeats: smallint!
  stripeCustomerId: String
  stripeSubscriptionId: String
  subscriptionCancellationDate: timestamptz
  subscriptionExpirationDate: timestamptz
  subscriptionExpirationMessageRead: Boolean!
  subscriptionInterval: subscriptionIntervalEnum_enum
  subscriptionPlan: subscriptionPlanEnum_enum!
  subscriptionUpdatedAt: timestamptz
  updatedAt: timestamptz!

  """An object relationship"""
  user: user!
  userId: uuid!
}

"""
aggregated selection of "userSubscription"
"""
type userSubscription_aggregate {
  aggregate: userSubscription_aggregate_fields
  nodes: [userSubscription!]!
}

"""
aggregate fields of "userSubscription"
"""
type userSubscription_aggregate_fields {
  avg: userSubscription_avg_fields
  count(columns: [userSubscription_select_column!], distinct: Boolean): Int!
  max: userSubscription_max_fields
  min: userSubscription_min_fields
  stddev: userSubscription_stddev_fields
  stddev_pop: userSubscription_stddev_pop_fields
  stddev_samp: userSubscription_stddev_samp_fields
  sum: userSubscription_sum_fields
  var_pop: userSubscription_var_pop_fields
  var_samp: userSubscription_var_samp_fields
  variance: userSubscription_variance_fields
}

"""aggregate avg on columns"""
type userSubscription_avg_fields {
  availableSeats: Float
  paidSeats: Float
}

"""
Boolean expression to filter rows from the table "userSubscription". All fields are combined with a logical 'AND'.
"""
input userSubscription_bool_exp {
  _and: [userSubscription_bool_exp!]
  _not: userSubscription_bool_exp
  _or: [userSubscription_bool_exp!]
  availableSeats: smallint_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  paidSeats: smallint_comparison_exp
  stripeCustomerId: String_comparison_exp
  stripeSubscriptionId: String_comparison_exp
  subscriptionCancellationDate: timestamptz_comparison_exp
  subscriptionExpirationDate: timestamptz_comparison_exp
  subscriptionExpirationMessageRead: Boolean_comparison_exp
  subscriptionInterval: subscriptionIntervalEnum_enum_comparison_exp
  subscriptionPlan: subscriptionPlanEnum_enum_comparison_exp
  subscriptionUpdatedAt: timestamptz_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: user_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "userSubscription"
"""
enum userSubscription_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  userSubscription_pkey

  """
  unique or primary key constraint on columns "stripeCustomerId"
  """
  userSubscription_stripeCustomerId_key

  """
  unique or primary key constraint on columns "stripeSubscriptionId"
  """
  userSubscription_stripeSubscriptionId_key

  """
  unique or primary key constraint on columns "userId"
  """
  userSubscription_userId_key
}

"""
input type for incrementing numeric columns in table "userSubscription"
"""
input userSubscription_inc_input {
  availableSeats: smallint
  paidSeats: smallint
}

"""
input type for inserting data into table "userSubscription"
"""
input userSubscription_insert_input {
  availableSeats: smallint
  createdAt: timestamptz
  id: uuid
  paidSeats: smallint
  stripeCustomerId: String
  stripeSubscriptionId: String
  subscriptionCancellationDate: timestamptz
  subscriptionExpirationDate: timestamptz
  subscriptionExpirationMessageRead: Boolean
  subscriptionInterval: subscriptionIntervalEnum_enum
  subscriptionPlan: subscriptionPlanEnum_enum
  subscriptionUpdatedAt: timestamptz
  updatedAt: timestamptz
  user: user_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type userSubscription_max_fields {
  availableSeats: smallint
  createdAt: timestamptz
  id: uuid
  paidSeats: smallint
  stripeCustomerId: String
  stripeSubscriptionId: String
  subscriptionCancellationDate: timestamptz
  subscriptionExpirationDate: timestamptz
  subscriptionUpdatedAt: timestamptz
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate min on columns"""
type userSubscription_min_fields {
  availableSeats: smallint
  createdAt: timestamptz
  id: uuid
  paidSeats: smallint
  stripeCustomerId: String
  stripeSubscriptionId: String
  subscriptionCancellationDate: timestamptz
  subscriptionExpirationDate: timestamptz
  subscriptionUpdatedAt: timestamptz
  updatedAt: timestamptz
  userId: uuid
}

"""
response of any mutation on the table "userSubscription"
"""
type userSubscription_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [userSubscription!]!
}

"""
input type for inserting object relation for remote table "userSubscription"
"""
input userSubscription_obj_rel_insert_input {
  data: userSubscription_insert_input!

  """upsert condition"""
  on_conflict: userSubscription_on_conflict
}

"""
on_conflict condition type for table "userSubscription"
"""
input userSubscription_on_conflict {
  constraint: userSubscription_constraint!
  update_columns: [userSubscription_update_column!]! = []
  where: userSubscription_bool_exp
}

"""Ordering options when selecting data from "userSubscription"."""
input userSubscription_order_by {
  availableSeats: order_by
  createdAt: order_by
  id: order_by
  paidSeats: order_by
  stripeCustomerId: order_by
  stripeSubscriptionId: order_by
  subscriptionCancellationDate: order_by
  subscriptionExpirationDate: order_by
  subscriptionExpirationMessageRead: order_by
  subscriptionInterval: order_by
  subscriptionPlan: order_by
  subscriptionUpdatedAt: order_by
  updatedAt: order_by
  user: user_order_by
  userId: order_by
}

"""primary key columns input for table: userSubscription"""
input userSubscription_pk_columns_input {
  id: uuid!
}

"""
select columns of table "userSubscription"
"""
enum userSubscription_select_column {
  """column name"""
  availableSeats

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  paidSeats

  """column name"""
  stripeCustomerId

  """column name"""
  stripeSubscriptionId

  """column name"""
  subscriptionCancellationDate

  """column name"""
  subscriptionExpirationDate

  """column name"""
  subscriptionExpirationMessageRead

  """column name"""
  subscriptionInterval

  """column name"""
  subscriptionPlan

  """column name"""
  subscriptionUpdatedAt

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "userSubscription"
"""
input userSubscription_set_input {
  availableSeats: smallint
  createdAt: timestamptz
  id: uuid
  paidSeats: smallint
  stripeCustomerId: String
  stripeSubscriptionId: String
  subscriptionCancellationDate: timestamptz
  subscriptionExpirationDate: timestamptz
  subscriptionExpirationMessageRead: Boolean
  subscriptionInterval: subscriptionIntervalEnum_enum
  subscriptionPlan: subscriptionPlanEnum_enum
  subscriptionUpdatedAt: timestamptz
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate stddev on columns"""
type userSubscription_stddev_fields {
  availableSeats: Float
  paidSeats: Float
}

"""aggregate stddev_pop on columns"""
type userSubscription_stddev_pop_fields {
  availableSeats: Float
  paidSeats: Float
}

"""aggregate stddev_samp on columns"""
type userSubscription_stddev_samp_fields {
  availableSeats: Float
  paidSeats: Float
}

"""
Streaming cursor of the table "userSubscription"
"""
input userSubscription_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: userSubscription_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input userSubscription_stream_cursor_value_input {
  availableSeats: smallint
  createdAt: timestamptz
  id: uuid
  paidSeats: smallint
  stripeCustomerId: String
  stripeSubscriptionId: String
  subscriptionCancellationDate: timestamptz
  subscriptionExpirationDate: timestamptz
  subscriptionExpirationMessageRead: Boolean
  subscriptionInterval: subscriptionIntervalEnum_enum
  subscriptionPlan: subscriptionPlanEnum_enum
  subscriptionUpdatedAt: timestamptz
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate sum on columns"""
type userSubscription_sum_fields {
  availableSeats: smallint
  paidSeats: smallint
}

"""
update columns of table "userSubscription"
"""
enum userSubscription_update_column {
  """column name"""
  availableSeats

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  paidSeats

  """column name"""
  stripeCustomerId

  """column name"""
  stripeSubscriptionId

  """column name"""
  subscriptionCancellationDate

  """column name"""
  subscriptionExpirationDate

  """column name"""
  subscriptionExpirationMessageRead

  """column name"""
  subscriptionInterval

  """column name"""
  subscriptionPlan

  """column name"""
  subscriptionUpdatedAt

  """column name"""
  updatedAt

  """column name"""
  userId
}

input userSubscription_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: userSubscription_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: userSubscription_set_input

  """filter the rows which have to be updated"""
  where: userSubscription_bool_exp!
}

"""aggregate var_pop on columns"""
type userSubscription_var_pop_fields {
  availableSeats: Float
  paidSeats: Float
}

"""aggregate var_samp on columns"""
type userSubscription_var_samp_fields {
  availableSeats: Float
  paidSeats: Float
}

"""aggregate variance on columns"""
type userSubscription_variance_fields {
  availableSeats: Float
  paidSeats: Float
}

type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  avg: user_avg_fields
  count(columns: [user_select_column!], distinct: Boolean): Int!
  max: user_max_fields
  min: user_min_fields
  stddev: user_stddev_fields
  stddev_pop: user_stddev_pop_fields
  stddev_samp: user_stddev_samp_fields
  sum: user_sum_fields
  var_pop: user_var_pop_fields
  var_samp: user_var_samp_fields
  variance: user_variance_fields
}

"""aggregate avg on columns"""
type user_avg_fields {
  githubId: Float
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  activeTeamId: uuid_comparison_exp
  avatarUrl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  email: String_comparison_exp
  githubId: Int_comparison_exp
  googleId: String_comparison_exp
  hasPassword: Boolean_comparison_exp
  id: uuid_comparison_exp
  invitation: teamInvitation_bool_exp
  invitation_aggregate: teamInvitation_aggregate_bool_exp
  isMarketingEmailsRequested: Boolean_comparison_exp
  name: String_comparison_exp
  notifications: notificationUser_bool_exp
  notifications_aggregate: notificationUser_aggregate_bool_exp
  password: String_comparison_exp
  registrationStep: registrationStep_enum_comparison_exp
  teams: teamUser_bool_exp
  teams_aggregate: teamUser_aggregate_bool_exp
  tokens: token_bool_exp
  tokens_aggregate: token_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
  userSubscription: userSubscription_bool_exp
  user_activeTeam: team_bool_exp
  user_notificationUsers: notificationUser_bool_exp
  user_notificationUsers_aggregate: notificationUser_aggregate_bool_exp
  user_teamInvitation: teamInvitation_bool_exp
  user_teamInvitation_aggregate: teamInvitation_aggregate_bool_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  user_email_key

  """
  unique or primary key constraint on columns "name", "email"
  """
  user_name_email_key

  """
  unique or primary key constraint on columns "id"
  """
  user_pkey
}

"""
input type for incrementing numeric columns in table "user"
"""
input user_inc_input {
  githubId: Int
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  activeTeamId: uuid
  avatarUrl: String
  createdAt: timestamptz
  email: String
  githubId: Int
  googleId: String
  id: uuid
  invitation: teamInvitation_arr_rel_insert_input
  isMarketingEmailsRequested: Boolean
  name: String
  notifications: notificationUser_arr_rel_insert_input
  password: String
  registrationStep: registrationStep_enum
  teams: teamUser_arr_rel_insert_input
  tokens: token_arr_rel_insert_input
  updatedAt: timestamptz
  userSubscription: userSubscription_obj_rel_insert_input
  user_activeTeam: team_obj_rel_insert_input
  user_notificationUsers: notificationUser_arr_rel_insert_input
  user_teamInvitation: teamInvitation_arr_rel_insert_input
}

"""aggregate max on columns"""
type user_max_fields {
  activeTeamId: uuid
  avatarUrl: String
  createdAt: timestamptz
  email: String
  githubId: Int
  googleId: String
  id: uuid
  name: String
  password: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type user_min_fields {
  activeTeamId: uuid
  avatarUrl: String
  createdAt: timestamptz
  email: String
  githubId: Int
  googleId: String
  id: uuid
  name: String
  password: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!

  """upsert condition"""
  on_conflict: user_on_conflict
}

"""
on_conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]! = []
  where: user_bool_exp
}

"""Ordering options when selecting data from "user"."""
input user_order_by {
  activeTeamId: order_by
  avatarUrl: order_by
  createdAt: order_by
  email: order_by
  githubId: order_by
  googleId: order_by
  hasPassword: order_by
  id: order_by
  invitation_aggregate: teamInvitation_aggregate_order_by
  isMarketingEmailsRequested: order_by
  name: order_by
  notifications_aggregate: notificationUser_aggregate_order_by
  password: order_by
  registrationStep: order_by
  teams_aggregate: teamUser_aggregate_order_by
  tokens_aggregate: token_aggregate_order_by
  updatedAt: order_by
  userSubscription: userSubscription_order_by
  user_activeTeam: team_order_by
  user_notificationUsers_aggregate: notificationUser_aggregate_order_by
  user_teamInvitation_aggregate: teamInvitation_aggregate_order_by
}

"""primary key columns input for table: user"""
input user_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  activeTeamId

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  githubId

  """column name"""
  googleId

  """column name"""
  id

  """column name"""
  isMarketingEmailsRequested

  """column name"""
  name

  """column name"""
  password

  """column name"""
  registrationStep

  """column name"""
  updatedAt
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  activeTeamId: uuid
  avatarUrl: String
  createdAt: timestamptz
  email: String
  githubId: Int
  googleId: String
  id: uuid
  isMarketingEmailsRequested: Boolean
  name: String
  password: String
  registrationStep: registrationStep_enum
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type user_stddev_fields {
  githubId: Float
}

"""aggregate stddev_pop on columns"""
type user_stddev_pop_fields {
  githubId: Float
}

"""aggregate stddev_samp on columns"""
type user_stddev_samp_fields {
  githubId: Float
}

"""
Streaming cursor of the table "user"
"""
input user_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_stream_cursor_value_input {
  activeTeamId: uuid
  avatarUrl: String
  createdAt: timestamptz
  email: String
  githubId: Int
  googleId: String
  id: uuid
  isMarketingEmailsRequested: Boolean
  name: String
  password: String
  registrationStep: registrationStep_enum
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type user_sum_fields {
  githubId: Int
}

"""
update columns of table "user"
"""
enum user_update_column {
  """column name"""
  activeTeamId

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  githubId

  """column name"""
  googleId

  """column name"""
  id

  """column name"""
  isMarketingEmailsRequested

  """column name"""
  name

  """column name"""
  password

  """column name"""
  registrationStep

  """column name"""
  updatedAt
}

input user_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: user_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_set_input

  """filter the rows which have to be updated"""
  where: user_bool_exp!
}

"""aggregate var_pop on columns"""
type user_var_pop_fields {
  githubId: Float
}

"""aggregate var_samp on columns"""
type user_var_samp_fields {
  githubId: Float
}

"""aggregate variance on columns"""
type user_variance_fields {
  githubId: Float
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "vendorEnum"
"""
type vendorEnum {
  description: String
  value: String!
}

"""
aggregated selection of "vendorEnum"
"""
type vendorEnum_aggregate {
  aggregate: vendorEnum_aggregate_fields
  nodes: [vendorEnum!]!
}

"""
aggregate fields of "vendorEnum"
"""
type vendorEnum_aggregate_fields {
  count(columns: [vendorEnum_select_column!], distinct: Boolean): Int!
  max: vendorEnum_max_fields
  min: vendorEnum_min_fields
}

"""
Boolean expression to filter rows from the table "vendorEnum". All fields are combined with a logical 'AND'.
"""
input vendorEnum_bool_exp {
  _and: [vendorEnum_bool_exp!]
  _not: vendorEnum_bool_exp
  _or: [vendorEnum_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "vendorEnum"
"""
enum vendorEnum_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  vendorEnum_pkey
}

enum vendorEnum_enum {
  agora
  aws
  azure
  braintree
  digitalOcean
  googleCloud
  mailchimp
  mixpanel
  other
  paypal
  pulumi
  segment
  sendgrid
  stripe
  terraform
  twilio
}

"""
Boolean expression to compare columns of type "vendorEnum_enum". All fields are combined with logical 'AND'.
"""
input vendorEnum_enum_comparison_exp {
  _eq: vendorEnum_enum
  _in: [vendorEnum_enum!]
  _is_null: Boolean
  _neq: vendorEnum_enum
  _nin: [vendorEnum_enum!]
}

"""
input type for inserting data into table "vendorEnum"
"""
input vendorEnum_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type vendorEnum_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type vendorEnum_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "vendorEnum"
"""
type vendorEnum_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [vendorEnum!]!
}

"""
input type for inserting object relation for remote table "vendorEnum"
"""
input vendorEnum_obj_rel_insert_input {
  data: vendorEnum_insert_input!

  """upsert condition"""
  on_conflict: vendorEnum_on_conflict
}

"""
on_conflict condition type for table "vendorEnum"
"""
input vendorEnum_on_conflict {
  constraint: vendorEnum_constraint!
  update_columns: [vendorEnum_update_column!]! = []
  where: vendorEnum_bool_exp
}

"""Ordering options when selecting data from "vendorEnum"."""
input vendorEnum_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: vendorEnum"""
input vendorEnum_pk_columns_input {
  value: String!
}

"""
select columns of table "vendorEnum"
"""
enum vendorEnum_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "vendorEnum"
"""
input vendorEnum_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "vendorEnum"
"""
input vendorEnum_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: vendorEnum_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input vendorEnum_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "vendorEnum"
"""
enum vendorEnum_update_column {
  """column name"""
  description

  """column name"""
  value
}

input vendorEnum_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: vendorEnum_set_input

  """filter the rows which have to be updated"""
  where: vendorEnum_bool_exp!
}

"""
columns and relationships of "verification"
"""
type verification {
  code: String!
  createdAt: timestamptz!
  expiresAt: timestamptz!
  id: uuid!
  type: verificationTypeEnum_enum!
  updatedAt: timestamptz!
  usedAt: timestamptz
  value: String
}

"""
columns and relationships of "verificationTypeEnum"
"""
type verificationTypeEnum {
  value: String!
}

"""
aggregated selection of "verificationTypeEnum"
"""
type verificationTypeEnum_aggregate {
  aggregate: verificationTypeEnum_aggregate_fields
  nodes: [verificationTypeEnum!]!
}

"""
aggregate fields of "verificationTypeEnum"
"""
type verificationTypeEnum_aggregate_fields {
  count(columns: [verificationTypeEnum_select_column!], distinct: Boolean): Int!
  max: verificationTypeEnum_max_fields
  min: verificationTypeEnum_min_fields
}

"""
Boolean expression to filter rows from the table "verificationTypeEnum". All fields are combined with a logical 'AND'.
"""
input verificationTypeEnum_bool_exp {
  _and: [verificationTypeEnum_bool_exp!]
  _not: verificationTypeEnum_bool_exp
  _or: [verificationTypeEnum_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "verificationTypeEnum"
"""
enum verificationTypeEnum_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  verificationTypeEnum_pkey
}

enum verificationTypeEnum_enum {
  EMAIL
  PASSWORD
}

"""
Boolean expression to compare columns of type "verificationTypeEnum_enum". All fields are combined with logical 'AND'.
"""
input verificationTypeEnum_enum_comparison_exp {
  _eq: verificationTypeEnum_enum
  _in: [verificationTypeEnum_enum!]
  _is_null: Boolean
  _neq: verificationTypeEnum_enum
  _nin: [verificationTypeEnum_enum!]
}

"""
input type for inserting data into table "verificationTypeEnum"
"""
input verificationTypeEnum_insert_input {
  value: String
}

"""aggregate max on columns"""
type verificationTypeEnum_max_fields {
  value: String
}

"""aggregate min on columns"""
type verificationTypeEnum_min_fields {
  value: String
}

"""
response of any mutation on the table "verificationTypeEnum"
"""
type verificationTypeEnum_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [verificationTypeEnum!]!
}

"""
on_conflict condition type for table "verificationTypeEnum"
"""
input verificationTypeEnum_on_conflict {
  constraint: verificationTypeEnum_constraint!
  update_columns: [verificationTypeEnum_update_column!]! = []
  where: verificationTypeEnum_bool_exp
}

"""Ordering options when selecting data from "verificationTypeEnum"."""
input verificationTypeEnum_order_by {
  value: order_by
}

"""primary key columns input for table: verificationTypeEnum"""
input verificationTypeEnum_pk_columns_input {
  value: String!
}

"""
select columns of table "verificationTypeEnum"
"""
enum verificationTypeEnum_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "verificationTypeEnum"
"""
input verificationTypeEnum_set_input {
  value: String
}

"""
Streaming cursor of the table "verificationTypeEnum"
"""
input verificationTypeEnum_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: verificationTypeEnum_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input verificationTypeEnum_stream_cursor_value_input {
  value: String
}

"""
update columns of table "verificationTypeEnum"
"""
enum verificationTypeEnum_update_column {
  """column name"""
  value
}

input verificationTypeEnum_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: verificationTypeEnum_set_input

  """filter the rows which have to be updated"""
  where: verificationTypeEnum_bool_exp!
}

"""
aggregated selection of "verification"
"""
type verification_aggregate {
  aggregate: verification_aggregate_fields
  nodes: [verification!]!
}

"""
aggregate fields of "verification"
"""
type verification_aggregate_fields {
  count(columns: [verification_select_column!], distinct: Boolean): Int!
  max: verification_max_fields
  min: verification_min_fields
}

"""
Boolean expression to filter rows from the table "verification". All fields are combined with a logical 'AND'.
"""
input verification_bool_exp {
  _and: [verification_bool_exp!]
  _not: verification_bool_exp
  _or: [verification_bool_exp!]
  code: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  expiresAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  type: verificationTypeEnum_enum_comparison_exp
  updatedAt: timestamptz_comparison_exp
  usedAt: timestamptz_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "verification"
"""
enum verification_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  verification_pkey
}

"""
input type for inserting data into table "verification"
"""
input verification_insert_input {
  code: String
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  type: verificationTypeEnum_enum
  updatedAt: timestamptz
  usedAt: timestamptz
  value: String
}

"""aggregate max on columns"""
type verification_max_fields {
  code: String
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usedAt: timestamptz
  value: String
}

"""aggregate min on columns"""
type verification_min_fields {
  code: String
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usedAt: timestamptz
  value: String
}

"""
response of any mutation on the table "verification"
"""
type verification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [verification!]!
}

"""
on_conflict condition type for table "verification"
"""
input verification_on_conflict {
  constraint: verification_constraint!
  update_columns: [verification_update_column!]! = []
  where: verification_bool_exp
}

"""Ordering options when selecting data from "verification"."""
input verification_order_by {
  code: order_by
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  type: order_by
  updatedAt: order_by
  usedAt: order_by
  value: order_by
}

"""primary key columns input for table: verification"""
input verification_pk_columns_input {
  id: uuid!
}

"""
select columns of table "verification"
"""
enum verification_select_column {
  """column name"""
  code

  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  type

  """column name"""
  updatedAt

  """column name"""
  usedAt

  """column name"""
  value
}

"""
input type for updating data in table "verification"
"""
input verification_set_input {
  code: String
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  type: verificationTypeEnum_enum
  updatedAt: timestamptz
  usedAt: timestamptz
  value: String
}

"""
Streaming cursor of the table "verification"
"""
input verification_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: verification_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input verification_stream_cursor_value_input {
  code: String
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  type: verificationTypeEnum_enum
  updatedAt: timestamptz
  usedAt: timestamptz
  value: String
}

"""
update columns of table "verification"
"""
enum verification_update_column {
  """column name"""
  code

  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  type

  """column name"""
  updatedAt

  """column name"""
  usedAt

  """column name"""
  value
}

input verification_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: verification_set_input

  """filter the rows which have to be updated"""
  where: verification_bool_exp!
}

